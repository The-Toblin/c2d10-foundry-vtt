{"version":3,"file":"loadBasis.mjs","sources":["../../src/loader/loadBasis.ts"],"sourcesContent":["import { checkExtension, createTexture, LoaderParserPriority } from '@pixi/assets';\nimport { CompressedTextureResource } from '@pixi/compressed-textures';\nimport { ALPHA_MODES, BaseTexture, extensions, ExtensionType, FORMATS, MIPMAP_MODES, settings } from '@pixi/core';\nimport { BASIS_FORMAT_TO_TYPE, BASIS_FORMATS } from '../Basis';\nimport { TranscoderWorker } from '../TranscoderWorker';\nimport { BasisParser } from './BasisParser';\n\nimport type { Loader, LoaderParser, ResolvedAsset } from '@pixi/assets';\nimport type { IBaseTextureOptions, Texture, TYPES } from '@pixi/core';\n\n/** Load BASIS textures! */\nexport const loadBasis = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.High,\n    },\n\n    name: 'loadBasis',\n\n    test(url: string): boolean\n    {\n        return checkExtension(url, '.basis');\n    },\n\n    async load(url: string, asset: ResolvedAsset, loader: Loader): Promise<Texture | Texture[]>\n    {\n        await TranscoderWorker.onTranscoderInitialized;\n\n        // get an array buffer...\n        const response = await settings.ADAPTER.fetch(url);\n\n        const arrayBuffer = await response.arrayBuffer();\n\n        const resources = await BasisParser.transcode(arrayBuffer);\n\n        const type: TYPES = BASIS_FORMAT_TO_TYPE[resources.basisFormat];\n        const format: FORMATS = resources.basisFormat !== BASIS_FORMATS.cTFRGBA32 ? FORMATS.RGB : FORMATS.RGBA;\n\n        const textures = resources.map((resource) =>\n        {\n            const base = new BaseTexture(resource, {\n                mipmap: resource instanceof CompressedTextureResource && resource.levels > 1\n                    ? MIPMAP_MODES.ON_MANUAL\n                    : MIPMAP_MODES.OFF,\n                alphaMode: ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,\n                type,\n                format,\n                ...asset.data,\n            });\n\n            return createTexture(base, loader, url);\n        });\n\n        return textures.length === 1 ? textures[0] : textures;\n    },\n\n    unload(texture): void\n    {\n        if (Array.isArray(texture))\n        {\n            texture.forEach((t) => t.destroy(true));\n        }\n        else\n        {\n            texture.destroy(true);\n        }\n    }\n\n} as LoaderParser<Texture | Texture[], IBaseTextureOptions>;\n\nextensions.add(loadBasis);\n"],"names":[],"mappings":";;;;;;AAWO,MAAM,YAAY;AAAA,EACrB,WAAW;AAAA,IACP,MAAM,cAAc;AAAA,IACpB,UAAU,qBAAqB;AAAA,EACnC;AAAA,EAEA,MAAM;AAAA,EAEN,KAAK,KACL;AACW,WAAA,eAAe,KAAK,QAAQ;AAAA,EACvC;AAAA,EAEA,MAAM,KAAK,KAAa,OAAsB,QAC9C;AACI,UAAM,iBAAiB;AAKvB,UAAM,cAAc,OAFH,MAAM,SAAS,QAAQ,MAAM,GAAG,GAEd,eAE7B,YAAY,MAAM,YAAY,UAAU,WAAW,GAEnD,OAAc,qBAAqB,UAAU,WAAW,GACxD,SAAkB,UAAU,gBAAgB,cAAc,YAAY,QAAQ,MAAM,QAAQ,MAE5F,WAAW,UAAU,IAAI,CAAC,aAChC;AACU,YAAA,OAAO,IAAI,YAAY,UAAU;AAAA,QACnC,QAAQ,oBAAoB,6BAA6B,SAAS,SAAS,IACrE,aAAa,YACb,aAAa;AAAA,QACnB,WAAW,YAAY;AAAA,QACvB;AAAA,QACA;AAAA,QACA,GAAG,MAAM;AAAA,MAAA,CACZ;AAEM,aAAA,cAAc,MAAM,QAAQ,GAAG;AAAA,IAAA,CACzC;AAED,WAAO,SAAS,WAAW,IAAI,SAAS,CAAC,IAAI;AAAA,EACjD;AAAA,EAEA,OAAO,SACP;AACQ,UAAM,QAAQ,OAAO,IAErB,QAAQ,QAAQ,CAAC,MAAM,EAAE,QAAQ,EAAI,CAAC,IAItC,QAAQ,QAAQ,EAAI;AAAA,EAE5B;AAEJ;AAEA,WAAW,IAAI,SAAS;"}