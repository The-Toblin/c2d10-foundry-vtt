{"version":3,"file":"TranscoderWorkerWrapper.js","sources":["../src/TranscoderWorkerWrapper.ts"],"sourcesContent":["import type { BASIS, BASIS_FORMATS, BasisBinding } from './Basis';\n\n/**\n * Initialization message sent by the main thread.\n * @ignore\n */\nexport interface IInitializeTranscoderMessage\n{\n    wasmSource: ArrayBuffer;\n    type: 'init';\n}\n\n/**\n * Request parameters for transcoding basis files. It only supports transcoding all of the basis file at once.\n * @ignore\n */\nexport interface ITranscodeMessage\n{\n    requestID?: number;\n    rgbFormat: number;\n    rgbaFormat?: number;\n    basisData?: Uint8Array;\n    type: 'transcode';\n}\n\n/** @ignore */\nexport interface ITranscodedImage\n{\n    imageID: number;\n    levelArray: Array<{\n        levelID: number,\n        levelWidth: number,\n        levelHeight: number,\n        levelBuffer: Uint8Array\n    }>;\n    width: number;\n    height: number;\n}\n\n/**\n * Response format for {@link PIXI.TranscoderWorker}.\n * @ignore\n */\nexport interface ITranscodeResponse\n{\n    type: 'init' | 'transcode';\n    requestID?: number;\n    success: boolean;\n    basisFormat?: BASIS_FORMATS;\n    imageArray?: Array<{\n        imageID: number,\n        levelArray: Array<{\n            levelID: number,\n            levelWidth: number,\n            levelHeight: number,\n            levelBuffer: Uint8Array\n        }>,\n        width: number,\n        height: number\n    }>;\n}\n\ndeclare global\n{\n    interface Window\n    {\n        BASIS: BASIS;\n    }\n}\n\n/**\n * This wraps the transcoder web-worker functionality; it can be converted into a string to get the source code. It expects\n * you to prepend the transcoder JavaScript code so that the `BASIS` namespace is available.\n *\n * The transcoder worker responds to two types of messages: \"init\" and \"transcode\". You must always send the first \"init\"\n * {@link IInitializeTranscoderMessage} message with the WebAssembly binary; if the transcoder is successfully initialized,\n * the web-worker will respond by sending another {@link ITranscodeResponse} message with `success: true`.\n * @ignore\n */\nexport function TranscoderWorkerWrapper(): void\n{\n    let basisBinding: BasisBinding;\n\n    const messageHandlers = {\n        init: (message: IInitializeTranscoderMessage): ITranscodeResponse =>\n        {\n            if (!self.BASIS)\n            {\n                console.warn('jsSource was not prepended?');\n\n                return {\n                    type: 'init',\n                    success: false\n                };\n            }\n\n            self.BASIS({ wasmBinary: message.wasmSource }).then((basisLibrary) =>\n            {\n                basisLibrary.initializeBasis();\n                basisBinding = basisLibrary;\n\n                (self as any).postMessage({\n                    type: 'init',\n                    success: true\n                });\n            });\n\n            return null;\n        },\n        transcode(message: ITranscodeMessage): ITranscodeResponse\n        {\n            const basisData = message.basisData;\n            const BASIS = basisBinding;\n\n            const data = basisData;\n            const basisFile = new BASIS.BasisFile(data);\n            const imageCount = basisFile.getNumImages();\n            const hasAlpha = basisFile.getHasAlpha();\n\n            const basisFormat = hasAlpha\n                ? message.rgbaFormat\n                : message.rgbFormat;\n            const basisFallbackFormat = 14;// BASIS_FORMATS.cTFRGB565 (cannot import values into web-worker!)\n            const imageArray = new Array(imageCount);\n\n            let fallbackMode = false;\n\n            if (!basisFile.startTranscoding())\n            {\n                basisFile.close();\n                basisFile.delete();\n\n                return {\n                    type: 'transcode',\n                    requestID: message.requestID,\n                    success: false,\n                    imageArray: null\n                };\n            }\n\n            for (let i = 0; i < imageCount; i++)\n            {\n                const levels = basisFile.getNumLevels(i);\n                const imageResource: ITranscodedImage = {\n                    imageID: i,\n                    levelArray: new Array<{\n                        levelID: number,\n                        levelWidth: number,\n                        levelHeight: number,\n                        levelBuffer: Uint8Array\n                    }>(),\n                    width: null,\n                    height: null\n                };\n\n                for (let j = 0; j < levels; j++)\n                {\n                    const format = !fallbackMode ? basisFormat : basisFallbackFormat;\n\n                    const width = basisFile.getImageWidth(i, j);\n                    const height = basisFile.getImageHeight(i, j);\n                    const byteSize = basisFile.getImageTranscodedSizeInBytes(i, j, format);\n\n                    const alignedWidth = (width + 3) & ~3;\n                    const alignedHeight = (height + 3) & ~3;\n\n                    // Level 0 is texture's actual width, height\n                    if (j === 0)\n                    {\n                        imageResource.width = alignedWidth;\n                        imageResource.height = alignedHeight;\n                    }\n\n                    const imageBuffer = new Uint8Array(byteSize);\n\n                    if (!basisFile.transcodeImage(imageBuffer, i, j, format, false, false))\n                    {\n                        if (fallbackMode)\n                        {\n                            // We failed in fallback mode as well!\n                            console.error(`Basis failed to transcode image ${i}, level ${j}!`);\n\n                            return { type: 'transcode', requestID: message.requestID, success: false };\n                        }\n\n                        /* eslint-disable-next-line max-len */\n                        console.warn(`Basis failed to transcode image ${i}, level ${j}! Retrying to an uncompressed texture format!`);\n                        i = -1;\n                        fallbackMode = true;\n\n                        break;\n                    }\n\n                    imageResource.levelArray.push({\n                        levelID: j,\n                        levelWidth: width,\n                        levelHeight: height,\n                        levelBuffer: imageBuffer\n                    });\n                }\n\n                imageArray[i] = imageResource;\n            }\n\n            basisFile.close();\n            basisFile.delete();\n\n            return {\n                type: 'transcode',\n                requestID: message.requestID,\n                success: true,\n                basisFormat: !fallbackMode ? basisFormat : basisFallbackFormat,\n                imageArray\n            };\n        }\n    };\n\n    self.onmessage = (e: { data: Partial<IInitializeTranscoderMessage | ITranscodeMessage> }): void =>\n    {\n        const msg = e.data;\n        const response = messageHandlers[msg.type](msg as any);\n\n        if (response)\n        {\n            (self as any).postMessage(response);\n        }\n    };\n}\n"],"names":[],"mappings":";AA+EO,SAAS,0BAChB;AACQ,MAAA;AAEJ,QAAM,kBAAkB;AAAA,IACpB,MAAM,CAAC,YAEE,KAAK,SAUV,KAAK,MAAM,EAAE,YAAY,QAAQ,WAAW,CAAC,EAAE,KAAK,CAAC,iBACrD;AACI,mBAAa,gBAAgB,GAC7B,eAAe,cAEd,KAAa,YAAY;AAAA,QACtB,MAAM;AAAA,QACN,SAAS;AAAA,MAAA,CACZ;AAAA,IACJ,CAAA,GAEM,SAnBH,QAAQ,KAAK,6BAA6B,GAEnC;AAAA,MACH,MAAM;AAAA,MACN,SAAS;AAAA,IAAA;AAAA,IAiBrB,UAAU,SACV;AACI,YAAM,YAAY,QAAQ,WACpB,QAAQ,cAER,OAAO,WACP,YAAY,IAAI,MAAM,UAAU,IAAI,GACpC,aAAa,UAAU,aAAa,GAGpC,cAFW,UAAU,YAAY,IAGjC,QAAQ,aACR,QAAQ,WACR,sBAAsB,IACtB,aAAa,IAAI,MAAM,UAAU;AAEvC,UAAI,eAAe;AAEf,UAAA,CAAC,UAAU,iBAAiB;AAE5B,eAAA,UAAU,MAAM,GAChB,UAAU,OAAA,GAEH;AAAA,UACH,MAAM;AAAA,UACN,WAAW,QAAQ;AAAA,UACnB,SAAS;AAAA,UACT,YAAY;AAAA,QAAA;AAIpB,eAAS,IAAI,GAAG,IAAI,YAAY,KAChC;AACI,cAAM,SAAS,UAAU,aAAa,CAAC,GACjC,gBAAkC;AAAA,UACpC,SAAS;AAAA,UACT,YAAY,IAAI,MAKb;AAAA,UACH,OAAO;AAAA,UACP,QAAQ;AAAA,QAAA;AAGZ,iBAAS,IAAI,GAAG,IAAI,QAAQ,KAC5B;AACI,gBAAM,SAAU,eAA6B,sBAAd,aAEzB,QAAQ,UAAU,cAAc,GAAG,CAAC,GACpC,SAAS,UAAU,eAAe,GAAG,CAAC,GACtC,WAAW,UAAU,8BAA8B,GAAG,GAAG,MAAM,GAE/D,eAAgB,QAAQ,IAAK,IAC7B,gBAAiB,SAAS,IAAK;AAGjC,gBAAM,MAEN,cAAc,QAAQ,cACtB,cAAc,SAAS;AAGrB,gBAAA,cAAc,IAAI,WAAW,QAAQ;AAEvC,cAAA,CAAC,UAAU,eAAe,aAAa,GAAG,GAAG,QAAQ,IAAO,EAAK,GACrE;AACQ,gBAAA;AAGA,qBAAA,QAAQ,MAAM,mCAAmC,CAAC,WAAW,CAAC,GAAG,GAE1D,EAAE,MAAM,aAAa,WAAW,QAAQ,WAAW,SAAS;AAI/D,oBAAA,KAAK,mCAAmC,CAAC,WAAW,CAAC,+CAA+C,GAC5G,IAAI,IACJ,eAAe;AAEf;AAAA,UACJ;AAEA,wBAAc,WAAW,KAAK;AAAA,YAC1B,SAAS;AAAA,YACT,YAAY;AAAA,YACZ,aAAa;AAAA,YACb,aAAa;AAAA,UAAA,CAChB;AAAA,QACL;AAEA,mBAAW,CAAC,IAAI;AAAA,MACpB;AAEA,aAAA,UAAU,MAAM,GAChB,UAAU,OAAA,GAEH;AAAA,QACH,MAAM;AAAA,QACN,WAAW,QAAQ;AAAA,QACnB,SAAS;AAAA,QACT,aAAc,eAA6B,sBAAd;AAAA,QAC7B;AAAA,MAAA;AAAA,IAER;AAAA,EAAA;AAGC,OAAA,YAAY,CAAC,MAClB;AACU,UAAA,MAAM,EAAE,MACR,WAAW,gBAAgB,IAAI,IAAI,EAAE,GAAU;AAEjD,gBAEC,KAAa,YAAY,QAAQ;AAAA,EAAA;AAG9C;;"}