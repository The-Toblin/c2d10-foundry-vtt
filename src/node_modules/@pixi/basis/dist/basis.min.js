/*!
 * @pixi/basis - v7.4.3
 * Compiled Thu, 06 Mar 2025 14:58:55 UTC
 *
 * @pixi/basis is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */this.PIXI=this.PIXI||{};var _pixi_basis=function(S,_,T,p){"use strict";var h=(e=>(e[e.cTFETC1=0]="cTFETC1",e[e.cTFETC2=1]="cTFETC2",e[e.cTFBC1=2]="cTFBC1",e[e.cTFBC3=3]="cTFBC3",e[e.cTFBC4=4]="cTFBC4",e[e.cTFBC5=5]="cTFBC5",e[e.cTFBC7=6]="cTFBC7",e[e.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",e[e.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",e[e.cTFASTC_4x4=10]="cTFASTC_4x4",e[e.cTFATC_RGB=11]="cTFATC_RGB",e[e.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",e[e.cTFRGBA32=13]="cTFRGBA32",e[e.cTFRGB565=14]="cTFRGB565",e[e.cTFBGR565=15]="cTFBGR565",e[e.cTFRGBA4444=16]="cTFRGBA4444",e))(h||{});const E={0:_.INTERNAL_FORMATS.COMPRESSED_RGB_ETC1_WEBGL,2:_.INTERNAL_FORMATS.COMPRESSED_RGB_S3TC_DXT1_EXT,3:_.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,8:_.INTERNAL_FORMATS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG,9:_.INTERNAL_FORMATS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,11:_.INTERNAL_FORMATS.COMPRESSED_RGB_ATC_WEBGL,10:_.INTERNAL_FORMATS.COMPRESSED_RGBA_ASTC_4x4_KHR,6:_.INTERNAL_FORMATS.COMPRESSED_RGBA_BPTC_UNORM_EXT},N={13:T.TYPES.UNSIGNED_BYTE,14:T.TYPES.UNSIGNED_SHORT_5_6_5,16:T.TYPES.UNSIGNED_SHORT_4_4_4_4},D=Object.keys(E).map(e=>Number(e)).reduce((e,r)=>(e[E[r]]=r,e),{}),L={3:!0,9:!0,10:!0,6:!0};function j(){let e;const r={init:t=>self.BASIS?(self.BASIS({wasmBinary:t.wasmSource}).then(a=>{a.initializeBasis(),e=a,self.postMessage({type:"init",success:!0})}),null):(console.warn("jsSource was not prepended?"),{type:"init",success:!1}),transcode(t){const a=t.basisData,s=e,o=a,n=new s.BasisFile(o),l=n.getNumImages(),f=n.getHasAlpha()?t.rgbaFormat:t.rgbFormat,A=14,u=new Array(l);let i=!1;if(!n.startTranscoding())return n.close(),n.delete(),{type:"transcode",requestID:t.requestID,success:!1,imageArray:null};for(let d=0;d<l;d++){const b=n.getNumLevels(d),F={imageID:d,levelArray:new Array,width:null,height:null};for(let B=0;B<b;B++){const G=i?A:f,m=n.getImageWidth(d,B),I=n.getImageHeight(d,B),g=n.getImageTranscodedSizeInBytes(d,B,G),v=m+3&-4,C=I+3&-4;B===0&&(F.width=v,F.height=C);const M=new Uint8Array(g);if(!n.transcodeImage(M,d,B,G,!1,!1)){if(i)return console.error(`Basis failed to transcode image ${d}, level ${B}!`),{type:"transcode",requestID:t.requestID,success:!1};console.warn(`Basis failed to transcode image ${d}, level ${B}! Retrying to an uncompressed texture format!`),d=-1,i=!0;break}F.levelArray.push({levelID:B,levelWidth:m,levelHeight:I,levelBuffer:M})}u[d]=F}return n.close(),n.delete(),{type:"transcode",requestID:t.requestID,success:!0,basisFormat:i?A:f,imageArray:u}}};self.onmessage=t=>{const a=t.data,s=r[a.type](a);s&&self.postMessage(s)}}const w=class R{constructor(){this.requests={},this.onMessage=r=>{const t=r.data;if(t.type==="init"){if(!t.success)throw new Error("BasisResource.TranscoderWorker failed to initialize.");this.isInit=!0,this.onInit()}else if(t.type==="transcode"){--this.load;const a=t.requestID;t.success?this.requests[a].resolve(t):this.requests[a].reject(),delete this.requests[a]}},this.isInit=!1,this.load=0,this.initPromise=new Promise(r=>{this.onInit=r}),R.wasmSource||console.warn("resources.BasisResource.TranscoderWorker has not been given the transcoder WASM binary!"),this.worker=new Worker(R.workerURL),this.worker.onmessage=this.onMessage,this.worker.postMessage({type:"init",jsSource:R.jsSource,wasmSource:R.wasmSource})}static get workerURL(){if(!R._workerURL){let r=j.toString();const t=r.indexOf("{"),a=r.lastIndexOf("}");r=r.slice(t+1,a),R.jsSource&&(r=`${R.jsSource}
${r}`),R._workerURL=URL.createObjectURL(new Blob([r]))}return R._workerURL}initAsync(){return this.initPromise}async transcodeAsync(r,t,a){++this.load;const s=R._tempID++,o=new Promise((n,l)=>{this.requests[s]={resolve:n,reject:l}});return this.worker.postMessage({requestID:s,basisData:r,rgbaFormat:t,rgbFormat:a,type:"transcode"}),o}static loadTranscoder(r,t){const a=fetch(r).then(o=>o.text()).then(o=>{R.jsSource=o}),s=fetch(t).then(o=>o.arrayBuffer()).then(o=>{R.wasmSource=o});return Promise.all([a,s]).then(o=>(this._onTranscoderInitializedResolve(),o))}static setTranscoder(r,t){R.jsSource=r,R.wasmSource=t}};w.onTranscoderInitialized=new Promise(e=>{w._onTranscoderInitializedResolve=e}),w._tempID=0;let y=w;const O=class c{static async transcode(r){let t;return typeof Worker!="undefined"&&c.TranscoderWorker.wasmSource?t=await c.transcodeAsync(r):t=c.transcodeSync(r),t}static async transcodeAsync(r){!c.defaultRGBAFormat&&!c.defaultRGBFormat&&c.autoDetectFormats();const t=c.workerPool;let a=268435456,s=null;for(let u=0,i=t.length;u<i;u++)t[u].load<a&&(s=t[u],a=s.load);s||(s=new y,t.push(s)),await s.initAsync();const o=await s.transcodeAsync(new Uint8Array(r),c.defaultRGBAFormat.basisFormat,c.defaultRGBFormat.basisFormat),n=o.basisFormat,l=o.imageArray,f=n>12;let A;if(f)A=l.map(u=>new T.BufferResource(new Uint16Array(u.levelArray[0].levelBuffer.buffer),{width:u.width,height:u.height}));else{const u=E[o.basisFormat];A=new Array(l.length);for(let i=0,d=l.length;i<d;i++)A[i]=new _.CompressedTextureResource(null,{format:u,width:l[i].width,height:l[i].height,levelBuffers:l[i].levelArray,levels:l[i].levelArray.length})}return A.basisFormat=n,A}static transcodeSync(r){!c.defaultRGBAFormat&&!c.defaultRGBFormat&&c.autoDetectFormats();const t=c.basisBinding,a=new Uint8Array(r),s=new t.BasisFile(a),o=s.getNumImages(),n=s.getHasAlpha()?c.defaultRGBAFormat.basisFormat:c.defaultRGBFormat.basisFormat,l=h.cTFRGB565,f=new Array(o);let A=c.fallbackMode;if(!s.startTranscoding())return s.close(),s.delete(),null;for(let i=0;i<o;i++){const d=A?1:s.getNumLevels(i),b=s.getImageWidth(i,0),F=s.getImageHeight(i,0),B=b+3&-4,G=F+3&-4,m=new Array(d);for(let g=0;g<d;g++){const v=s.getImageWidth(i,g),C=s.getImageHeight(i,g),M=s.getImageTranscodedSizeInBytes(i,0,A?l:n);if(m[g]={levelID:g,levelBuffer:new Uint8Array(M),levelWidth:v,levelHeight:C},!s.transcodeImage(m[g].levelBuffer,i,0,A?l:n,!1,!1)){if(A)break;i=-1,A=!0;continue}}let I;A?I=new T.BufferResource(new Uint16Array(m[0].levelBuffer.buffer),{width:b,height:F}):I=new _.CompressedTextureResource(null,{format:E[n],width:B,height:G,levelBuffers:m,levels:d}),f[i]=I}s.close(),s.delete();const u=f;return u.basisFormat=A?l:n,u}static autoDetectFormats(r){if(!r){const a=T.settings.ADAPTER.createCanvas().getContext("webgl");if(!a){console.error("WebGL not available for BASIS transcoding. Silently failing.");return}r={bptc:a.getExtension("EXT_texture_compression_bptc"),astc:a.getExtension("WEBGL_compressed_texture_astc"),etc:a.getExtension("WEBGL_compressed_texture_etc"),s3tc:a.getExtension("WEBGL_compressed_texture_s3tc"),s3tc_sRGB:a.getExtension("WEBGL_compressed_texture_s3tc_srgb"),pvrtc:a.getExtension("WEBGL_compressed_texture_pvrtc")||a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),etc1:a.getExtension("WEBGL_compressed_texture_etc1"),atc:a.getExtension("WEBGL_compressed_texture_atc")}}const t={};for(const a in r){const s=r[a];s&&Object.assign(t,Object.getPrototypeOf(s))}for(let a=0;a<2;a++){const s=!!a;let o,n;for(const l in t)if(o=t[l],n=D[o],n!==void 0&&(s&&L[n]||!s&&!L[n]))break;o?c[s?"defaultRGBAFormat":"defaultRGBFormat"]={textureFormat:o,basisFormat:n}:(c[s?"defaultRGBAFormat":"defaultRGBFormat"]={textureFormat:T.TYPES.UNSIGNED_SHORT_5_6_5,basisFormat:h.cTFRGB565},c.fallbackMode=!0)}}static bindTranscoder(r){c.basisBinding=r}static loadTranscoder(r,t){return c.TranscoderWorker.loadTranscoder(r,t)}static setTranscoder(r,t){c.TranscoderWorker.setTranscoder(r,t)}static get TRANSCODER_WORKER_POOL_LIMIT(){return this.workerPool.length||1}static set TRANSCODER_WORKER_POOL_LIMIT(r){for(let t=this.workerPool.length;t<r;t++)this.workerPool[t]=new y,this.workerPool[t].initAsync()}};O.fallbackMode=!1,O.workerPool=[],O.TranscoderWorker=y;let P=O;const k={extension:{type:T.ExtensionType.DetectionParser,priority:3},test:async()=>!!(P.basisBinding&&P.TranscoderWorker.wasmSource),add:async e=>[...e,"basis"],remove:async e=>e.filter(r=>r!=="basis")};T.extensions.add(k);var H=Object.defineProperty,W=Object.getOwnPropertySymbols,q=Object.prototype.hasOwnProperty,X=Object.prototype.propertyIsEnumerable,x=(e,r,t)=>r in e?H(e,r,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[r]=t,z=(e,r)=>{for(var t in r||(r={}))q.call(r,t)&&x(e,t,r[t]);if(W)for(var t of W(r))X.call(r,t)&&x(e,t,r[t]);return e};const U={extension:{type:T.ExtensionType.LoadParser,priority:p.LoaderParserPriority.High},name:"loadBasis",test(e){return p.checkExtension(e,".basis")},async load(e,r,t){await y.onTranscoderInitialized;const a=await(await T.settings.ADAPTER.fetch(e)).arrayBuffer(),s=await P.transcode(a),o=N[s.basisFormat],n=s.basisFormat!==h.cTFRGBA32?T.FORMATS.RGB:T.FORMATS.RGBA,l=s.map(f=>{const A=new T.BaseTexture(f,z({mipmap:f instanceof _.CompressedTextureResource&&f.levels>1?T.MIPMAP_MODES.ON_MANUAL:T.MIPMAP_MODES.OFF,alphaMode:T.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,type:o,format:n},r.data));return p.createTexture(A,t,e)});return l.length===1?l[0]:l},unload(e){Array.isArray(e)?e.forEach(r=>r.destroy(!0)):e.destroy(!0)}};return T.extensions.add(U),S.BASIS_FORMATS=h,S.BASIS_FORMATS_ALPHA=L,S.BASIS_FORMAT_TO_INTERNAL_FORMAT=E,S.BASIS_FORMAT_TO_TYPE=N,S.BasisParser=P,S.INTERNAL_FORMAT_TO_BASIS_FORMAT=D,S.TranscoderWorker=y,S.detectBasis=k,S.loadBasis=U,S}({},PIXI,PIXI,PIXI);Object.assign(this.PIXI,_pixi_basis);
//# sourceMappingURL=basis.min.js.map
