import { BLEND_MODES, Color, Matrix, Point, Polygon, Renderer, Shader, Texture } from '@pixi/core';
import { Container } from '@pixi/display';
import { LINE_CAP, LINE_JOIN } from '@pixi/graphics';
import { IGraphicsBatchSettings } from './core/BatchDrawCall';
import { FillStyle } from './core/FillStyle';
import { LINE_SCALE_MODE, LineStyle } from './core/LineStyle';
import { SmoothGraphicsGeometry } from './SmoothGraphicsGeometry';
import type { ColorSource, IPointData, IShape } from '@pixi/core';
import type { IDestroyOptions } from '@pixi/display';
export interface IFillStyleOptions {
    color?: ColorSource;
    alpha?: number;
    texture?: Texture;
    matrix?: Matrix;
    smooth?: boolean;
    shader?: Shader;
}
export interface ILineStyleOptions extends IFillStyleOptions {
    width?: number;
    alignment?: number;
    scaleMode?: LINE_SCALE_MODE;
    cap?: LINE_CAP;
    join?: LINE_JOIN;
    miterLimit?: number;
}
/**
 * @memberof PIXI.smooth
 */
export declare class SmoothGraphics extends Container {
    static readonly curves: {
        adaptive: boolean;
        maxLength: number;
        minSegments: number;
        maxSegments: number;
        epsilon: number;
        _segmentsCount(length: number, defaultSegments?: number): number;
    };
    static _TEMP_POINT: Point;
    shader: Shader;
    shaderSettings: IGraphicsBatchSettings;
    pluginName: string;
    currentPath: Polygon;
    protected batches: Array<any>;
    protected batchTint: number;
    protected batchDirty: number;
    protected vertexData: Float32Array;
    protected _fillStyle: FillStyle;
    protected _lineStyle: LineStyle;
    protected _matrix: Matrix;
    protected _holeMode: boolean;
    protected _transformID: number;
    protected _tintColor: Color;
    private state;
    private _geometry;
    get geometry(): SmoothGraphicsGeometry;
    constructor(geometry?: SmoothGraphicsGeometry);
    clone(): SmoothGraphics;
    set blendMode(value: BLEND_MODES);
    get blendMode(): BLEND_MODES;
    get tint(): ColorSource;
    set tint(value: ColorSource);
    get fill(): FillStyle;
    get line(): LineStyle;
    lineStyle(width: number, color?: ColorSource, alpha?: number, alignment?: number, scaleMode?: LINE_SCALE_MODE): this;
    lineStyle(options?: ILineStyleOptions): this;
    lineTextureStyle(options: ILineStyleOptions): this;
    protected startPoly(): void;
    finishPoly(): void;
    moveTo(x: number, y: number): this;
    lineTo(x: number, y: number): this;
    protected _initCurve(x?: number, y?: number): void;
    quadraticCurveTo(cpX: number, cpY: number, toX: number, toY: number): this;
    bezierCurveTo(cpX: number, cpY: number, cpX2: number, cpY2: number, toX: number, toY: number): this;
    arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this;
    arc(cx: number, cy: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean): this;
    beginFill(color?: ColorSource, alpha?: number, smooth?: boolean): this;
    private normalizeColor;
    beginTextureFill(options?: IFillStyleOptions): this;
    endFill(): this;
    drawRect(x: number, y: number, width: number, height: number): this;
    drawRoundedRect(x: number, y: number, width: number, height: number, radius: number): this;
    drawCircle(x: number, y: number, radius: number): this;
    drawEllipse(x: number, y: number, width: number, height: number): this;
    drawPolygon(...path: Array<number> | Array<IPointData>): this;
    drawPolygon(path: Array<number> | Array<IPointData> | Polygon): this;
    drawShape(shape: IShape): this;
    clear(): this;
    isFastRect(): boolean;
    protected _renderCanvas(renderer: any): void;
    protected _render(renderer: Renderer): void;
    protected _populateBatches(): void;
    protected _renderBatched(renderer: Renderer): void;
    protected _renderDirect(renderer: Renderer): void;
    protected _resolveDirectShader(_renderer: Renderer): Shader;
    protected _calculateBounds(): void;
    containsPoint(point: IPointData): boolean;
    protected calculateTints(): void;
    protected calculateVertices(): void;
    closePath(): this;
    setMatrix(matrix: Matrix): this;
    beginHole(): this;
    endHole(): this;
    destroy(options?: IDestroyOptions | boolean): void;
}
