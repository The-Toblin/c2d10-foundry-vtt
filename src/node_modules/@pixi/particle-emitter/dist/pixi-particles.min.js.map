{"version":3,"sources":["../src/PropertyNode.ts","../src/ParticleUtils.ts","../src/behaviors/Behaviors.ts","../src/Particle.ts","../src/Emitter.ts","../src/behaviors/shapes/Rectangle.ts","../src/behaviors/shapes/Torus.ts","../src/behaviors/shapes/PolygonalChain.ts","../src/behaviors/AccelerationMovement.ts","../src/PropertyList.ts","../src/behaviors/Alpha.ts","../src/behaviors/AnimatedTexture.ts","../src/behaviors/BlendMode.ts","../src/behaviors/BurstSpawn.ts","../src/behaviors/Color.ts","../src/behaviors/OrderedTexture.ts","../src/behaviors/PathMovement.ts","../src/behaviors/PointSpawn.ts","../src/behaviors/RandomTexture.ts","../src/behaviors/Rotation.ts","../src/behaviors/Scale.ts","../src/behaviors/ShapeSpawn.ts","../src/behaviors/SingleTexture.ts","../src/behaviors/SpeedMovement.ts","../src/index.ts","../src/LinkedListContainer.ts","../src/EmitterConfig.ts"],"names":["PropertyNode","[object Object]","value","time","ease","this","next","isStepped","generateEase","data","array","list","node","first","hexToRGB","length","i","start","end","GetTextureFromString","Texture","from","verbose","DEG_TO_RADS","Math","PI","rotatePoint","angle","p","s","sin","c","cos","xnew","x","y","ynew","combineRGBComponents","r","g","b","point","sqrt","normalize","oneOverLen","scaleBy","color","output","alpha","charAt","substr","indexOf","parseInt","a","segments","qty","oneOverQty","t","cp","e","getBlendMode","name","toUpperCase","replace","BLEND_MODES","NORMAL","BehaviorOrder","numSteps","currentNode","current","nextIndex","lerp","curVal","nextVal","Particle","Sprite","emitter","super","prevChild","nextChild","config","anchor","maxLife","age","agePercent","oneOverLife","prev","init","kill","rotation","position","scale","tint","visible","recycle","parent","removeChild","destroy","ticker","Ticker","shared","PositionParticle","Symbol","Emitter","particleParent","initBehaviors","updateBehaviors","recycleBehaviors","minLifetime","maxLifetime","customEase","_frequency","spawnChance","maxParticles","emitterLifetime","spawnPos","Point","particlesPerWave","ownerPos","_prevEmitterPos","_prevPosIsValid","_posChanged","_parent","addAtBack","particleCount","_emit","_spawnTimer","_emitterLife","_activeParticlesFirst","_activeParticlesLast","_poolFirst","_origConfig","_autoUpdate","_destroyWhenComplete","_completeCallback","update","rotate","updateSpawnPos","updateOwnerPos","constructor","knownBehaviors","type","frequency","cleanup","lifetime","min","max","set","pos","copyFrom","emit","undefined","autoUpdate","behaviors","map","console","error","filter","push","sort","order","Spawn","slice","updateParticle","recycleParticle","find","count","particle","fromCleanup","newRot","diff","remove","add","callback","delta","settings","TARGET_FPMS","prevX","prevY","curX","curY","emitPosX","emitPosY","waveFirst","waveLast","len","random","addChildAt","addChild","behavior","initParticles","cb","Rectangle","w","h","editorConfig","Torus","radius","innerRadius","affectRotation","PolygonalChain","countingLengths","totalLength","Array","isArray","chain","prevPoint","j","second","p1","p2","l","segLength","out","rand","chosenSeg","AccelerationBehavior","Late","minStart","maxStart","accel","maxSpeed","_a","speed","velocity","deltaSec","vel","oldVX","oldVY","currentSpeed","atan2","intValueSimple","intColorSimple","intValueComplex","intColorComplex","intValueStepped","intColorStepped","PropertyList","isColor","interpolate","AlphaBehavior","Normal","reset","createList","StaticAlphaBehavior","getTextures","textures","outTextures","tex","dupe","texture","RandomAnimatedTextureBehavior","anims","anim","framerate","parsedAnim","duration","loop","index","floor","animElapsed","animDuration","animFramerate","frame","EMPTY","SingleAnimatedTextureBehavior","BlendModeBehavior","blendMode","BurstSpawn","spacing","distance","ColorBehavior","StaticColorBehavior","OrderedTextureBehavior","helperPoint","MATH_FUNCS","WHITELISTER","RegExp","concat","join","PathBehavior","path","pathString","matches","match","Function","parsePath","minMult","initRotation","initPosition","movement","mult","speedMult","PointSpawn","_first","RandomTextureBehavior","RotationBehavior","minSpeed","rotSpeed","oldSpeed","StaticRotationBehavior","NoRotationBehavior","ScaleBehavior","scaleMult","StaticScaleBehavior","ShapeSpawn","ShapeClass","shapes","Error","shape","typeOverride","getRandPos","registerShape","SingleTextureBehavior","SpeedBehavior","StaticSpeedBehavior","registerBehavior","behaviors.AccelerationBehavior","behaviors.AlphaBehavior","behaviors.StaticAlphaBehavior","behaviors.RandomAnimatedTextureBehavior","behaviors.SingleAnimatedTextureBehavior","behaviors.BlendModeBehavior","behaviors.BurstSpawn","behaviors.ColorBehavior","behaviors.StaticColorBehavior","behaviors.OrderedTextureBehavior","behaviors.PathBehavior","behaviors.PointSpawn","behaviors.RandomTextureBehavior","behaviors.RotationBehavior","behaviors.StaticRotationBehavior","behaviors.NoRotationBehavior","behaviors.ScaleBehavior","behaviors.StaticScaleBehavior","behaviors.ShapeSpawn","behaviors.SingleTextureBehavior","behaviors.SpeedBehavior","behaviors.StaticSpeedBehavior","Container","_firstChild","_lastChild","_childCount","firstChild","lastChild","childCount","children","child","sortDirty","transform","_parentID","_boundsID","onChildrenChange","target","relative","child2","test","getChildAt","beginIndex","endIndex","begin","range","removed","RangeError","updateTransform","worldAlpha","_bounds","clear","_calculateBounds","renderable","calculateBounds","_mask","maskObject","addBoundsMask","filterArea","addBoundsArea","addBounds","updateID","rect","skipChildrenUpdate","result","DisplayObject","prototype","getLocalBounds","call","renderer","filters","renderAdvanced","_render","render","batch","flush","mask","_enabledFilters","enabled","pop","maskManager","pushMask","_renderCanvas","renderCanvas","popMask","art","acceleration","minimumSpeedMultiplier","_b","noRotation","_c","extraData","_d","_e","_f","_g","_h","_j","minimumScaleMultiplier","_k","_l","rotationAcceleration","_m","rotationSpeed","_o","_p","_q","startRotation","_r","_s","_t","_u","_v","orderedArt","spawnType","angleStart","particleSpacing","spawnCircle","minR","spawnRect","spawnPolygon"],"mappings":"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","file":"dist/pixi-particles.min.js.map","sourcesContent":["import { generateEase, hexToRGB, EaseSegment, SimpleEase, Color } from './ParticleUtils';\nimport { BasicTweenable } from './EmitterConfig';\n\nexport interface ValueStep<T> {\n    value: T;\n    time: number;\n}\n\nexport interface ValueList<T> {\n    list: ValueStep<T>[];\n    isStepped?: boolean;\n    ease?: SimpleEase|EaseSegment[];\n}\n/**\n * A single node in a PropertyList.\n */\nexport class PropertyNode<V>\n{\n    /**\n     * Value for the node.\n     */\n    public value: V;\n    /**\n     * Time value for the node. Between 0-1.\n     */\n    public time: number;\n    /**\n     * The next node in line.\n     */\n    public next: PropertyNode<V>;\n    /**\n     * If this is the first node in the list, controls if the entire list is stepped or not.\n     */\n    public isStepped: boolean;\n    public ease: SimpleEase;\n\n    /**\n     * @param value The value for this node\n     * @param time The time for this node, between 0-1\n     * @param [ease] Custom ease for this list. Only relevant for the first node.\n     */\n    constructor(value: V, time: number, ease?: SimpleEase|EaseSegment[])\n    {\n        this.value = value;\n        this.time = time;\n        this.next = null;\n        this.isStepped = false;\n        if (ease)\n        {\n            this.ease = typeof ease === 'function' ? ease : generateEase(ease);\n        }\n        else\n        {\n            this.ease = null;\n        }\n    }\n\n    /**\n     * Creates a list of property values from a data object {list, isStepped} with a list of objects in\n     * the form {value, time}. Alternatively, the data object can be in the deprecated form of\n     * {start, end}.\n     * @param data The data for the list.\n     * @param data.list The array of value and time objects.\n     * @param data.isStepped If the list is stepped rather than interpolated.\n     * @param data.ease Custom ease for this list.\n     * @return The first node in the list\n     */\n    // eslint-disable-next-line max-len\n    public static createList<T extends(string|number)>(data: ValueList<T>|BasicTweenable<T>): PropertyNode<T extends string ? Color : T>\n    {\n        if ('list' in data)\n        {\n            const array = data.list;\n            let node;\n            const { value, time } = array[0];\n\n            // eslint-disable-next-line max-len\n            const first = node = new PropertyNode(typeof value === 'string' ? hexToRGB(value) : value, time, data.ease);\n\n            // only set up subsequent nodes if there are a bunch or the 2nd one is different from the first\n            if (array.length > 2 || (array.length === 2 && array[1].value !== value))\n            {\n                for (let i = 1; i < array.length; ++i)\n                {\n                    const { value, time } = array[i];\n\n                    node.next = new PropertyNode(typeof value === 'string' ? hexToRGB(value) : value, time);\n                    node = node.next;\n                }\n            }\n            first.isStepped = !!data.isStepped;\n\n            return first as PropertyNode<T extends string ? Color : T>;\n        }\n\n        // Handle deprecated version here\n        const start = new PropertyNode(typeof data.start === 'string' ? hexToRGB(data.start) : data.start, 0);\n        // only set up a next value if it is different from the starting value\n\n        if (data.end !== data.start)\n        {\n            start.next = new PropertyNode(typeof data.end === 'string' ? hexToRGB(data.end) : data.end, 1);\n        }\n\n        return start as PropertyNode<T extends string ? Color : T>;\n    }\n}\n","import { Texture } from '@pixi/core';\nimport { IPointData } from '@pixi/math';\nimport { BLEND_MODES } from '@pixi/constants';\nimport { PropertyNode, ValueStep } from './PropertyNode';\n\n/**\n * The method used by behaviors to fetch textures. Defaults to Texture.from.\n */\n// get Texture.from(), only supports V5 and V6 with individual packages\n// eslint-disable-next-line prefer-const\nexport let GetTextureFromString:(d:string) => Texture = Texture.from;\n\nexport interface Color {\n    r: number;\n    g: number;\n    b: number;\n    a?: number;\n}\n\nexport interface EaseSegment {\n    cp: number;\n    s: number;\n    e: number;\n}\n\nexport type SimpleEase = (time: number) => number;\n\n/**\n * If errors and warnings should be logged within the library.\n */\nexport const verbose = false;\n\nexport const DEG_TO_RADS = Math.PI / 180;\n\n/**\n * Rotates a point by a given angle.\n * @param angle The angle to rotate by in radians\n * @param p The point to rotate around 0,0.\n */\nexport function rotatePoint(angle: number, p: IPointData): void\n{\n    if (!angle) return;\n\n    const s = Math.sin(angle);\n    const c = Math.cos(angle);\n    const xnew = (p.x * c) - (p.y * s);\n    const ynew = (p.x * s) + (p.y * c);\n\n    p.x = xnew;\n    p.y = ynew;\n}\n\n/**\n * Combines separate color components (0-255) into a single uint color.\n * @param r The red value of the color\n * @param g The green value of the color\n * @param b The blue value of the color\n * @return The color in the form of 0xRRGGBB\n */\nexport function combineRGBComponents(r: number, g: number, b: number/* , a*/): number\n{\n    return /* a << 24 |*/ (r << 16) | (g << 8) | b;\n}\n\n/**\n * Returns the length (or magnitude) of this point.\n * @param point The point to measure length\n * @return The length of this point.\n */\nexport function length(point: IPointData): number\n{\n    return Math.sqrt((point.x * point.x) + (point.y * point.y));\n}\n\n/**\n * Reduces the point to a length of 1.\n * @param point The point to normalize\n */\nexport function normalize(point: IPointData): void\n{\n    const oneOverLen = 1 / length(point);\n\n    point.x *= oneOverLen;\n    point.y *= oneOverLen;\n}\n\n/**\n * Multiplies the x and y values of this point by a value.\n * @param point The point to scaleBy\n * @param value The value to scale by.\n */\nexport function scaleBy(point: IPointData, value: number): void\n{\n    point.x *= value;\n    point.y *= value;\n}\n\n/**\n * Converts a hex string from \"#AARRGGBB\", \"#RRGGBB\", \"0xAARRGGBB\", \"0xRRGGBB\",\n * \"AARRGGBB\", or \"RRGGBB\" to an object of ints of 0-255, as\n * {r, g, b, (a)}.\n * @param color The input color string.\n * @param output An object to put the output in. If omitted, a new object is created.\n * @return The object with r, g, and b properties, possibly with an a property.\n */\nexport function hexToRGB(color: string, output?: Color): Color\n{\n    if (!output)\n    {\n        output = {} as Color;\n    }\n    if (color.charAt(0) === '#')\n    {\n        color = color.substr(1);\n    }\n    else if (color.indexOf('0x') === 0)\n    {\n        color = color.substr(2);\n    }\n    let alpha;\n\n    if (color.length === 8)\n    {\n        alpha = color.substr(0, 2);\n        color = color.substr(2);\n    }\n    output.r = parseInt(color.substr(0, 2), 16);// Red\n    output.g = parseInt(color.substr(2, 2), 16);// Green\n    output.b = parseInt(color.substr(4, 2), 16);// Blue\n    if (alpha)\n    {\n        output.a = parseInt(alpha, 16);\n    }\n\n    return output;\n}\n\n/**\n * Generates a custom ease function, based on the GreenSock custom ease, as demonstrated\n * by the related tool at http://www.greensock.com/customease/.\n * @param segments An array of segments, as created by\n * http://www.greensock.com/customease/.\n * @return A function that calculates the percentage of change at\n *                    a given point in time (0-1 inclusive).\n */\nexport function generateEase(segments: EaseSegment[]): SimpleEase\n{\n    const qty = segments.length;\n    const oneOverQty = 1 / qty;\n    /*\n        * Calculates the percentage of change at a given point in time (0-1 inclusive).\n        * @param {Number} time The time of the ease, 0-1 inclusive.\n        * @return {Number} The percentage of the change, 0-1 inclusive (unless your\n        *                  ease goes outside those bounds).\n        */\n\n    // eslint-disable-next-line func-names\n    return function (time: number): number\n    {\n        const i = (qty * time) | 0;// do a quick floor operation\n\n        const t = (time - (i * oneOverQty)) * qty;\n        const s = segments[i] || segments[qty - 1];\n\n        return (s.s + (t * ((2 * (1 - t) * (s.cp - s.s)) + (t * (s.e - s.s)))));\n    };\n}\n\n/**\n * Gets a blend mode, ensuring that it is valid.\n * @param name The name of the blend mode to get.\n * @return The blend mode as specified in the PIXI.BLEND_MODES enumeration.\n */\nexport function getBlendMode(name: string): number\n{\n    if (!name) return BLEND_MODES.NORMAL;\n    name = name.toUpperCase().replace(/ /g, '_');\n\n    return (BLEND_MODES as any)[name] || BLEND_MODES.NORMAL;\n}\n\n/**\n * Converts a list of {value, time} objects starting at time 0 and ending at time 1 into an evenly\n * spaced stepped list of PropertyNodes for color values. This is primarily to handle conversion of\n * linear gradients to fewer colors, allowing for some optimization for Canvas2d fallbacks.\n * @param list The list of data to convert.\n * @param [numSteps=10] The number of steps to use.\n * @return The blend mode as specified in the PIXI.blendModes enumeration.\n */\nexport function createSteppedGradient(list: ValueStep<string>[], numSteps = 10): PropertyNode<Color>\n{\n    if (typeof numSteps !== 'number' || numSteps <= 0)\n    {\n        numSteps = 10;\n    }\n    const first = new PropertyNode<Color>(hexToRGB(list[0].value), list[0].time);\n\n    first.isStepped = true;\n    let currentNode = first;\n    let current = list[0];\n    let nextIndex = 1;\n    let next = list[nextIndex];\n\n    for (let i = 1; i < numSteps; ++i)\n    {\n        let lerp = i / numSteps;\n        // ensure we are on the right segment, if multiple\n\n        while (lerp > next.time)\n        {\n            current = next;\n            next = list[++nextIndex];\n        }\n        // convert the lerp value to the segment range\n        lerp = (lerp - current.time) / (next.time - current.time);\n        const curVal = hexToRGB(current.value);\n        const nextVal = hexToRGB(next.value);\n        const output: Color = {\n            r: ((nextVal.r - curVal.r) * lerp) + curVal.r,\n            g: ((nextVal.g - curVal.g) * lerp) + curVal.g,\n            b: ((nextVal.b - curVal.b) * lerp) + curVal.b,\n        };\n\n        currentNode.next = new PropertyNode(output, i / numSteps);\n        currentNode = currentNode.next;\n    }\n\n    // we don't need to have a PropertyNode for time of 1, because in a stepped version at that point\n    // the particle has died of old age\n    return first;\n}\n","import { Particle } from '../Particle';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * All behaviors must match this specification.\n */\nexport interface IEmitterBehavior\n{\n    /**\n     * Order in which the behavior will be handled. Lower numbers are handled earlier, with an order of 0 getting\n     * special treatment before the Emitter's transformation is applied.\n     */\n    order: number;\n    /**\n     * Called to initialize a wave of particles, with a reference to the first particle in the linked list.\n     * @param first The first (maybe only) particle in a newly spawned wave of particles.\n     */\n    initParticles(first: Particle): void;\n    /**\n     * Updates a single particle for a given period of time elapsed. Return `true` to recycle the particle.\n     * @param particle The particle to update.\n     * @param deltaSec The time to advance the particle by in seconds.\n     */\n    updateParticle?(particle: Particle, deltaSec: number): void|boolean;\n    /**\n     * A hook for when a particle is recycled.\n     * @param particle The particle that was just recycled.\n     * @param natural `true` if the reycling was due to natural lifecycle, `false` if it was due to emitter cleanup.\n     */\n    recycleParticle?(particle: Particle, natural: boolean): void;\n}\n\n/**\n * A class for an emitter behavior.\n */\nexport interface IEmitterBehaviorClass\n{\n    /**\n     * The unique type name that the behavior is registered under.\n     */\n    type: string;\n    /**\n     * Configuration data for an editor to display this behavior. Does not need to exist in production code.\n     */\n    editorConfig?: BehaviorEditorConfig;\n    /**\n     * The behavior constructor itself.\n     * @param config The config for the behavior, which should match its defined specifications.\n     */\n    new (config: any): IEmitterBehavior;\n}\n\n/**\n * Standard behavior order values, specifying when/how they are used. Other numeric values can be used,\n * but only the Spawn value will be handled in a special way. All other values will be sorted numerically.\n * Behaviors with the same value will not be given any specific sort order, as they are assumed to not\n * interfere with each other.\n */\nexport enum BehaviorOrder\n{\n    /**\n     * Spawn - initial placement and/or rotation. This happens before rotation/translation due to\n     * emitter rotation/position is applied.\n     */\n    Spawn = 0,\n    /**\n     * Normal priority, for things that don't matter when they are applied.\n     */\n    Normal = 2,\n    /**\n     * Delayed priority, for things that need to read other values in order to act correctly.\n     */\n    Late = 5,\n}\n","import { Emitter } from './Emitter';\nimport { LinkedListChild } from './LinkedListContainer';\nimport { Sprite } from '@pixi/sprite';\n\n/**\n * An individual particle image. You shouldn't have to deal with these.\n */\nexport class Particle extends Sprite implements LinkedListChild\n{\n    /**\n     * The emitter that controls this particle.\n     */\n    public emitter: Emitter;\n    /**\n     * The maximum lifetime of this particle, in seconds.\n     */\n    public maxLife: number;\n    /**\n     * The current age of the particle, in seconds.\n     */\n    public age: number;\n    /**\n     * The current age of the particle as a normalized value between 0 and 1.\n     */\n    public agePercent: number;\n    /**\n     * One divided by the max life of the particle, saved for slightly faster math.\n     */\n    public oneOverLife: number;\n    /**\n     * Reference to the next particle in the list.\n     */\n    public next: Particle;\n\n    /**\n     * Reference to the previous particle in the list.\n     */\n    public prev: Particle;\n\n    public prevChild: LinkedListChild;\n    public nextChild: LinkedListChild;\n\n    /**\n     * Static per-particle configuration for behaviors to use. Is not cleared when recycling.\n     */\n    public config: {[key: string]: any};\n\n    /**\n     * @param emitter The emitter that controls this particle.\n     */\n    constructor(emitter: Emitter)\n    {\n        // start off the sprite with a blank texture, since we are going to replace it\n        // later when the particle is initialized.\n        super();\n        // initialize LinkedListChild props so they are included in underlying JS class definition\n        this.prevChild = this.nextChild = null;\n\n        this.emitter = emitter;\n        this.config = {};\n        // particles should be centered\n        this.anchor.x = this.anchor.y = 0.5;\n        this.maxLife = 0;\n        this.age = 0;\n        this.agePercent = 0;\n        this.oneOverLife = 0;\n        this.next = null;\n        this.prev = null;\n\n        // save often used functions on the instance instead of the prototype for better speed\n        this.init = this.init;\n        this.kill = this.kill;\n    }\n\n    /**\n     * Initializes the particle for use, based on the properties that have to\n     * have been set already on the particle.\n     */\n    public init(maxLife: number): void\n    {\n        this.maxLife = maxLife;\n        // reset the age\n        this.age = this.agePercent = 0;\n        // reset the sprite props\n        this.rotation = 0;\n        this.position.x = this.position.y = 0;\n        this.scale.x = this.scale.y = 1;\n        this.tint = 0xffffff;\n        this.alpha = 1;\n        // save our lerp helper\n        this.oneOverLife = 1 / this.maxLife;\n\n        // ensure visibility\n        this.visible = true;\n    }\n\n    /**\n     * Kills the particle, removing it from the display list\n     * and telling the emitter to recycle it.\n     */\n    public kill(): void\n    {\n        this.emitter.recycle(this);\n    }\n\n    /**\n     * Destroys the particle, removing references and preventing future use.\n     */\n    public destroy(): void\n    {\n        if (this.parent)\n        {\n            this.parent.removeChild(this);\n        }\n        this.emitter = this.next = this.prev = null;\n        super.destroy();\n    }\n}\n","import { generateEase, rotatePoint, SimpleEase } from './ParticleUtils';\nimport { Particle } from './Particle';\nimport { EmitterConfigV3 } from './EmitterConfig';\nimport { Container } from '@pixi/display';\nimport { settings } from '@pixi/settings';\nimport { Point } from '@pixi/math';\nimport { Ticker } from '@pixi/ticker';\nimport { BehaviorOrder, IEmitterBehavior, IEmitterBehaviorClass } from './behaviors/Behaviors';\n// get the shared ticker, only supports V5 and V6 with individual packages\n/**\n * @hidden\n */\nconst ticker = Ticker.shared;\n\n/**\n * Key used in sorted order to determine when to set particle position from the emitter position\n * and rotation.\n */\nconst PositionParticle = Symbol('Position particle per emitter position');\n\n/**\n * A particle emitter.\n */\nexport class Emitter\n{\n    private static knownBehaviors: {[key: string]: IEmitterBehaviorClass} = {};\n\n    public static registerBehavior(constructor: IEmitterBehaviorClass): void\n    {\n        Emitter.knownBehaviors[constructor.type] = constructor;\n    }\n\n    /**\n     * Active initialization behaviors for this emitter.\n     */\n    protected initBehaviors: (IEmitterBehavior | typeof PositionParticle)[];\n    /**\n     * Active update behaviors for this emitter.\n     */\n    protected updateBehaviors: IEmitterBehavior[];\n    /**\n     * Active recycle behaviors for this emitter.\n     */\n    protected recycleBehaviors: IEmitterBehavior[];\n    // properties for individual particles\n    /**\n     * The minimum lifetime for a particle, in seconds.\n     */\n    public minLifetime: number;\n    /**\n     * The maximum lifetime for a particle, in seconds.\n     */\n    public maxLifetime: number;\n    /**\n     * An easing function for nonlinear interpolation of values. Accepts a single\n     * parameter of time as a value from 0-1, inclusive. Expected outputs are values\n     * from 0-1, inclusive.\n     */\n    public customEase: SimpleEase;\n    // properties for spawning particles\n    /**\n     * Time between particle spawns in seconds.\n     */\n    protected _frequency: number;\n    /**\n     * Chance that a particle will be spawned on each opportunity to spawn one.\n     * 0 is 0%, 1 is 100%.\n     */\n    public spawnChance: number;\n    /**\n     * Maximum number of particles to keep alive at a time. If this limit\n     * is reached, no more particles will spawn until some have died.\n     */\n    public maxParticles: number;\n    /**\n     * The amount of time in seconds to emit for before setting emit to false.\n     * A value of -1 is an unlimited amount of time.\n     */\n    public emitterLifetime: number;\n    /**\n     * Position at which to spawn particles, relative to the emitter's owner's origin.\n     * For example, the flames of a rocket travelling right might have a spawnPos\n     * of {x:-50, y:0}.\n     * to spawn at the rear of the rocket.\n     * To change this, use updateSpawnPos().\n     */\n    public spawnPos: Point;\n    /**\n     * Number of particles to spawn time that the frequency allows for particles to spawn.\n     */\n    public particlesPerWave: number;\n    /**\n     * Rotation of the emitter or emitter's owner in degrees. This is added to\n     * the calculated spawn angle.\n     * To change this, use rotate().\n     */\n    protected rotation: number;\n    /**\n     * The world position of the emitter's owner, to add spawnPos to when\n     * spawning particles. To change this, use updateOwnerPos().\n     */\n    protected ownerPos: Point;\n    /**\n     * The origin + spawnPos in the previous update, so that the spawn position\n     * can be interpolated to space out particles better.\n     */\n    protected _prevEmitterPos: Point;\n    /**\n     * If _prevEmitterPos is valid, to prevent interpolation on the first update\n     */\n    protected _prevPosIsValid: boolean;\n    /**\n     * If either ownerPos or spawnPos has changed since the previous update.\n     */\n    protected _posChanged: boolean;\n    /**\n     * The container to add particles to.\n     */\n    protected _parent: Container;\n    /**\n     * If particles should be added at the back of the display list instead of the front.\n     */\n    public addAtBack: boolean;\n    /**\n     * The current number of active particles.\n     */\n    public particleCount: number;\n    /**\n     * If particles should be emitted during update() calls. Setting this to false\n     * stops new particles from being created, but allows existing ones to die out.\n     */\n    protected _emit: boolean;\n    /**\n     * The timer for when to spawn particles in seconds, where numbers less\n     * than 0 mean that particles should be spawned.\n     */\n    protected _spawnTimer: number;\n    /**\n     * The life of the emitter in seconds.\n     */\n    protected _emitterLife: number;\n    /**\n     * The particles that are active and on the display list. This is the first particle in a\n     * linked list.\n     */\n    protected _activeParticlesFirst: Particle;\n    /**\n     * The particles that are active and on the display list. This is the last particle in a\n     * linked list.\n     */\n    protected _activeParticlesLast: Particle;\n    /**\n     * The particles that are not currently being used. This is the first particle in a\n     * linked list.\n     */\n    protected _poolFirst: Particle;\n    /**\n     * The original config object that this emitter was initialized with.\n     */\n    protected _origConfig: any;\n    /**\n     * If the update function is called automatically from the shared ticker.\n     * Setting this to false requires calling the update function manually.\n     */\n    protected _autoUpdate: boolean;\n    /**\n     * If the emitter should destroy itself when all particles have died out. This is set by\n     * playOnceAndDestroy();\n     */\n    protected _destroyWhenComplete: boolean;\n    /**\n     * A callback for when all particles have died out. This is set by\n     * playOnceAndDestroy() or playOnce();\n     */\n    protected _completeCallback: () => void;\n\n    /**\n     * @param particleParent The container to add the particles to.\n     * @param particleImages A texture or array of textures to use\n     *                       for the particles. Strings will be turned\n     *                       into textures via Texture.fromImage().\n     * @param config A configuration object containing settings for the emitter.\n     * @param config.emit If config.emit is explicitly passed as false, the\n     *                    Emitter will start disabled.\n     * @param config.autoUpdate If config.autoUpdate is explicitly passed as\n     *                          true, the Emitter will automatically call\n     *                          update via the PIXI shared ticker.\n     */\n    constructor(particleParent: Container, config: EmitterConfigV3)\n    {\n        this.initBehaviors = [];\n        this.updateBehaviors = [];\n        this.recycleBehaviors = [];\n        // properties for individual particles\n        this.minLifetime = 0;\n        this.maxLifetime = 0;\n        this.customEase = null;\n        // properties for spawning particles\n        this._frequency = 1;\n        this.spawnChance = 1;\n        this.maxParticles = 1000;\n        this.emitterLifetime = -1;\n        this.spawnPos = new Point();\n        this.particlesPerWave = 1;\n        // emitter properties\n        this.rotation = 0;\n        this.ownerPos = new Point();\n        this._prevEmitterPos = new Point();\n        this._prevPosIsValid = false;\n        this._posChanged = false;\n        this._parent = null;\n        this.addAtBack = false;\n        this.particleCount = 0;\n        this._emit = false;\n        this._spawnTimer = 0;\n        this._emitterLife = -1;\n        this._activeParticlesFirst = null;\n        this._activeParticlesLast = null;\n        this._poolFirst = null;\n        this._origConfig = null;\n        this._autoUpdate = false;\n        this._destroyWhenComplete = false;\n        this._completeCallback = null;\n\n        // set the initial parent\n        this.parent = particleParent;\n\n        if (config)\n        {\n            this.init(config);\n        }\n\n        // save often used functions on the instance instead of the prototype for better speed\n        this.recycle = this.recycle;\n        this.update = this.update;\n        this.rotate = this.rotate;\n        this.updateSpawnPos = this.updateSpawnPos;\n        this.updateOwnerPos = this.updateOwnerPos;\n    }\n\n    /**\n     * Time between particle spawns in seconds. If this value is not a number greater than 0,\n     * it will be set to 1 (particle per second) to prevent infinite loops.\n     */\n    public get frequency(): number { return this._frequency; }\n    public set frequency(value: number)\n    {\n        // do some error checking to prevent infinite loops\n        if (typeof value === 'number' && value > 0)\n        {\n            this._frequency = value;\n        }\n        else\n        {\n            this._frequency = 1;\n        }\n    }\n\n    /**\n    * The container to add particles to. Settings this will dump any active particles.\n    */\n    public get parent(): Container { return this._parent; }\n    public set parent(value: Container)\n    {\n        this.cleanup();\n        this._parent = value;\n    }\n\n    /**\n     * Sets up the emitter based on the config settings.\n     * @param config A configuration object containing settings for the emitter.\n     */\n    public init(config: EmitterConfigV3): void\n    {\n        if (!config)\n        {\n            return;\n        }\n        // clean up any existing particles\n        this.cleanup();\n\n        // store the original config and particle images, in case we need to re-initialize\n        // when the particle constructor is changed\n        this._origConfig = config;\n\n        // /////////////////////////\n        // Particle Properties    //\n        // /////////////////////////\n\n        // set up the lifetime\n        this.minLifetime = config.lifetime.min;\n        this.maxLifetime = config.lifetime.max;\n        // use the custom ease if provided\n        if (config.ease)\n        {\n            this.customEase = typeof config.ease === 'function'\n                ? config.ease : generateEase(config.ease);\n        }\n        else\n        {\n            this.customEase = null;\n        }\n        // ////////////////////////\n        // Emitter Properties    //\n        // ////////////////////////\n        // reset spawn type specific settings\n        this.particlesPerWave = 1;\n        if (config.particlesPerWave && config.particlesPerWave > 1)\n        {\n            this.particlesPerWave = config.particlesPerWave;\n        }\n        // set the spawning frequency\n        this.frequency = config.frequency;\n        this.spawnChance = (typeof config.spawnChance === 'number' && config.spawnChance > 0) ? config.spawnChance : 1;\n        // set the emitter lifetime\n        this.emitterLifetime = config.emitterLifetime || -1;\n        // set the max particles\n        this.maxParticles = config.maxParticles > 0 ? config.maxParticles : 1000;\n        // determine if we should add the particle at the back of the list or not\n        this.addAtBack = !!config.addAtBack;\n        // reset the emitter position and rotation variables\n        this.rotation = 0;\n        this.ownerPos.set(0);\n        if (config.pos)\n        {\n            this.spawnPos.copyFrom(config.pos);\n        }\n        else\n        {\n            this.spawnPos.set(0);\n        }\n\n        this._prevEmitterPos.copyFrom(this.spawnPos);\n        // previous emitter position is invalid and should not be used for interpolation\n        this._prevPosIsValid = false;\n        // start emitting\n        this._spawnTimer = 0;\n        this.emit = config.emit === undefined ? true : !!config.emit;\n        this.autoUpdate = !!config.autoUpdate;\n\n        // ////////////////////////\n        // Behaviors             //\n        // ////////////////////////\n        const behaviors: (IEmitterBehavior | typeof PositionParticle)[] = config.behaviors.map((data) =>\n        {\n            const constructor = Emitter.knownBehaviors[data.type];\n\n            if (!constructor)\n            {\n                console.error(`Unknown behavior: ${data.type}`);\n\n                return null;\n            }\n\n            return new constructor(data.config);\n        })\n            .filter((b) => !!b);\n\n        behaviors.push(PositionParticle);\n        behaviors.sort((a, b) =>\n        {\n            if (a === PositionParticle)\n            {\n                return (b as IEmitterBehavior).order === BehaviorOrder.Spawn ? 1 : -1;\n            }\n            else if (b === PositionParticle)\n            {\n                return (a as IEmitterBehavior).order === BehaviorOrder.Spawn ? -1 : 1;\n            }\n\n            return (a as IEmitterBehavior).order - (b as IEmitterBehavior).order;\n        });\n        this.initBehaviors = behaviors.slice();\n        this.updateBehaviors = behaviors.filter((b) => b !== PositionParticle && b.updateParticle) as IEmitterBehavior[];\n        this.recycleBehaviors = behaviors.filter((b) => b !== PositionParticle && b.recycleParticle) as IEmitterBehavior[];\n    }\n\n    /**\n     * Gets the instantiated behavior of the specified type, if any.\n     * @param type The behavior type to find.\n     */\n    public getBehavior(type: string): IEmitterBehavior|null\n    {\n        return this.initBehaviors.find((b) => b instanceof Emitter.knownBehaviors[type]) as IEmitterBehavior || null;\n    }\n\n    /**\n     * Fills the pool with the specified number of particles, so that they don't have to be instantiated later.\n     * @param count The number of particles to create.\n     */\n    public fillPool(count: number): void\n    {\n        for (; count > 0; --count)\n        {\n            const p = new Particle(this);\n\n            p.next = this._poolFirst;\n            this._poolFirst = p;\n        }\n    }\n\n    /**\n     * Recycles an individual particle. For internal use only.\n     * @param particle The particle to recycle.\n     * @param fromCleanup If this is being called to manually clean up all particles.\n     * @internal\n     */\n    public recycle(particle: Particle, fromCleanup = false): void\n    {\n        for (let i = 0; i < this.recycleBehaviors.length; ++i)\n        {\n            this.recycleBehaviors[i].recycleParticle(particle, !fromCleanup);\n        }\n        if (particle.next)\n        {\n            particle.next.prev = particle.prev;\n        }\n        if (particle.prev)\n        {\n            particle.prev.next = particle.next;\n        }\n        if (particle === this._activeParticlesLast)\n        {\n            this._activeParticlesLast = particle.prev;\n        }\n        if (particle === this._activeParticlesFirst)\n        {\n            this._activeParticlesFirst = particle.next;\n        }\n        // add to pool\n        particle.prev = null;\n        particle.next = this._poolFirst;\n        this._poolFirst = particle;\n        // remove child from display, or make it invisible if it is in a ParticleContainer\n        if (particle.parent)\n        {\n            particle.parent.removeChild(particle);\n        }\n        // decrease count\n        --this.particleCount;\n    }\n\n    /**\n     * Sets the rotation of the emitter to a new value. This rotates the spawn position in addition\n     * to particle direction.\n     * @param newRot The new rotation, in degrees.\n     */\n    public rotate(newRot: number): void\n    {\n        if (this.rotation === newRot) return;\n        // caclulate the difference in rotation for rotating spawnPos\n        const diff = newRot - this.rotation;\n\n        this.rotation = newRot;\n        // rotate spawnPos\n        rotatePoint(diff, this.spawnPos);\n        // mark the position as having changed\n        this._posChanged = true;\n    }\n\n    /**\n     * Changes the spawn position of the emitter.\n     * @param x The new x value of the spawn position for the emitter.\n     * @param y The new y value of the spawn position for the emitter.\n     */\n    public updateSpawnPos(x: number, y: number): void\n    {\n        this._posChanged = true;\n        this.spawnPos.x = x;\n        this.spawnPos.y = y;\n    }\n\n    /**\n     * Changes the position of the emitter's owner. You should call this if you are adding\n     * particles to the world container that your emitter's owner is moving around in.\n     * @param x The new x value of the emitter's owner.\n     * @param y The new y value of the emitter's owner.\n     */\n    public updateOwnerPos(x: number, y: number): void\n    {\n        this._posChanged = true;\n        this.ownerPos.x = x;\n        this.ownerPos.y = y;\n    }\n\n    /**\n     * Prevents emitter position interpolation in the next update.\n     * This should be used if you made a major position change of your emitter's owner\n     * that was not normal movement.\n     */\n    public resetPositionTracking(): void\n    {\n        this._prevPosIsValid = false;\n    }\n\n    /**\n     * If particles should be emitted during update() calls. Setting this to false\n     * stops new particles from being created, but allows existing ones to die out.\n     */\n    public get emit(): boolean { return this._emit; }\n    public set emit(value: boolean)\n    {\n        this._emit = !!value;\n        this._emitterLife = this.emitterLifetime;\n    }\n\n    /**\n     * If the update function is called automatically from the shared ticker.\n     * Setting this to false requires calling the update function manually.\n     */\n    public get autoUpdate(): boolean { return this._autoUpdate; }\n    public set autoUpdate(value: boolean)\n    {\n        if (this._autoUpdate && !value)\n        {\n            ticker.remove(this.update, this);\n        }\n        else if (!this._autoUpdate && value)\n        {\n            ticker.add(this.update, this);\n        }\n        this._autoUpdate = !!value;\n    }\n\n    /**\n     * Starts emitting particles, sets autoUpdate to true, and sets up the Emitter to destroy itself\n     * when particle emission is complete.\n     * @param callback Callback for when emission is complete (all particles have died off)\n     */\n    public playOnceAndDestroy(callback?: () => void): void\n    {\n        this.autoUpdate = true;\n        this.emit = true;\n        this._destroyWhenComplete = true;\n        this._completeCallback = callback;\n    }\n\n    /**\n     * Starts emitting particles and optionally calls a callback when particle emission is complete.\n     * @param callback Callback for when emission is complete (all particles have died off)\n     */\n    public playOnce(callback?: () => void): void\n    {\n        this.emit = true;\n        this._completeCallback = callback;\n    }\n\n    /**\n     * Updates all particles spawned by this emitter and emits new ones.\n     * @param delta Time elapsed since the previous frame, in __seconds__.\n     */\n    public update(delta: number): void\n    {\n        if (this._autoUpdate)\n        {\n            delta = delta / settings.TARGET_FPMS / 1000;\n        }\n\n        // if we don't have a parent to add particles to, then don't do anything.\n        // this also works as a isDestroyed check\n        if (!this._parent) return;\n\n        // == update existing particles ==\n\n        // update all particle lifetimes before turning them over to behaviors\n        for (let particle = this._activeParticlesFirst, next; particle; particle = next)\n        {\n            // save next particle in case we recycle this one\n            next = particle.next;\n            // increase age\n            particle.age += delta;\n            // recycle particle if it is too old\n            if (particle.age > particle.maxLife || particle.age < 0)\n            {\n                this.recycle(particle);\n            }\n            else\n            {\n                // determine our interpolation value\n                let lerp = particle.age * particle.oneOverLife;// lifetime / maxLife;\n\n                // global ease affects all interpolation calculations\n                if (this.customEase)\n                {\n                    if (this.customEase.length === 4)\n                    {\n                        // the t, b, c, d parameters that some tween libraries use\n                        // (time, initial value, end value, duration)\n                        lerp = (this.customEase as any)(lerp, 0, 1, 1);\n                    }\n                    else\n                    {\n                        // the simplified version that we like that takes\n                        // one parameter, time from 0-1. TweenJS eases provide this usage.\n                        lerp = this.customEase(lerp);\n                    }\n                }\n\n                // set age percent for all interpolation calculations\n                particle.agePercent = lerp;\n\n                // let each behavior run wild on the active particles\n                for (let i = 0; i < this.updateBehaviors.length; ++i)\n                {\n                    if (this.updateBehaviors[i].updateParticle(particle, delta))\n                    {\n                        this.recycle(particle);\n                        break;\n                    }\n                }\n            }\n        }\n\n        let prevX: number;\n        let prevY: number;\n\n        // if the previous position is valid, store these for later interpolation\n        if (this._prevPosIsValid)\n        {\n            prevX = this._prevEmitterPos.x;\n            prevY = this._prevEmitterPos.y;\n        }\n        // store current position of the emitter as local variables\n        const curX = this.ownerPos.x + this.spawnPos.x;\n        const curY = this.ownerPos.y + this.spawnPos.y;\n        // spawn new particles\n\n        if (this._emit)\n        {\n            // decrease spawn timer\n            this._spawnTimer -= delta < 0 ? 0 : delta;\n            // while _spawnTimer < 0, we have particles to spawn\n            while (this._spawnTimer <= 0)\n            {\n                // determine if the emitter should stop spawning\n                if (this._emitterLife >= 0)\n                {\n                    this._emitterLife -= this._frequency;\n                    if (this._emitterLife <= 0)\n                    {\n                        this._spawnTimer = 0;\n                        this._emitterLife = 0;\n                        this.emit = false;\n                        break;\n                    }\n                }\n                // determine if we have hit the particle limit\n                if (this.particleCount >= this.maxParticles)\n                {\n                    this._spawnTimer += this._frequency;\n                    continue;\n                }\n                let emitPosX: number;\n                let emitPosY: number;\n\n                // If the position has changed and this isn't the first spawn,\n                // interpolate the spawn position\n                if (this._prevPosIsValid && this._posChanged)\n                {\n                    // 1 - _spawnTimer / delta, but _spawnTimer is negative\n                    const lerp = 1 + (this._spawnTimer / delta);\n\n                    emitPosX = ((curX - prevX) * lerp) + prevX;\n                    emitPosY = ((curY - prevY) * lerp) + prevY;\n                }\n                // otherwise just set to the spawn position\n                else\n                {\n                    emitPosX = curX;\n                    emitPosY = curY;\n                }\n\n                let waveFirst: Particle = null;\n                let waveLast: Particle = null;\n\n                // create enough particles to fill the wave\n                for (let len = Math.min(this.particlesPerWave, this.maxParticles - this.particleCount), i = 0; i < len; ++i)\n                {\n                    // see if we actually spawn one\n                    if (this.spawnChance < 1 && Math.random() >= this.spawnChance)\n                    {\n                        continue;\n                    }\n                    // determine the particle lifetime\n                    let lifetime;\n\n                    if (this.minLifetime === this.maxLifetime)\n                    {\n                        lifetime = this.minLifetime;\n                    }\n                    else\n                    {\n                        lifetime = (Math.random() * (this.maxLifetime - this.minLifetime)) + this.minLifetime;\n                    }\n                    // only make the particle if it wouldn't immediately destroy itself\n                    if (-this._spawnTimer >= lifetime)\n                    {\n                        continue;\n                    }\n                    // create particle\n                    let p: Particle;\n\n                    if (this._poolFirst)\n                    {\n                        p = this._poolFirst;\n                        this._poolFirst = this._poolFirst.next;\n                        p.next = null;\n                    }\n                    else\n                    {\n                        p = new Particle(this);\n                    }\n\n                    // initialize particle\n                    p.init(lifetime);\n                    // add the particle to the display list\n                    if (this.addAtBack)\n                    {\n                        this._parent.addChildAt(p, 0);\n                    }\n                    else\n                    {\n                        this._parent.addChild(p);\n                    }\n                    // add particles to list of ones in this wave\n                    if (waveFirst)\n                    {\n                        waveLast.next = p;\n                        p.prev = waveLast;\n                        waveLast = p;\n                    }\n                    else\n                    {\n                        waveLast = waveFirst = p;\n                    }\n                    // increase our particle count\n                    ++this.particleCount;\n                }\n\n                if (waveFirst)\n                {\n                    // add particle to list of active particles\n                    if (this._activeParticlesLast)\n                    {\n                        this._activeParticlesLast.next = waveFirst;\n                        waveFirst.prev = this._activeParticlesLast;\n                        this._activeParticlesLast = waveLast;\n                    }\n                    else\n                    {\n                        this._activeParticlesFirst = waveFirst;\n                        this._activeParticlesLast = waveLast;\n                    }\n                    // run behavior init on particles\n                    for (let i = 0; i < this.initBehaviors.length; ++i)\n                    {\n                        const behavior = this.initBehaviors[i];\n\n                        // if we hit our special key, interrupt behaviors to apply\n                        // emitter position/rotation\n                        if (behavior === PositionParticle)\n                        {\n                            for (let particle = waveFirst, next; particle; particle = next)\n                            {\n                                // save next particle in case we recycle this one\n                                next = particle.next;\n                                // rotate the particle's position by the emitter's rotation\n                                if (this.rotation !== 0)\n                                {\n                                    rotatePoint(this.rotation, particle.position);\n                                    particle.rotation += this.rotation;\n                                }\n                                // offset by the emitter's position\n                                particle.position.x += emitPosX;\n                                particle.position.y += emitPosY;\n\n                                // also, just update the particle's age properties while we are looping through\n                                particle.age += delta;\n                                // determine our interpolation value\n                                let lerp = particle.age * particle.oneOverLife;// lifetime / maxLife;\n\n                                // global ease affects all interpolation calculations\n                                if (this.customEase)\n                                {\n                                    if (this.customEase.length === 4)\n                                    {\n                                        // the t, b, c, d parameters that some tween libraries use\n                                        // (time, initial value, end value, duration)\n                                        lerp = (this.customEase as any)(lerp, 0, 1, 1);\n                                    }\n                                    else\n                                    {\n                                        // the simplified version that we like that takes\n                                        // one parameter, time from 0-1. TweenJS eases provide this usage.\n                                        lerp = this.customEase(lerp);\n                                    }\n                                }\n                                // set age percent for all interpolation calculations\n                                particle.agePercent = lerp;\n                            }\n                        }\n                        else\n                        {\n                            behavior.initParticles(waveFirst);\n                        }\n                    }\n                    for (let particle = waveFirst, next; particle; particle = next)\n                    {\n                        // save next particle in case we recycle this one\n                        next = particle.next;\n                        // now update the particles by the time passed, so the particles are spread out properly\n                        for (let i = 0; i < this.updateBehaviors.length; ++i)\n                        {\n                            // we want a positive delta, because a negative delta messes things up\n                            if (this.updateBehaviors[i].updateParticle(particle, -this._spawnTimer))\n                            {\n                                // bail if the particle got reycled\n                                this.recycle(particle);\n                                break;\n                            }\n                        }\n                    }\n                }\n                // increase timer and continue on to any other particles that need to be created\n                this._spawnTimer += this._frequency;\n            }\n        }\n        // if the position changed before this update, then keep track of that\n        if (this._posChanged)\n        {\n            this._prevEmitterPos.x = curX;\n            this._prevEmitterPos.y = curY;\n            this._prevPosIsValid = true;\n            this._posChanged = false;\n        }\n\n        // if we are all done and should destroy ourselves, take care of that\n        if (!this._emit && !this._activeParticlesFirst)\n        {\n            if (this._completeCallback)\n            {\n                const cb = this._completeCallback;\n\n                this._completeCallback = null;\n                cb();\n            }\n            if (this._destroyWhenComplete)\n            {\n                this.destroy();\n            }\n        }\n    }\n\n    /**\n     * Emits a single wave of particles, using standard spawnChance & particlesPerWave settings. Does not affect\n     * regular spawning through the frequency, and ignores the emit property.\n     */\n    public emitNow(): void\n    {\n        const emitPosX = this.ownerPos.x + this.spawnPos.x;\n        const emitPosY = this.ownerPos.y + this.spawnPos.y;\n\n        let waveFirst: Particle = null;\n        let waveLast: Particle = null;\n\n        // create enough particles to fill the wave\n        for (let len = Math.min(this.particlesPerWave, this.maxParticles - this.particleCount), i = 0; i < len; ++i)\n        {\n            // see if we actually spawn one\n            if (this.spawnChance < 1 && Math.random() >= this.spawnChance)\n            {\n                continue;\n            }\n            // create particle\n            let p: Particle;\n\n            if (this._poolFirst)\n            {\n                p = this._poolFirst;\n                this._poolFirst = this._poolFirst.next;\n                p.next = null;\n            }\n            else\n            {\n                p = new Particle(this);\n            }\n\n            let lifetime: number;\n\n            if (this.minLifetime === this.maxLifetime)\n            {\n                lifetime = this.minLifetime;\n            }\n            else\n            {\n                lifetime = (Math.random() * (this.maxLifetime - this.minLifetime)) + this.minLifetime;\n            }\n            // initialize particle\n            p.init(lifetime);\n            // add the particle to the display list\n            if (this.addAtBack)\n            {\n                this._parent.addChildAt(p, 0);\n            }\n            else\n            {\n                this._parent.addChild(p);\n            }\n            // add particles to list of ones in this wave\n            if (waveFirst)\n            {\n                waveLast.next = p;\n                p.prev = waveLast;\n                waveLast = p;\n            }\n            else\n            {\n                waveLast = waveFirst = p;\n            }\n            // increase our particle count\n            ++this.particleCount;\n        }\n\n        if (waveFirst)\n        {\n            // add particle to list of active particles\n            if (this._activeParticlesLast)\n            {\n                this._activeParticlesLast.next = waveFirst;\n                waveFirst.prev = this._activeParticlesLast;\n                this._activeParticlesLast = waveLast;\n            }\n            else\n            {\n                this._activeParticlesFirst = waveFirst;\n                this._activeParticlesLast = waveLast;\n            }\n            // run behavior init on particles\n            for (let i = 0; i < this.initBehaviors.length; ++i)\n            {\n                const behavior = this.initBehaviors[i];\n\n                // if we hit our special key, interrupt behaviors to apply\n                // emitter position/rotation\n                if (behavior === PositionParticle)\n                {\n                    for (let particle = waveFirst, next; particle; particle = next)\n                    {\n                        // save next particle in case we recycle this one\n                        next = particle.next;\n                        // rotate the particle's position by the emitter's rotation\n                        if (this.rotation !== 0)\n                        {\n                            rotatePoint(this.rotation, particle.position);\n                            particle.rotation += this.rotation;\n                        }\n                        // offset by the emitter's position\n                        particle.position.x += emitPosX;\n                        particle.position.y += emitPosY;\n                    }\n                }\n                else\n                {\n                    behavior.initParticles(waveFirst);\n                }\n            }\n        }\n    }\n\n    /**\n     * Kills all active particles immediately.\n     */\n    public cleanup(): void\n    {\n        let particle;\n        let next;\n\n        for (particle = this._activeParticlesFirst; particle; particle = next)\n        {\n            next = particle.next;\n            this.recycle(particle, true);\n        }\n        this._activeParticlesFirst = this._activeParticlesLast = null;\n        this.particleCount = 0;\n    }\n\n    /**\n     * Destroys the emitter and all of its particles.\n     */\n    public destroy(): void\n    {\n        // make sure we aren't still listening to any tickers\n        this.autoUpdate = false;\n        // puts all active particles in the pool, and removes them from the particle parent\n        this.cleanup();\n        // wipe the pool clean\n        let next;\n\n        for (let particle = this._poolFirst; particle; particle = next)\n        {\n            // store next value so we don't lose it in our destroy call\n            next = particle.next;\n            particle.destroy();\n        }\n        this._poolFirst = this._parent = this.spawnPos = this.ownerPos\n            = this.customEase = this._completeCallback = null;\n    }\n}\n","import { Particle } from '../../Particle';\nimport type { ObjectProperty } from '../editor/Types';\nimport { SpawnShape } from './SpawnShape';\n\n/**\n * A rectangle for generating spawn positions.\n */\nexport class Rectangle implements SpawnShape\n{\n    public static type = 'rect';\n    public static editorConfig: ObjectProperty = null;\n    /**\n     * X (left) position of the rectangle.\n     */\n    public x: number;\n    /**\n     * Y (top) position of the rectangle.\n     */\n    public y: number;\n    /**\n     * Width of the rectangle.\n     */\n    public w: number;\n    /**\n     * Height of the rectangle.\n     */\n    public h: number;\n\n    constructor(config: {x: number; y: number; w: number; h: number})\n    {\n        this.x = config.x;\n        this.y = config.y;\n        this.w = config.w;\n        this.h = config.h;\n    }\n\n    getRandPos(particle: Particle): void\n    {\n        // place the particle at a random point in the rectangle\n        particle.x = (Math.random() * this.w) + this.x;\n        particle.y = (Math.random() * this.h) + this.y;\n    }\n}\n","import { Particle } from '../../Particle';\nimport { rotatePoint } from '../../ParticleUtils';\nimport { ObjectProperty } from '../editor/Types';\nimport { SpawnShape } from './SpawnShape';\n\n/**\n * A class for spawning particles in a circle or ring.\n * Can optionally apply rotation to particles so that they are aimed away from the center of the circle.\n */\nexport class Torus implements SpawnShape\n{\n    public static type = 'torus';\n    public static editorConfig: ObjectProperty = null;\n    /**\n     * X position of the center of the shape.\n     */\n    public x: number;\n    /**\n     * Y position of the center of the shape.\n     */\n    public y: number;\n    /**\n     * Radius of circle, or outer radius of a ring.\n     */\n    public radius: number;\n    /**\n     * Inner radius of a ring. Use 0 to have a circle.\n     */\n    public innerRadius: number;\n    /**\n     * If rotation should be applied to particles.\n     */\n    public rotation: boolean;\n\n    constructor(config: {radius: number; x: number; y: number; innerRadius?: number; affectRotation?: boolean})\n    {\n        this.x = config.x || 0;\n        this.y = config.y || 0;\n        this.radius = config.radius;\n        this.innerRadius = config.innerRadius || 0;\n        this.rotation = !!config.affectRotation;\n    }\n\n    getRandPos(particle: Particle): void\n    {\n        // place the particle at a random radius in the ring\n        if (this.innerRadius !== this.radius)\n        {\n            particle.x = (Math.random() * (this.radius - this.innerRadius)) + this.innerRadius;\n        }\n        else\n        {\n            particle.x = this.radius;\n        }\n        particle.y = 0;\n        // rotate the point to a random angle in the circle\n        const angle = Math.random() * Math.PI * 2;\n\n        if (this.rotation)\n        {\n            particle.rotation += angle;\n        }\n        rotatePoint(angle, particle.position);\n        // now add in the center of the torus\n        particle.position.x += this.x;\n        particle.position.y += this.y;\n    }\n}\n","import { IPointData } from '@pixi/math';\nimport { ListProperty } from '../editor/Types';\nimport { SpawnShape } from './SpawnShape';\n\nexport interface Segment\n{\n    p1: IPointData;\n    p2: IPointData;\n    l: number;\n}\n\n/**\n * Chain of line segments for generating spawn positions.\n */\nexport class PolygonalChain implements SpawnShape\n{\n    public static type = 'polygonalChain';\n    public static editorConfig: ListProperty = null;\n    /**\n     * List of segment objects in the chain.\n     */\n    private segments: Segment[];\n    /**\n     * Total length of all segments of the chain.\n     */\n    private totalLength: number;\n    /**\n     * Total length of segments up to and including the segment of the same index.\n     * Used for weighted random selection of segment.\n     */\n    private countingLengths: number[];\n\n    /**\n     * @param data Point data for polygon chains. Either a list of points for a single chain, or a list of chains.\n     */\n    constructor(data: IPointData[]|IPointData[][])\n    {\n        this.segments = [];\n        this.countingLengths = [];\n        this.totalLength = 0;\n        this.init(data);\n    }\n\n    /**\n     * @param data Point data for polygon chains. Either a list of points for a single chain, or a list of chains.\n     */\n    private init(data: IPointData[]|IPointData[][]): void\n    {\n        // if data is not present, set up a segment of length 0\n        if (!data || !data.length)\n        {\n            this.segments.push({ p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 }, l: 0 });\n        }\n        else if (Array.isArray(data[0]))\n        {\n            // list of segment chains, each defined as a list of points\n            for (let i = 0; i < data.length; ++i)\n            {\n                // loop through the chain, connecting points\n                const chain = data[i] as IPointData[];\n                let prevPoint = chain[0] as IPointData;\n\n                for (let j = 1; j < chain.length; ++j)\n                {\n                    const second = chain[j] as IPointData;\n\n                    this.segments.push({ p1: prevPoint, p2: second, l: 0 });\n                    prevPoint = second;\n                }\n            }\n        }\n        else\n        {\n            let prevPoint = data[0] as IPointData;\n            // list of points\n\n            for (let i = 1; i < data.length; ++i)\n            {\n                const second = data[i] as IPointData;\n\n                this.segments.push({ p1: prevPoint, p2: second, l: 0 });\n                prevPoint = second;\n            }\n        }\n        // now go through our segments to calculate the lengths so that we\n        // can set up a nice weighted random distribution\n        for (let i = 0; i < this.segments.length; ++i)\n        {\n            const { p1, p2 } = this.segments[i];\n            const segLength = Math.sqrt(((p2.x - p1.x) * (p2.x - p1.x)) + ((p2.y - p1.y) * (p2.y - p1.y)));\n            // save length so we can turn a random number into a 0-1 interpolation value later\n\n            this.segments[i].l = segLength;\n            this.totalLength += segLength;\n            // keep track of the length so far, counting up\n            this.countingLengths.push(this.totalLength);\n        }\n    }\n\n    /**\n     * Gets a random point in the chain.\n     * @param out The point to store the selected position in.\n     */\n    public getRandPos(out: IPointData): void\n    {\n        // select a random spot in the length of the chain\n        const rand = Math.random() * this.totalLength;\n        let chosenSeg: Segment;\n        let lerp: number;\n\n        // if only one segment, it wins\n        if (this.segments.length === 1)\n        {\n            chosenSeg = this.segments[0];\n            lerp = rand;\n        }\n        else\n        {\n            // otherwise, go through countingLengths until we have determined\n            // which segment we chose\n            for (let i = 0; i < this.countingLengths.length; ++i)\n            {\n                if (rand < this.countingLengths[i])\n                {\n                    chosenSeg = this.segments[i];\n                    // set lerp equal to the length into that segment\n                    // (i.e. the remainder after subtracting all the segments before it)\n                    lerp = i === 0 ? rand : rand - this.countingLengths[i - 1];\n                    break;\n                }\n            }\n        }\n        // divide lerp by the segment length, to result in a 0-1 number.\n        lerp /= chosenSeg.l || 1;\n        const { p1, p2 } = chosenSeg;\n        // now calculate the position in the segment that the lerp value represents\n\n        out.x = p1.x + (lerp * (p2.x - p1.x));\n        out.y = p1.y + (lerp * (p2.y - p1.y));\n    }\n}\n","import { Point } from '@pixi/math';\nimport { Particle } from '../Particle';\nimport { rotatePoint, scaleBy, length } from '../ParticleUtils';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\nexport class AccelerationBehavior implements IEmitterBehavior\n{\n    public static type = 'moveAcceleration';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    // doesn't _really_ need to be late, but doing so ensures that we can override any\n    // rotation behavior that is mistakenly added\n    public order = BehaviorOrder.Late;\n    private minStart: number;\n    private maxStart: number;\n    private accel: {x: number; y: number};\n    private rotate: boolean;\n    private maxSpeed: number;\n    constructor(config: {\n        /**\n         * Minimum speed when initializing the particle.\n         */\n        minStart: number;\n        /**\n         * Maximum speed when initializing the particle.\n         */\n        maxStart: number;\n        /**\n         * Constant acceleration, in the coordinate space of the particle parent.\n         */\n        accel: {x: number; y: number};\n        /**\n         * Rotate the particle with its direction of movement.\n         * While initial movement direction reacts to rotation settings, this overrides any dynamic rotation.\n         */\n        rotate: boolean;\n        /**\n         * Maximum linear speed. 0 is unlimited.\n         */\n        maxSpeed: number;\n    })\n    {\n        this.minStart = config.minStart;\n        this.maxStart = config.maxStart;\n        this.accel = config.accel;\n        this.rotate = !!config.rotate;\n        this.maxSpeed = config.maxSpeed ?? 0;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            const speed = (Math.random() * (this.maxStart - this.minStart)) + this.minStart;\n\n            if (!next.config.velocity)\n            {\n                next.config.velocity = new Point(speed, 0);\n            }\n            else\n            {\n                (next.config.velocity as Point).set(speed, 0);\n            }\n\n            rotatePoint(next.rotation, next.config.velocity);\n\n            next = next.next;\n        }\n    }\n\n    updateParticle(particle: Particle, deltaSec: number): void\n    {\n        const vel = particle.config.velocity;\n        const oldVX = vel.x;\n        const oldVY = vel.y;\n\n        vel.x += this.accel.x * deltaSec;\n        vel.y += this.accel.y * deltaSec;\n        if (this.maxSpeed)\n        {\n            const currentSpeed = length(vel);\n            // if we are going faster than we should, clamp at the max speed\n            // DO NOT recalculate vector length\n\n            if (currentSpeed > this.maxSpeed)\n            {\n                scaleBy(vel, this.maxSpeed / currentSpeed);\n            }\n        }\n        // calculate position delta by the midpoint between our old velocity and our new velocity\n        particle.x += (oldVX + vel.x) / 2 * deltaSec;\n        particle.y += (oldVY + vel.y) / 2 * deltaSec;\n        if (this.rotate)\n        {\n            particle.rotation = Math.atan2(vel.y, vel.x);\n        }\n    }\n}\n","import { combineRGBComponents, SimpleEase, Color } from './ParticleUtils';\nimport { PropertyNode } from './PropertyNode';\n\nfunction intValueSimple(this: PropertyList<number>, lerp: number): number\n{\n    if (this.ease) lerp = this.ease(lerp);\n\n    return ((this.first.next.value - this.first.value) * lerp) + this.first.value;\n}\n\nfunction intColorSimple(this: PropertyList<Color>, lerp: number): number\n{\n    if (this.ease) lerp = this.ease(lerp);\n\n    const curVal = this.first.value;\n    const nextVal = this.first.next.value;\n    const r = ((nextVal.r - curVal.r) * lerp) + curVal.r;\n    const g = ((nextVal.g - curVal.g) * lerp) + curVal.g;\n    const b = ((nextVal.b - curVal.b) * lerp) + curVal.b;\n\n    return combineRGBComponents(r, g, b);\n}\n\nfunction intValueComplex(this: PropertyList<number>, lerp: number): number\n{\n    if (this.ease) lerp = this.ease(lerp);\n\n    // make sure we are on the right segment\n    let current = this.first;\n    let next = current.next;\n\n    while (lerp > next.time)\n    {\n        current = next;\n        next = next.next;\n    }\n    // convert the lerp value to the segment range\n    lerp = (lerp - current.time) / (next.time - current.time);\n\n    return ((next.value - current.value) * lerp) + current.value;\n}\n\nfunction intColorComplex(this: PropertyList<Color>, lerp: number): number\n{\n    if (this.ease) lerp = this.ease(lerp);\n\n    // make sure we are on the right segment\n    let current = this.first;\n    let next = current.next;\n\n    while (lerp > next.time)\n    {\n        current = next;\n        next = next.next;\n    }\n    // convert the lerp value to the segment range\n    lerp = (lerp - current.time) / (next.time - current.time);\n    const curVal = current.value;\n    const nextVal = next.value;\n    const r = ((nextVal.r - curVal.r) * lerp) + curVal.r;\n    const g = ((nextVal.g - curVal.g) * lerp) + curVal.g;\n    const b = ((nextVal.b - curVal.b) * lerp) + curVal.b;\n\n    return combineRGBComponents(r, g, b);\n}\n\nfunction intValueStepped(this: PropertyList<number>, lerp: number): number\n{\n    if (this.ease) lerp = this.ease(lerp);\n\n    // make sure we are on the right segment\n    let current = this.first;\n\n    while (current.next && lerp > current.next.time)\n    {\n        current = current.next;\n    }\n\n    return current.value;\n}\n\nfunction intColorStepped(this: PropertyList<Color>, lerp: number): number\n{\n    if (this.ease) lerp = this.ease(lerp);\n\n    // make sure we are on the right segment\n    let current = this.first;\n\n    while (current.next && lerp > current.next.time)\n    {\n        current = current.next;\n    }\n    const curVal = current.value;\n\n    return combineRGBComponents(curVal.r, curVal.g, curVal.b);\n}\n\n/**\n * Singly linked list container for keeping track of interpolated properties for particles.\n * Each Particle will have one of these for each interpolated property.\n */\nexport class PropertyList<V>\n{\n    /**\n     * The first property node in the linked list.\n     */\n    public first: PropertyNode<V>;\n    /**\n     * Calculates the correct value for the current interpolation value. This method is set in\n     * the reset() method.\n     * @param lerp The interpolation value from 0-1.\n     * @return The interpolated value. Colors are converted to the hex value.\n     */\n    public interpolate: (lerp: number) => number;\n    /**\n     * A custom easing method for this list.\n     * @param lerp The interpolation value from 0-1.\n     * @return The eased value, also from 0-1.\n     */\n    public ease: SimpleEase;\n    /**\n     * If this list manages colors, which requires a different method for interpolation.\n     */\n    private isColor: boolean;\n\n    /**\n     * @param isColor If this list handles color values\n     */\n    constructor(isColor = false)\n    {\n        this.first = null;\n        this.isColor = !!isColor;\n        this.interpolate = null;\n        this.ease = null;\n    }\n\n    /**\n     * Resets the list for use.\n     * @param first The first node in the list.\n     * @param first.isStepped If the values should be stepped instead of interpolated linearly.\n     */\n    public reset(first: PropertyNode<V>): void\n    {\n        this.first = first;\n        const isSimple = first.next && first.next.time >= 1;\n\n        if (isSimple)\n        {\n            this.interpolate = this.isColor ? intColorSimple : intValueSimple;\n        }\n        else if (first.isStepped)\n        {\n            this.interpolate = this.isColor ? intColorStepped : intValueStepped;\n        }\n        else\n        {\n            this.interpolate = this.isColor ? intColorComplex : intValueComplex;\n        }\n        this.ease = this.first.ease;\n    }\n}\n","import { Particle } from '../Particle';\nimport { PropertyList } from '../PropertyList';\nimport { PropertyNode, ValueList } from '../PropertyNode';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\nexport class AlphaBehavior implements IEmitterBehavior\n{\n    public static type = 'alpha';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private list: PropertyList<number>;\n    constructor(config: {\n        /**\n         * Transparency of the particles from 0 (transparent) to 1 (opaque)\n         */\n        alpha: ValueList<number>;\n    })\n    {\n        this.list = new PropertyList(false);\n        this.list.reset(PropertyNode.createList(config.alpha));\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            next.alpha = this.list.first.value;\n            next = next.next;\n        }\n    }\n\n    updateParticle(particle: Particle): void\n    {\n        particle.alpha = this.list.interpolate(particle.agePercent);\n    }\n}\n\nexport class StaticAlphaBehavior implements IEmitterBehavior\n{\n    public static type = 'alphaStatic';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private value: number;\n    constructor(config: {\n        /**\n         * Transparency of the particles from 0 (transparent) to 1 (opaque)\n         */\n        alpha: number;\n    })\n    {\n        this.value = config.alpha;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            next.alpha = this.value;\n            next = next.next;\n        }\n    }\n}\n","import { Texture } from '@pixi/core';\nimport { Particle } from '../Particle';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { GetTextureFromString } from '../ParticleUtils';\nimport { BehaviorEditorConfig } from './editor/Types';\n\nexport interface AnimatedParticleArt\n{\n    framerate: -1|number;\n    loop?: boolean;\n    textures: (string|Texture|{texture: string|Texture; count: number})[];\n}\n\ninterface ParsedAnimatedParticleArt\n{\n    textures: Texture[];\n    duration: number;\n    framerate: number;\n    loop: boolean;\n}\n\nfunction getTextures(textures: (string|Texture|{texture: string|Texture; count: number})[]): Texture[]\n{\n    const outTextures: Texture[] = [];\n\n    for (let j = 0; j < textures.length; ++j)\n    {\n        let tex = textures[j];\n\n        if (typeof tex === 'string')\n        {\n            outTextures.push(GetTextureFromString(tex));\n        }\n        else if (tex instanceof Texture)\n        {\n            outTextures.push(tex);\n        }\n        // assume an object with extra data determining duplicate frame data\n        else\n        {\n            let dupe = tex.count || 1;\n\n            if (typeof tex.texture === 'string')\n            {\n                tex = GetTextureFromString(tex.texture);\n            }\n            else// if(tex.texture instanceof Texture)\n            {\n                tex = tex.texture;\n            }\n            for (; dupe > 0; --dupe)\n            {\n                outTextures.push(tex);\n            }\n        }\n    }\n\n    return outTextures;\n}\n\nexport class RandomAnimatedTextureBehavior implements IEmitterBehavior\n{\n    public static type = 'animatedRandom';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private anims: ParsedAnimatedParticleArt[];\n    constructor(config: {\n        /**\n         * Property: anims\n         * Type: AnimatedParticleArt[]\n         * Title: Particle Animations\n         * Description: Animation configuration to use for each particle, randomly chosen from the list.\n         */\n        anims: AnimatedParticleArt[];\n    })\n    {\n        this.anims = [];\n        for (let i = 0; i < config.anims.length; ++i)\n        {\n            const anim = config.anims[i];\n            const textures = getTextures(anim.textures);\n            // eslint-disable-next-line no-nested-ternary\n            const framerate = anim.framerate < 0 ? -1 : (anim.framerate > 0 ? anim.framerate : 60);\n            const parsedAnim: ParsedAnimatedParticleArt = {\n                textures,\n                duration: framerate > 0 ? textures.length / framerate : 0,\n                framerate,\n                loop: framerate > 0 ? !!anim.loop : false,\n            };\n\n            this.anims.push(parsedAnim);\n        }\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            const index = Math.floor(Math.random() * this.anims.length);\n            const anim = next.config.anim = this.anims[index];\n\n            next.texture = anim.textures[0];\n            next.config.animElapsed = 0;\n            // if anim should match particle life exactly\n            if (anim.framerate === -1)\n            {\n                next.config.animDuration = next.maxLife;\n                next.config.animFramerate = anim.textures.length / next.maxLife;\n            }\n            else\n            {\n                next.config.animDuration = anim.duration;\n                next.config.animFramerate = anim.framerate;\n            }\n\n            next = next.next;\n        }\n    }\n\n    updateParticle(particle: Particle, deltaSec: number): void\n    {\n        const config = particle.config;\n        const anim = config.anim;\n\n        config.animElapsed += deltaSec;\n        if (config.animElapsed >= config.animDuration)\n        {\n            // loop elapsed back around\n            if (config.anim.loop)\n            {\n                config.animElapsed = config.animElapsed % config.animDuration;\n            }\n            // subtract a small amount to prevent attempting to go past the end of the animation\n            else\n            {\n                config.animElapsed = config.animDuration - 0.000001;\n            }\n        }\n        // add a very small number to the frame and then floor it to avoid\n        // the frame being one short due to floating point errors.\n        const frame = ((config.animElapsed * config.animFramerate) + 0.0000001) | 0;\n\n        // in the very rare case that framerate * elapsed math ends up going past the end, use the last texture\n        particle.texture = anim.textures[frame] || anim.textures[anim.textures.length - 1] || Texture.EMPTY;\n    }\n}\n\nexport class SingleAnimatedTextureBehavior implements IEmitterBehavior\n{\n    public static type = 'animatedSingle';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private anim: ParsedAnimatedParticleArt;\n    constructor(config: {\n        /**\n         * Property: anim\n         * Type: AnimatedParticleArt\n         * Title: Particle Animations\n         * Description: Animation configuration to use for each particle.\n         */\n        anim: AnimatedParticleArt;\n    })\n    {\n        const anim = config.anim;\n        const textures = getTextures(anim.textures);\n        // eslint-disable-next-line no-nested-ternary\n        const framerate = anim.framerate < 0 ? -1 : (anim.framerate > 0 ? anim.framerate : 60);\n\n        this.anim = {\n            textures,\n            duration: framerate > 0 ? textures.length / framerate : 0,\n            framerate,\n            loop: framerate > 0 ? !!anim.loop : false,\n        };\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n        const anim = this.anim;\n\n        while (next)\n        {\n            next.texture = anim.textures[0];\n            next.config.animElapsed = 0;\n            // if anim should match particle life exactly\n            if (anim.framerate === -1)\n            {\n                next.config.animDuration = next.maxLife;\n                next.config.animFramerate = anim.textures.length / next.maxLife;\n            }\n            else\n            {\n                next.config.animDuration = anim.duration;\n                next.config.animFramerate = anim.framerate;\n            }\n\n            next = next.next;\n        }\n    }\n\n    updateParticle(particle: Particle, deltaSec: number): void\n    {\n        const anim = this.anim;\n        const config = particle.config;\n\n        config.animElapsed += deltaSec;\n        if (config.animElapsed >= config.animDuration)\n        {\n            // loop elapsed back around\n            if (config.anim.loop)\n            {\n                config.animElapsed = config.animElapsed % config.animDuration;\n            }\n            // subtract a small amount to prevent attempting to go past the end of the animation\n            else\n            {\n                config.animElapsed = config.animDuration - 0.000001;\n            }\n        }\n        // add a very small number to the frame and then floor it to avoid\n        // the frame being one short due to floating point errors.\n        const frame = ((config.animElapsed * config.animFramerate) + 0.0000001) | 0;\n\n        // in the very rare case that framerate * elapsed math ends up going past the end, use the last texture\n        particle.texture = anim.textures[frame] || anim.textures[anim.textures.length - 1] || Texture.EMPTY;\n    }\n}\n","import { Particle } from '../Particle';\nimport { getBlendMode } from '../ParticleUtils';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\nexport class BlendModeBehavior implements IEmitterBehavior\n{\n    public static type = 'blendMode';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private value: string;\n    constructor(config: {\n        /**\n         * Blend mode of all particles.\n         */\n        blendMode: string;\n    })\n    {\n        this.value = config.blendMode;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            next.blendMode = getBlendMode(this.value);\n            next = next.next;\n        }\n    }\n}\n","import { Particle } from '../Particle';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { DEG_TO_RADS, rotatePoint } from '../ParticleUtils';\nimport { BehaviorEditorConfig } from './editor/Types';\n\nexport class BurstSpawn implements IEmitterBehavior\n{\n    public static type = 'spawnBurst';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    order = BehaviorOrder.Spawn;\n    private spacing: number;\n    private start: number;\n    private distance: number;\n\n    constructor(config: {\n        /**\n         * Description: Spacing between each particle spawned in a wave, in degrees.\n         */\n        spacing: number;\n        /**\n         * Description: Angle to start placing particles at, in degrees. 0 is facing right, 90 is facing upwards.\n         */\n        start: number;\n        /**\n         * Description: Distance from the emitter to spawn particles, forming a ring/arc.\n         */\n        distance: number;\n    })\n    {\n        this.spacing = config.spacing * DEG_TO_RADS;\n        this.start = config.start * DEG_TO_RADS;\n        this.distance = config.distance;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let count = 0;\n        let next = first;\n\n        while (next)\n        {\n            let angle: number;\n\n            if (this.spacing)\n            {\n                angle = this.start + (this.spacing * count);\n            }\n            else\n            {\n                angle = Math.random() * Math.PI * 2;\n            }\n\n            next.rotation = angle;\n            if (this.distance)\n            {\n                next.position.x = this.distance;\n                rotatePoint(angle, next.position);\n            }\n            next = next.next;\n            ++count;\n        }\n    }\n}\n","import { Particle } from '../Particle';\nimport { Color, combineRGBComponents } from '../ParticleUtils';\nimport { PropertyList } from '../PropertyList';\nimport { PropertyNode, ValueList } from '../PropertyNode';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\nexport class ColorBehavior implements IEmitterBehavior\n{\n    public static type = 'color';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private list: PropertyList<Color>;\n    constructor(config: {\n        /**\n         * Color of the particles as 6 digit hex codes.\n         */\n        color: ValueList<string>;\n    })\n    {\n        this.list = new PropertyList(true);\n        this.list.reset(PropertyNode.createList(config.color));\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n        const color = this.list.first.value;\n        const tint = combineRGBComponents(color.r, color.g, color.b);\n\n        while (next)\n        {\n            next.tint = tint;\n            next = next.next;\n        }\n    }\n\n    updateParticle(particle: Particle): void\n    {\n        particle.tint = this.list.interpolate(particle.agePercent);\n    }\n}\n\nexport class StaticColorBehavior implements IEmitterBehavior\n{\n    public static type = 'colorStatic';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private value: number;\n    constructor(config: {\n        /**\n         * Color of the particles as 6 digit hex codes.\n         */\n        color: string;\n    })\n    {\n        let color = config.color;\n\n        if (color.charAt(0) === '#')\n        {\n            color = color.substr(1);\n        }\n        else if (color.indexOf('0x') === 0)\n        {\n            color = color.substr(2);\n        }\n\n        this.value = parseInt(color, 16);\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            next.tint = this.value;\n            next = next.next;\n        }\n    }\n}\n","import { Texture } from '@pixi/core';\nimport { Particle } from '../Particle';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { GetTextureFromString } from '../ParticleUtils';\nimport { BehaviorEditorConfig } from './editor/Types';\n\nexport class OrderedTextureBehavior implements IEmitterBehavior\n{\n    public static type = 'textureOrdered';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private textures: Texture[];\n    private index: number;\n    constructor(config: {\n        /**\n         * Images to use for each particle, used in order before looping around\n         */\n        textures: Texture[];\n    })\n    {\n        this.index = 0;\n        this.textures = config.textures.map((tex) => (typeof tex === 'string' ? GetTextureFromString(tex) : tex));\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            next.texture = this.textures[this.index];\n            if (++this.index >= this.textures.length)\n            {\n                this.index = 0;\n            }\n            next = next.next;\n        }\n    }\n}\n","import { Point } from '@pixi/math';\nimport { Particle } from '../Particle';\nimport { rotatePoint, verbose } from '../ParticleUtils';\nimport { PropertyList } from '../PropertyList';\nimport { PropertyNode, ValueList } from '../PropertyNode';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * A helper point for math things.\n * @hidden\n */\nconst helperPoint = new Point();\n\n/**\n * A hand picked list of Math functions (and a couple properties) that are\n * allowable. They should be used without the preceding \"Math.\"\n * @hidden\n */\nconst MATH_FUNCS = [\n    'E',\n    'LN2',\n    'LN10',\n    'LOG2E',\n    'LOG10E',\n    'PI',\n    'SQRT1_2',\n    'SQRT2',\n    'abs',\n    'acos',\n    'acosh',\n    'asin',\n    'asinh',\n    'atan',\n    'atanh',\n    'atan2',\n    'cbrt',\n    'ceil',\n    'cos',\n    'cosh',\n    'exp',\n    'expm1',\n    'floor',\n    'fround',\n    'hypot',\n    'log',\n    'log1p',\n    'log10',\n    'log2',\n    'max',\n    'min',\n    'pow',\n    'random',\n    'round',\n    'sign',\n    'sin',\n    'sinh',\n    'sqrt',\n    'tan',\n    'tanh',\n];\n/**\n * create an actual regular expression object from the string\n * @hidden\n */\nconst WHITELISTER = new RegExp(\n    [\n        // Allow the 4 basic operations, parentheses and all numbers/decimals, as well\n        // as 'x', for the variable usage.\n        '[01234567890\\\\.\\\\*\\\\-\\\\+\\\\/\\\\(\\\\)x ,]',\n    ].concat(MATH_FUNCS).join('|'),\n    'g',\n);\n\n/**\n * Parses a string into a function for path following.\n * This involves whitelisting the string for safety, inserting \"Math.\" to math function\n * names, and using `new Function()` to generate a function.\n * @hidden\n * @param pathString The string to parse.\n * @return The path function - takes x, outputs y.\n */\nfunction parsePath(pathString: string): (x: number) => number\n{\n    const matches = pathString.match(WHITELISTER);\n\n    for (let i = matches.length - 1; i >= 0; --i)\n    {\n        if (MATH_FUNCS.indexOf(matches[i]) >= 0)\n        { matches[i] = `Math.${matches[i]}`; }\n    }\n    pathString = matches.join('');\n\n    // eslint-disable-next-line no-new-func\n    return new Function('x', `return ${pathString};`) as (x: number) => number;\n}\n\n/**\n * A particle that follows a path defined by an algebraic expression, e.g. \"sin(x)\" or\n * \"5x + 3\".\n * To use this class, the particle config must have a \"path\" string in the\n * \"extraData\" parameter. This string should have \"x\" in it to represent movement (from the\n * speed settings of the particle). It may have numbers, parentheses, the four basic\n * operations, and the following Math functions or properties (without the preceding \"Math.\"):\n * \"pow\", \"sqrt\", \"abs\", \"floor\", \"round\", \"ceil\", \"E\", \"PI\", \"sin\", \"cos\", \"tan\", \"asin\",\n * \"acos\", \"atan\", \"atan2\", \"log\".\n * The overall movement of the particle and the expression value become x and y positions for\n * the particle, respectively. The final position is rotated by the spawn rotation/angle of\n * the particle.\n *\n * Some example paths:\n *\n * \t\"sin(x/10) * 20\" // A sine wave path.\n * \t\"cos(x/100) * 30\" // Particles curve counterclockwise (for medium speed/low lifetime particles)\n * \t\"pow(x/10, 2) / 2\" // Particles curve clockwise (remember, +y is down).\n */\nexport class PathBehavior implements IEmitterBehavior\n{\n    public static type = 'movePath';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    // *MUST* happen after other behaviors do initialization so that we can read initial transformations\n    public order = BehaviorOrder.Late;\n    /**\n     * The function representing the path the particle should take.\n     */\n    private path: (x: number) => number;\n    private list: PropertyList<number>;\n    private minMult: number;\n    constructor(config: {\n        /**\n         * Algebraic expression describing the movement of the particle.\n         */\n        path: string|((x: number) => number);\n        /**\n         * Speed of the particles, with a minimum value of 0. this affects the x value in the path.\n         */\n        speed: ValueList<number>;\n        /**\n         * A value between minimum speed multipler and 1 is randomly generated and multiplied\n         * with each speed value to generate the actual speed for each particle.\n         */\n        minMult: number;\n    })\n    {\n        if (config.path)\n        {\n            if (typeof config.path === 'function')\n            {\n                this.path = config.path;\n            }\n            else\n            {\n                try\n                {\n                    this.path = parsePath(config.path);\n                }\n                catch (e)\n                {\n                    if (verbose)\n                    {\n                        console.error('PathParticle: error in parsing path expression', e);\n                    }\n                    this.path = null;\n                }\n            }\n        }\n        else\n        {\n            if (verbose)\n            {\n                console.error('PathParticle requires a path value in its config!');\n            }\n            // eslint-disable-next-line @typescript-eslint/explicit-function-return-type\n            this.path = (x) => x;\n        }\n        this.list = new PropertyList(false);\n        this.list.reset(PropertyNode.createList(config.speed));\n        this.minMult = config.minMult ?? 1;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            /*\n             * The initial rotation in degrees of the particle, because the direction of the path\n             * is based on that.\n             */\n            next.config.initRotation = next.rotation;\n            /* The initial position of the particle, as all path movement is added to that. */\n            if (!next.config.initPosition)\n            {\n                next.config.initPosition = new Point(next.x, next.y);\n            }\n            else\n            {\n                (next.config.initPosition as Point).copyFrom(next.position);\n            }\n            /* Total single directional movement, due to speed. */\n            next.config.movement = 0;\n\n            // also do speed multiplier, since this includes basic speed movement\n            const mult = (Math.random() * (1 - this.minMult)) + this.minMult;\n\n            next.config.speedMult = mult;\n\n            next = next.next;\n        }\n    }\n\n    updateParticle(particle: Particle, deltaSec: number): void\n    {\n        // increase linear movement based on speed\n        const speed = this.list.interpolate(particle.agePercent) * particle.config.speedMult;\n\n        particle.config.movement += speed * deltaSec;\n        // set up the helper point for rotation\n        helperPoint.x = particle.config.movement;\n        helperPoint.y = this.path(helperPoint.x);\n        rotatePoint(particle.config.initRotation, helperPoint);\n        particle.position.x = particle.config.initPosition.x + helperPoint.x;\n        particle.position.y = particle.config.initPosition.y + helperPoint.y;\n    }\n}\n","import { Particle } from '../Particle';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\nexport class PointSpawn implements IEmitterBehavior\n{\n    public static type = 'spawnPoint';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    order = BehaviorOrder.Spawn;\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    initParticles(_first: Particle): void\n    {\n        // really just a no-op\n    }\n}\n","import { Texture } from '@pixi/core';\nimport { Particle } from '../Particle';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { GetTextureFromString } from '../ParticleUtils';\nimport { BehaviorEditorConfig } from './editor/Types';\n\nexport class RandomTextureBehavior implements IEmitterBehavior\n{\n    public static type = 'textureRandom';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private textures: Texture[];\n    constructor(config: {\n        /**\n         * Images to use for each particle, randomly chosen from the list.\n         */\n        textures: (Texture|string)[];\n    })\n    {\n        this.textures = config.textures.map((tex) => (typeof tex === 'string' ? GetTextureFromString(tex) : tex));\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            const index = Math.floor(Math.random() * this.textures.length);\n\n            next.texture = this.textures[index];\n\n            next = next.next;\n        }\n    }\n}\n","import { Particle } from '../Particle';\nimport { DEG_TO_RADS } from '../ParticleUtils';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\nexport class RotationBehavior implements IEmitterBehavior\n{\n    public static type = 'rotation';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private minStart: number;\n    private maxStart: number;\n    private minSpeed: number;\n    private maxSpeed: number;\n    private accel: number;\n    constructor(config: {\n        /**\n         * Minimum starting rotation of the particles, in degrees. 0 is facing right, 90 is upwards.\n         */\n        minStart: number;\n        /**\n         * Maximum starting rotation of the particles, in degrees. 0 is facing right, 90 is upwards.\n         */\n        maxStart: number;\n        /**\n         * Minimum rotation speed of the particles, in degrees/second. Positive is counter-clockwise.\n         */\n        minSpeed: number;\n        /**\n         * Maximum rotation speed of the particles, in degrees/second. Positive is counter-clockwise.\n         */\n        maxSpeed: number;\n        /**\n         * Constant rotational acceleration of the particles, in degrees/second/second.\n         */\n        accel: number;\n    })\n    {\n        this.minStart = config.minStart * DEG_TO_RADS;\n        this.maxStart = config.maxStart * DEG_TO_RADS;\n        this.minSpeed = config.minSpeed * DEG_TO_RADS;\n        this.maxSpeed = config.maxSpeed * DEG_TO_RADS;\n        this.accel = config.accel * DEG_TO_RADS;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            if (this.minStart === this.maxStart)\n            {\n                next.rotation += this.maxStart;\n            }\n            else\n            {\n                next.rotation += (Math.random() * (this.maxStart - this.minStart)) + this.minStart;\n            }\n            next.config.rotSpeed = (Math.random() * (this.maxSpeed - this.minSpeed)) + this.minSpeed;\n\n            next = next.next;\n        }\n    }\n\n    updateParticle(particle: Particle, deltaSec: number): void\n    {\n        if (this.accel)\n        {\n            const oldSpeed = particle.config.rotSpeed;\n\n            particle.config.rotSpeed += this.accel * deltaSec;\n            particle.rotation += (particle.config.rotSpeed + oldSpeed) / 2 * deltaSec;\n        }\n        else\n        {\n            particle.rotation += particle.config.rotSpeed * deltaSec;\n        }\n    }\n}\n\nexport class StaticRotationBehavior implements IEmitterBehavior\n{\n    public static type = 'rotationStatic';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private min: number;\n    private max: number;\n    constructor(config: {\n        /**\n         * Minimum starting rotation of the particles, in degrees. 0 is facing right, 90 is upwards.\n         */\n        min: number;\n        /**\n         * Maximum starting rotation of the particles, in degrees. 0 is facing right, 90 is upwards.\n         */\n        max: number;\n    })\n    {\n        this.min = config.min * DEG_TO_RADS;\n        this.max = config.max * DEG_TO_RADS;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            if (this.min === this.max)\n            {\n                next.rotation += this.max;\n            }\n            else\n            {\n                next.rotation += (Math.random() * (this.max - this.min)) + this.min;\n            }\n\n            next = next.next;\n        }\n    }\n}\n\nexport class NoRotationBehavior implements IEmitterBehavior\n{\n    public static type = 'noRotation';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Late + 1;\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            next.rotation = 0;\n\n            next = next.next;\n        }\n    }\n}\n","import { Particle } from '../Particle';\nimport { PropertyList } from '../PropertyList';\nimport { PropertyNode, ValueList } from '../PropertyNode';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\nexport class ScaleBehavior implements IEmitterBehavior\n{\n    public static type = 'scale';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private list: PropertyList<number>;\n    private minMult: number;\n    constructor(config: {\n        /**\n         * Scale of the particles, with a minimum value of 0\n         */\n        scale: ValueList<number>;\n        /**\n         * A value between minimum scale multipler and 1 is randomly\n         * generated and multiplied with each scale value to provide the actual scale for each particle.\n         */\n        minMult: number;\n    })\n    {\n        this.list = new PropertyList(false);\n        this.list.reset(PropertyNode.createList(config.scale));\n        this.minMult = config.minMult;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            const mult = (Math.random() * (1 - this.minMult)) + this.minMult;\n\n            next.config.scaleMult = mult;\n            next.scale.x = next.scale.y = this.list.first.value * mult;\n\n            next = next.next;\n        }\n    }\n\n    updateParticle(particle: Particle): void\n    {\n        particle.scale.x = particle.scale.y = this.list.interpolate(particle.agePercent) * particle.config.scaleMult;\n    }\n}\n\nexport class StaticScaleBehavior implements IEmitterBehavior\n{\n    public static type = 'scaleStatic';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private min: number;\n    private max: number;\n    constructor(config: {\n        /**\n         * Minimum scale of the particles, with a minimum value of 0\n         */\n        min: number;\n        /**\n         * Maximum scale of the particles, with a minimum value of 0\n         */\n        max: number;\n    })\n    {\n        this.min = config.min;\n        this.max = config.max;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            const scale = (Math.random() * (this.max - this.min)) + this.min;\n\n            next.scale.x = next.scale.y = scale;\n\n            next = next.next;\n        }\n    }\n}\n","import { Particle } from '../Particle';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { SpawnShape, SpawnShapeClass } from './shapes/SpawnShape';\nimport { PolygonalChain } from './shapes/PolygonalChain';\nimport { Rectangle } from './shapes/Rectangle';\nimport { Torus } from './shapes/Torus';\nimport { BehaviorEditorConfig } from './editor/Types';\n\nexport class ShapeSpawn implements IEmitterBehavior\n{\n    public static type = 'spawnShape';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    /**\n     * Dictionary of all registered shape classes.\n     */\n    private static shapes: {[key: string]: SpawnShapeClass} = {};\n\n    /**\n     * Registers a shape to be used by the ShapeSpawn behavior.\n     * @param constructor The shape class constructor to use, with a static `type` property to reference it by.\n     * @param typeOverride An optional type override, primarily for registering a shape under multiple names.\n     */\n    public static registerShape(constructor: SpawnShapeClass, typeOverride?: string): void\n    {\n        ShapeSpawn.shapes[typeOverride || constructor.type] = constructor;\n    }\n\n    order = BehaviorOrder.Spawn;\n    private shape: SpawnShape;\n\n    constructor(config: {\n        /**\n         * Type of the shape to spawn\n         */\n        type: string;\n        /**\n         * Configuration data for the spawn shape.\n         */\n        data: any;\n    })\n    {\n        const ShapeClass = ShapeSpawn.shapes[config.type];\n\n        if (!ShapeClass)\n        {\n            throw new Error(`No shape found with type '${config.type}'`);\n        }\n        this.shape = new ShapeClass(config.data);\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            this.shape.getRandPos(next);\n            next = next.next;\n        }\n    }\n}\n\nShapeSpawn.registerShape(PolygonalChain);\nShapeSpawn.registerShape(Rectangle);\nShapeSpawn.registerShape(Torus);\nShapeSpawn.registerShape(Torus, 'circle');\n","import { Texture } from '@pixi/core';\nimport { Particle } from '../Particle';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { GetTextureFromString } from '../ParticleUtils';\nimport { BehaviorEditorConfig } from './editor/Types';\n\nexport class SingleTextureBehavior implements IEmitterBehavior\n{\n    public static type = 'textureSingle';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private texture: Texture;\n    constructor(config: {\n        /**\n         * Image to use for each particle.\n         */\n        texture: Texture|string;\n    })\n    {\n        this.texture = typeof config.texture === 'string' ? GetTextureFromString(config.texture) : config.texture;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            next.texture = this.texture;\n\n            next = next.next;\n        }\n    }\n}\n","import { Point } from '@pixi/math';\nimport { Particle } from '../Particle';\nimport { rotatePoint, normalize, scaleBy } from '../ParticleUtils';\nimport { PropertyList } from '../PropertyList';\nimport { PropertyNode, ValueList } from '../PropertyNode';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\nexport class SpeedBehavior implements IEmitterBehavior\n{\n    public static type = 'moveSpeed';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Late;\n    private list: PropertyList<number>;\n    private minMult: number;\n    constructor(config: {\n        /**\n         * Speed of the particles, with a minimum value of 0\n         */\n        speed: ValueList<number>;\n        /**\n         * A value between minimum speed multipler and 1 is randomly\n         * generated and multiplied with each speed value to generate the actual speed for each particle.\n         */\n        minMult: number;\n    })\n    {\n        this.list = new PropertyList(false);\n        this.list.reset(PropertyNode.createList(config.speed));\n        this.minMult = config.minMult ?? 1;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            const mult = (Math.random() * (1 - this.minMult)) + this.minMult;\n\n            next.config.speedMult = mult;\n            if (!next.config.velocity)\n            {\n                next.config.velocity = new Point(this.list.first.value * mult, 0);\n            }\n            else\n            {\n                (next.config.velocity as Point).set(this.list.first.value * mult, 0);\n            }\n\n            rotatePoint(next.rotation, next.config.velocity);\n\n            next = next.next;\n        }\n    }\n\n    updateParticle(particle: Particle, deltaSec: number): void\n    {\n        const speed = this.list.interpolate(particle.agePercent) * particle.config.speedMult;\n        const vel = particle.config.velocity;\n\n        normalize(vel);\n        scaleBy(vel, speed);\n        particle.x += vel.x * deltaSec;\n        particle.y += vel.y * deltaSec;\n    }\n}\n\nexport class StaticSpeedBehavior implements IEmitterBehavior\n{\n    public static type = 'moveSpeedStatic';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Late;\n    private min: number;\n    private max: number;\n    constructor(config: {\n        /**\n         * Minimum speed when initializing the particle.\n         */\n        min: number;\n        /**\n         * Maximum speed when initializing the particle.\n         */\n        max: number;\n    })\n    {\n        this.min = config.min;\n        this.max = config.max;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            const speed = (Math.random() * (this.max - this.min)) + this.min;\n\n            if (!next.config.velocity)\n            {\n                next.config.velocity = new Point(speed, 0);\n            }\n            else\n            {\n                (next.config.velocity as Point).set(speed, 0);\n            }\n\n            rotatePoint(next.rotation, next.config.velocity);\n\n            next = next.next;\n        }\n    }\n\n    updateParticle(particle: Particle, deltaSec: number): void\n    {\n        const velocity = particle.config.velocity;\n\n        particle.x += velocity.x * deltaSec;\n        particle.y += velocity.y * deltaSec;\n    }\n}\n","import { Emitter } from './Emitter';\nimport * as behaviors from './behaviors';\n\nEmitter.registerBehavior(behaviors.AccelerationBehavior);\nEmitter.registerBehavior(behaviors.AlphaBehavior);\nEmitter.registerBehavior(behaviors.StaticAlphaBehavior);\nEmitter.registerBehavior(behaviors.RandomAnimatedTextureBehavior);\nEmitter.registerBehavior(behaviors.SingleAnimatedTextureBehavior);\nEmitter.registerBehavior(behaviors.BlendModeBehavior);\nEmitter.registerBehavior(behaviors.BurstSpawn);\nEmitter.registerBehavior(behaviors.ColorBehavior);\nEmitter.registerBehavior(behaviors.StaticColorBehavior);\nEmitter.registerBehavior(behaviors.OrderedTextureBehavior);\nEmitter.registerBehavior(behaviors.PathBehavior);\nEmitter.registerBehavior(behaviors.PointSpawn);\nEmitter.registerBehavior(behaviors.RandomTextureBehavior);\nEmitter.registerBehavior(behaviors.RotationBehavior);\nEmitter.registerBehavior(behaviors.StaticRotationBehavior);\nEmitter.registerBehavior(behaviors.NoRotationBehavior);\nEmitter.registerBehavior(behaviors.ScaleBehavior);\nEmitter.registerBehavior(behaviors.StaticScaleBehavior);\nEmitter.registerBehavior(behaviors.ShapeSpawn);\nEmitter.registerBehavior(behaviors.SingleTextureBehavior);\nEmitter.registerBehavior(behaviors.SpeedBehavior);\nEmitter.registerBehavior(behaviors.StaticSpeedBehavior);\n\nexport * as behaviors from './behaviors';\nexport * as ParticleUtils from './ParticleUtils';\nexport * from './Particle';\nexport * from './Emitter';\nexport * from './EmitterConfig';\nexport * from './PropertyList';\nexport * from './PropertyNode';\nexport * from './LinkedListContainer';\n","import { Container, DisplayObject } from '@pixi/display';\nimport { Renderer, MaskData } from '@pixi/core';\nimport { Rectangle } from '@pixi/math';\n\n/** Interface for a child of a LinkedListContainer (has the prev/next properties added) */\nexport interface LinkedListChild extends DisplayObject\n{\n    nextChild: LinkedListChild|null;\n    prevChild: LinkedListChild|null;\n}\n\n/**\n * A semi-experimental Container that uses a doubly linked list to manage children instead of an\n * array. This means that adding/removing children often is not the same performance hit that\n * it would to be continually pushing/splicing.\n * However, this is primarily intended to be used for heavy particle usage, and may not handle\n * edge cases well if used as a complete Container replacement.\n */\nexport class LinkedListContainer extends Container\n{\n    private _firstChild: LinkedListChild|null = null;\n    private _lastChild: LinkedListChild|null = null;\n    private _childCount = 0;\n\n    public get firstChild(): LinkedListChild\n    {\n        return this._firstChild;\n    }\n\n    public get lastChild(): LinkedListChild\n    {\n        return this._lastChild;\n    }\n\n    public get childCount(): number\n    {\n        return this._childCount;\n    }\n\n    public addChild<T extends DisplayObject[]>(...children: T): T[0]\n    {\n        // if there is only one argument we can bypass looping through the them\n        if (children.length > 1)\n        {\n            // loop through the array and add all children\n            for (let i = 0; i < children.length; i++)\n            {\n                // eslint-disable-next-line prefer-rest-params\n                this.addChild(children[i]);\n            }\n        }\n        else\n        {\n            const child = children[0] as LinkedListChild;\n            // if the child has a parent then lets remove it as PixiJS objects can only exist in one place\n\n            if (child.parent)\n            {\n                child.parent.removeChild(child);\n            }\n\n            child.parent = this;\n            this.sortDirty = true;\n\n            // ensure child transform will be recalculated\n            child.transform._parentID = -1;\n\n            // add to list if we have a list\n            if (this._lastChild)\n            {\n                this._lastChild.nextChild = child;\n                child.prevChild = this._lastChild;\n                this._lastChild = child;\n            }\n            // otherwise initialize the list\n            else\n            {\n                this._firstChild = this._lastChild = child;\n            }\n\n            // update child count\n            ++this._childCount;\n\n            // ensure bounds will be recalculated\n            this._boundsID++;\n\n            // TODO - lets either do all callbacks or all events.. not both!\n            this.onChildrenChange();\n            this.emit('childAdded', child, this, this._childCount);\n            child.emit('added', this);\n        }\n\n        return children[0];\n    }\n\n    public addChildAt<T extends DisplayObject>(child: T, index: number): T\n    {\n        if (index < 0 || index > this._childCount)\n        {\n            throw new Error(`addChildAt: The index ${index} supplied is out of bounds ${this._childCount}`);\n        }\n\n        if (child.parent)\n        {\n            child.parent.removeChild(child);\n        }\n\n        child.parent = this;\n        this.sortDirty = true;\n\n        // ensure child transform will be recalculated\n        child.transform._parentID = -1;\n\n        const c = (child as any) as LinkedListChild;\n\n        // if no children, do basic initialization\n        if (!this._firstChild)\n        {\n            this._firstChild = this._lastChild = c;\n        }\n        // add at beginning (back)\n        else if (index === 0)\n        {\n            this._firstChild.prevChild = c;\n            c.nextChild = this._firstChild;\n            this._firstChild = c;\n        }\n        // add at end (front)\n        else if (index === this._childCount)\n        {\n            this._lastChild.nextChild = c;\n            c.prevChild = this._lastChild;\n            this._lastChild = c;\n        }\n        // otherwise we have to start counting through the children to find the right one\n        // - SLOW, only provided to fully support the possibility of use\n        else\n        {\n            let i = 0;\n            let target = this._firstChild;\n\n            while (i < index)\n            {\n                target = target.nextChild;\n                ++i;\n            }\n            // insert before the target that we found at the specified index\n            target.prevChild.nextChild = c;\n            c.prevChild = target.prevChild;\n            c.nextChild = target;\n            target.prevChild = c;\n        }\n\n        // update child count\n        ++this._childCount;\n\n        // ensure bounds will be recalculated\n        this._boundsID++;\n\n        // TODO - lets either do all callbacks or all events.. not both!\n        this.onChildrenChange(index);\n        child.emit('added', this);\n        this.emit('childAdded', child, this, index);\n\n        return child;\n    }\n\n    /**\n     * Adds a child to the container to be rendered below another child.\n     *\n     * @param child The child to add\n     * @param relative - The current child to add the new child relative to.\n     * @return The child that was added.\n     */\n    public addChildBelow<T extends DisplayObject>(child: T, relative: DisplayObject): T\n    {\n        if (relative.parent !== this)\n        {\n            throw new Error(`addChildBelow: The relative target must be a child of this parent`);\n        }\n\n        if (child.parent)\n        {\n            child.parent.removeChild(child);\n        }\n\n        child.parent = this;\n        this.sortDirty = true;\n\n        // ensure child transform will be recalculated\n        child.transform._parentID = -1;\n\n        // insert before the target that we were given\n        (relative as LinkedListChild).prevChild.nextChild = (child as any as LinkedListChild);\n        (child as any as LinkedListChild).prevChild = (relative as LinkedListChild).prevChild;\n        (child as any as LinkedListChild).nextChild = (relative as LinkedListChild);\n        (relative as LinkedListChild).prevChild = (child as any as LinkedListChild);\n        if (this._firstChild === relative)\n        {\n            this._firstChild = (child as any as LinkedListChild);\n        }\n\n        // update child count\n        ++this._childCount;\n\n        // ensure bounds will be recalculated\n        this._boundsID++;\n\n        // TODO - lets either do all callbacks or all events.. not both!\n        this.onChildrenChange();\n        this.emit('childAdded', child, this, this._childCount);\n        child.emit('added', this);\n\n        return child;\n    }\n\n    /**\n     * Adds a child to the container to be rendered above another child.\n     *\n     * @param child The child to add\n     * @param relative - The current child to add the new child relative to.\n     * @return The child that was added.\n     */\n    public addChildAbove<T extends DisplayObject>(child: T, relative: DisplayObject): T\n    {\n        if (relative.parent !== this)\n        {\n            throw new Error(`addChildBelow: The relative target must be a child of this parent`);\n        }\n\n        if (child.parent)\n        {\n            child.parent.removeChild(child);\n        }\n\n        child.parent = this;\n        this.sortDirty = true;\n\n        // ensure child transform will be recalculated\n        child.transform._parentID = -1;\n\n        // insert after the target that we were given\n        (relative as LinkedListChild).nextChild.prevChild = (child as any as LinkedListChild);\n        (child as any as LinkedListChild).nextChild = (relative as LinkedListChild).nextChild;\n        (child as any as LinkedListChild).prevChild = (relative as LinkedListChild);\n        (relative as LinkedListChild).nextChild = (child as any as LinkedListChild);\n        if (this._lastChild === relative)\n        {\n            this._lastChild = (child as any as LinkedListChild);\n        }\n\n        // update child count\n        ++this._childCount;\n\n        // ensure bounds will be recalculated\n        this._boundsID++;\n\n        // TODO - lets either do all callbacks or all events.. not both!\n        this.onChildrenChange();\n        this.emit('childAdded', child, this, this._childCount);\n        child.emit('added', this);\n\n        return child;\n    }\n\n    public swapChildren(child: DisplayObject, child2: DisplayObject): void\n    {\n        if (child === child2 || child.parent !== this || child2.parent !== this)\n        {\n            return;\n        }\n\n        const { prevChild, nextChild } = (child as LinkedListChild);\n\n        (child as LinkedListChild).prevChild = (child2 as LinkedListChild).prevChild;\n        (child as LinkedListChild).nextChild = (child2 as LinkedListChild).nextChild;\n        (child2 as LinkedListChild).prevChild = prevChild;\n        (child2 as LinkedListChild).nextChild = nextChild;\n\n        if (this._firstChild === child)\n        {\n            this._firstChild = child2 as LinkedListChild;\n        }\n        else if (this._firstChild === child2)\n        {\n            this._firstChild = child as LinkedListChild;\n        }\n        if (this._lastChild === child)\n        {\n            this._lastChild = child2 as LinkedListChild;\n        }\n        else if (this._lastChild === child2)\n        {\n            this._lastChild = child as LinkedListChild;\n        }\n\n        this.onChildrenChange();\n    }\n\n    public getChildIndex(child: DisplayObject): number\n    {\n        let index = 0;\n        let test = this._firstChild;\n\n        while (test)\n        {\n            if (test === child)\n            {\n                break;\n            }\n            test = test.nextChild;\n            ++index;\n        }\n        if (!test)\n        {\n            throw new Error('The supplied DisplayObject must be a child of the caller');\n        }\n\n        return index;\n    }\n\n    setChildIndex(child: DisplayObject, index: number): void\n    {\n        if (index < 0 || index >= this._childCount)\n        {\n            throw new Error(`The index ${index} supplied is out of bounds ${this._childCount}`);\n        }\n        if (child.parent !== this)\n        {\n            throw new Error('The supplied DisplayObject must be a child of the caller');\n        }\n\n        // remove child\n        if ((child as LinkedListChild).nextChild)\n        {\n            (child as LinkedListChild).nextChild.prevChild = (child as LinkedListChild).prevChild;\n        }\n        if ((child as LinkedListChild).prevChild)\n        {\n            (child as LinkedListChild).prevChild.nextChild = (child as LinkedListChild).nextChild;\n        }\n        if (this._firstChild === (child as LinkedListChild))\n        {\n            this._firstChild = (child as LinkedListChild).nextChild;\n        }\n        if (this._lastChild === (child as LinkedListChild))\n        {\n            this._lastChild = (child as LinkedListChild).prevChild;\n        }\n        (child as LinkedListChild).nextChild = null;\n        (child as LinkedListChild).prevChild = null;\n\n        // do addChildAt\n        if (!this._firstChild)\n        {\n            this._firstChild = this._lastChild = (child as LinkedListChild);\n        }\n        else if (index === 0)\n        {\n            this._firstChild.prevChild = (child as LinkedListChild);\n            (child as LinkedListChild).nextChild = this._firstChild;\n            this._firstChild = (child as LinkedListChild);\n        }\n        else if (index === this._childCount)\n        {\n            this._lastChild.nextChild = (child as LinkedListChild);\n            (child as LinkedListChild).prevChild = this._lastChild;\n            this._lastChild = (child as LinkedListChild);\n        }\n        else\n        {\n            let i = 0;\n            let target = this._firstChild;\n\n            while (i < index)\n            {\n                target = target.nextChild;\n                ++i;\n            }\n            target.prevChild.nextChild = (child as LinkedListChild);\n            (child as LinkedListChild).prevChild = target.prevChild;\n            (child as LinkedListChild).nextChild = target;\n            target.prevChild = (child as LinkedListChild);\n        }\n\n        this.onChildrenChange(index);\n    }\n\n    public removeChild<T extends DisplayObject[]>(...children: T): T[0]\n    {\n        // if there is only one argument we can bypass looping through the them\n        if (children.length > 1)\n        {\n            // loop through the arguments property and remove all children\n            for (let i = 0; i < children.length; i++)\n            {\n                this.removeChild(children[i]);\n            }\n        }\n        else\n        {\n            const child = children[0] as LinkedListChild;\n\n            // bail if not actually our child\n            if (child.parent !== this) return null;\n\n            child.parent = null;\n            // ensure child transform will be recalculated\n            child.transform._parentID = -1;\n\n            // swap out child references\n            if (child.nextChild)\n            {\n                child.nextChild.prevChild = child.prevChild;\n            }\n            if (child.prevChild)\n            {\n                child.prevChild.nextChild = child.nextChild;\n            }\n            if (this._firstChild === child)\n            {\n                this._firstChild = child.nextChild;\n            }\n            if (this._lastChild === child)\n            {\n                this._lastChild = child.prevChild;\n            }\n            // clear sibling references\n            child.nextChild = null;\n            child.prevChild = null;\n\n            // update child count\n            --this._childCount;\n\n            // ensure bounds will be recalculated\n            this._boundsID++;\n\n            // TODO - lets either do all callbacks or all events.. not both!\n            this.onChildrenChange();\n            child.emit('removed', this);\n            this.emit('childRemoved', child, this);\n        }\n\n        return children[0];\n    }\n\n    public getChildAt(index: number): DisplayObject\n    {\n        if (index < 0 || index >= this._childCount)\n        {\n            throw new Error(`getChildAt: Index (${index}) does not exist.`);\n        }\n\n        if (index === 0)\n        {\n            return this._firstChild;\n        }\n        // add at end (front)\n        else if (index === this._childCount)\n        {\n            return this._lastChild;\n        }\n        // otherwise we have to start counting through the children to find the right one\n        // - SLOW, only provided to fully support the possibility of use\n        let i = 0;\n        let target = this._firstChild;\n\n        while (i < index)\n        {\n            target = target.nextChild;\n            ++i;\n        }\n\n        return target;\n    }\n\n    public removeChildAt(index: number): DisplayObject\n    {\n        const child = this.getChildAt(index) as LinkedListChild;\n\n        // ensure child transform will be recalculated..\n        child.parent = null;\n        child.transform._parentID = -1;\n        // swap out child references\n        if (child.nextChild)\n        {\n            child.nextChild.prevChild = child.prevChild;\n        }\n        if (child.prevChild)\n        {\n            child.prevChild.nextChild = child.nextChild;\n        }\n        if (this._firstChild === child)\n        {\n            this._firstChild = child.nextChild;\n        }\n        if (this._lastChild === child)\n        {\n            this._lastChild = child.prevChild;\n        }\n        // clear sibling references\n        child.nextChild = null;\n        child.prevChild = null;\n\n        // update child count\n        --this._childCount;\n\n        // ensure bounds will be recalculated\n        this._boundsID++;\n\n        // TODO - lets either do all callbacks or all events.. not both!\n        this.onChildrenChange(index);\n        child.emit('removed', this);\n        this.emit('childRemoved', child, this, index);\n\n        return child;\n    }\n\n    public removeChildren(beginIndex = 0, endIndex = this._childCount): DisplayObject[]\n    {\n        const begin = beginIndex;\n        const end = endIndex;\n        const range = end - begin;\n\n        if (range > 0 && range <= end)\n        {\n            const removed: LinkedListChild[] = [];\n            let child = this._firstChild;\n\n            for (let i = 0; i <= end && child; ++i, child = child.nextChild)\n            {\n                if (i >= begin)\n                {\n                    removed.push(child);\n                }\n            }\n\n            // child before removed section\n            const prevChild = removed[0].prevChild;\n            // child after removed section\n            const nextChild = removed[removed.length - 1].nextChild;\n\n            if (!nextChild)\n            {\n                // if we removed the last child, then the new last child is the one before\n                // the removed section\n                this._lastChild = prevChild;\n            }\n            else\n            {\n                // otherwise, stitch the child before the section to the child after\n                nextChild.prevChild = prevChild;\n            }\n            if (!prevChild)\n            {\n                // if we removed the first child, then the new first child is the one after\n                // the removed section\n                this._firstChild = nextChild;\n            }\n            else\n            {\n                // otherwise stich the child after the section to the one before\n                prevChild.nextChild = nextChild;\n            }\n\n            for (let i = 0; i < removed.length; ++i)\n            {\n                // clear parenting and sibling references for all removed children\n                removed[i].parent = null;\n                if (removed[i].transform)\n                {\n                    removed[i].transform._parentID = -1;\n                }\n                removed[i].nextChild = null;\n                removed[i].prevChild = null;\n            }\n\n            this._boundsID++;\n\n            this.onChildrenChange(beginIndex);\n\n            for (let i = 0; i < removed.length; ++i)\n            {\n                removed[i].emit('removed', this);\n                this.emit('childRemoved', removed[i], this, i);\n            }\n\n            return removed;\n        }\n        else if (range === 0 && this._childCount === 0)\n        {\n            return [];\n        }\n\n        throw new RangeError('removeChildren: numeric values are outside the acceptable range.');\n    }\n\n    /**\n     * Updates the transform on all children of this container for rendering.\n     * Copied from and overrides PixiJS v5 method (v4 method is identical)\n     */\n    updateTransform(): void\n    {\n        this._boundsID++;\n\n        this.transform.updateTransform(this.parent.transform);\n\n        // TODO: check render flags, how to process stuff here\n        this.worldAlpha = this.alpha * this.parent.worldAlpha;\n\n        let child;\n        let next;\n\n        for (child = this._firstChild; child; child = next)\n        {\n            next = child.nextChild;\n\n            if (child.visible)\n            {\n                child.updateTransform();\n            }\n        }\n    }\n\n    /**\n     * Recalculates the bounds of the container.\n     * Copied from and overrides PixiJS v5 method (v4 method is identical)\n     */\n    calculateBounds(): void\n    {\n        this._bounds.clear();\n\n        this._calculateBounds();\n\n        let child;\n        let next;\n\n        for (child = this._firstChild; child; child = next)\n        {\n            next = child.nextChild;\n\n            if (!child.visible || !child.renderable)\n            {\n                continue;\n            }\n\n            child.calculateBounds();\n\n            // TODO: filter+mask, need to mask both somehow\n            if (child._mask)\n            {\n                const maskObject = ((child._mask as MaskData).maskObject || child._mask) as Container;\n\n                maskObject.calculateBounds();\n                this._bounds.addBoundsMask(child._bounds, maskObject._bounds);\n            }\n            else if (child.filterArea)\n            {\n                this._bounds.addBoundsArea(child._bounds, child.filterArea);\n            }\n            else\n            {\n                this._bounds.addBounds(child._bounds);\n            }\n        }\n\n        this._bounds.updateID = this._boundsID;\n    }\n\n    /**\n     * Retrieves the local bounds of the displayObject as a rectangle object. Copied from and overrides PixiJS v5 method\n     */\n    public getLocalBounds(rect?: Rectangle, skipChildrenUpdate = false): Rectangle\n    {\n        // skip Container's getLocalBounds, go directly to DisplayObject\n        const result = DisplayObject.prototype.getLocalBounds.call(this, rect);\n\n        if (!skipChildrenUpdate)\n        {\n            let child;\n            let next;\n\n            for (child = this._firstChild; child; child = next)\n            {\n                next = child.nextChild;\n\n                if (child.visible)\n                {\n                    child.updateTransform();\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Renders the object using the WebGL renderer. Copied from and overrides PixiJS v5 method\n     */\n    render(renderer: Renderer): void\n    {\n        // if the object is not visible or the alpha is 0 then no need to render this element\n        if (!this.visible || this.worldAlpha <= 0 || !this.renderable)\n        {\n            return;\n        }\n\n        // do a quick check to see if this element has a mask or a filter.\n        if (this._mask || (this.filters && this.filters.length))\n        {\n            this.renderAdvanced(renderer);\n        }\n        else\n        {\n            this._render(renderer);\n\n            let child;\n            let next;\n\n            // simple render children!\n            for (child = this._firstChild; child; child = next)\n            {\n                next = child.nextChild;\n                child.render(renderer);\n            }\n        }\n    }\n\n    /**\n     * Render the object using the WebGL renderer and advanced features. Copied from and overrides PixiJS v5 method\n     */\n    protected renderAdvanced(renderer: Renderer): void\n    {\n        renderer.batch.flush();\n\n        const filters = this.filters;\n        const mask = this._mask;\n\n        // _enabledFilters note: As of development, _enabledFilters is not documented in pixi.js\n        // types but is in code of current release (5.2.4).\n\n        // push filter first as we need to ensure the stencil buffer is correct for any masking\n        if (filters)\n        {\n            if (!this._enabledFilters)\n            {\n                this._enabledFilters = [];\n            }\n\n            this._enabledFilters.length = 0;\n\n            for (let i = 0; i < filters.length; i++)\n            {\n                if (filters[i].enabled)\n                {\n                    this._enabledFilters.push(filters[i]);\n                }\n            }\n\n            if (this._enabledFilters.length)\n            {\n                renderer.filter.push(this, this._enabledFilters);\n            }\n        }\n\n        if (mask)\n        {\n            renderer.mask.push(this, this._mask);\n        }\n\n        // add this object to the batch, only rendered if it has a texture.\n        this._render(renderer);\n\n        let child;\n        let next;\n\n        // now loop through the children and make sure they get rendered\n        for (child = this._firstChild; child; child = next)\n        {\n            next = child.nextChild;\n            child.render(renderer);\n        }\n\n        renderer.batch.flush();\n\n        if (mask)\n        {\n            renderer.mask.pop(this);\n        }\n\n        if (filters && this._enabledFilters && this._enabledFilters.length)\n        {\n            renderer.filter.pop();\n        }\n    }\n\n    /**\n     * Renders the object using the Canvas renderer. Copied from and overrides PixiJS Canvas mixin in V5 and V6.\n     */\n    renderCanvas(renderer: any): void\n    {\n        // if not visible or the alpha is 0 then no need to render this\n        if (!this.visible || this.worldAlpha <= 0 || !this.renderable)\n        {\n            return;\n        }\n\n        if (this._mask)\n        {\n            renderer.maskManager.pushMask(this._mask);\n        }\n\n        (this as any)._renderCanvas(renderer);\n\n        let child;\n        let next;\n\n        for (child = this._firstChild; child; child = next)\n        {\n            next = child.nextChild;\n            (child as any).renderCanvas(renderer);\n        }\n\n        if (this._mask)\n        {\n            renderer.maskManager.popMask(renderer);\n        }\n    }\n}\n","/* eslint-disable no-lonely-if */\nimport { EaseSegment, SimpleEase } from './ParticleUtils';\nimport { ValueList } from './PropertyNode';\nimport { IPointData } from '@pixi/math';\n\nexport interface EmitterConfigV3\n{\n    lifetime: RandNumber;\n    ease?: SimpleEase | EaseSegment[];\n    particlesPerWave?: number;\n    frequency: number;\n    spawnChance?: number;\n    emitterLifetime?: number;\n    maxParticles?: number;\n    addAtBack?: boolean;\n    pos: { x: number; y: number };\n    emit?: boolean;\n    autoUpdate?: boolean;\n\n    behaviors: {\n        type: string;\n        config: any;\n    }[];\n}\n\nexport interface RandNumber\n{\n    max: number;\n    min: number;\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function upgradeConfig(config: EmitterConfigV2|EmitterConfigV1, art: any): EmitterConfigV3\n{\n    // just ensure we aren't given any V3 config data\n    if ('behaviors' in config)\n    {\n        return config;\n    }\n\n    const out: EmitterConfigV3 = {\n        lifetime: config.lifetime,\n        ease: config.ease,\n        particlesPerWave: config.particlesPerWave,\n        frequency: config.frequency,\n        spawnChance: config.spawnChance,\n        emitterLifetime: config.emitterLifetime,\n        maxParticles: config.maxParticles,\n        addAtBack: config.addAtBack,\n        pos: config.pos,\n        emit: config.emit,\n        autoUpdate: config.autoUpdate,\n        behaviors: [],\n    };\n\n    // set up the alpha\n    if (config.alpha)\n    {\n        if ('start' in config.alpha)\n        {\n            if (config.alpha.start === config.alpha.end)\n            {\n                if (config.alpha.start !== 1)\n                {\n                    out.behaviors.push({\n                        type: 'alphaStatic',\n                        config: { alpha: config.alpha.start },\n                    });\n                }\n            }\n            else\n            {\n                const list: ValueList<number> = {\n                    list: [\n                        { time: 0, value: config.alpha.start },\n                        { time: 1, value: config.alpha.end },\n                    ],\n                };\n\n                out.behaviors.push({\n                    type: 'alpha',\n                    config: { alpha: list },\n                });\n            }\n        }\n        else if (config.alpha.list.length === 1)\n        {\n            if (config.alpha.list[0].value !== 1)\n            {\n                out.behaviors.push({\n                    type: 'alphaStatic',\n                    config: { alpha: config.alpha.list[0].value },\n                });\n            }\n        }\n        else\n        {\n            out.behaviors.push({\n                type: 'alpha',\n                config: { alpha: config.alpha },\n            });\n        }\n    }\n\n    // acceleration movement\n    if (config.acceleration && (config.acceleration.x || config.acceleration.y))\n    {\n        let minStart: number;\n        let maxStart: number;\n\n        if ('start' in config.speed)\n        {\n            minStart = config.speed.start * (config.speed.minimumSpeedMultiplier ?? 1);\n            maxStart = config.speed.start;\n        }\n        else\n        {\n            minStart = config.speed.list[0].value * ((config as EmitterConfigV2).minimumSpeedMultiplier ?? 1);\n            maxStart = config.speed.list[0].value;\n        }\n\n        out.behaviors.push({\n            type: 'moveAcceleration',\n            config: {\n                accel: config.acceleration,\n                minStart,\n                maxStart,\n                rotate: !config.noRotation,\n                maxSpeed: config.maxSpeed,\n            },\n        });\n    }\n    // path movement\n    else if (config.extraData?.path)\n    {\n        let list: ValueList<number>;\n        let mult: number;\n\n        if ('start' in config.speed)\n        {\n            mult = config.speed.minimumSpeedMultiplier ?? 1;\n            if (config.speed.start === config.speed.end)\n            {\n                list = {\n                    list: [{ time: 0, value: config.speed.start }],\n                };\n            }\n            else\n            {\n                list = {\n                    list: [\n                        { time: 0, value: config.speed.start },\n                        { time: 1, value: config.speed.end },\n                    ],\n                };\n            }\n        }\n        else\n        {\n            list = config.speed;\n            mult = ((config as EmitterConfigV2).minimumSpeedMultiplier ?? 1);\n        }\n\n        out.behaviors.push({\n            type: 'movePath',\n            config: {\n                path: config.extraData.path,\n                speed: list,\n                minMult: mult,\n            },\n        });\n    }\n    // normal speed movement\n    else\n    {\n        if ('start' in config.speed)\n        {\n            if (config.speed.start === config.speed.end)\n            {\n                out.behaviors.push({\n                    type: 'moveSpeedStatic',\n                    config: {\n                        min: config.speed.start * (config.speed.minimumSpeedMultiplier ?? 1),\n                        max: config.speed.start,\n                    },\n                });\n            }\n            else\n            {\n                const list: ValueList<number> = {\n                    list: [\n                        { time: 0, value: config.speed.start },\n                        { time: 1, value: config.speed.end },\n                    ],\n                };\n\n                out.behaviors.push({\n                    type: 'moveSpeed',\n                    config: { speed: list, minMult: config.speed.minimumSpeedMultiplier },\n                });\n            }\n        }\n        else if (config.speed.list.length === 1)\n        {\n            out.behaviors.push({\n                type: 'moveSpeedStatic',\n                config: {\n                    min: config.speed.list[0].value * ((config as EmitterConfigV2).minimumSpeedMultiplier ?? 1),\n                    max: config.speed.list[0].value,\n                },\n            });\n        }\n        else\n        {\n            out.behaviors.push({\n                type: 'moveSpeed',\n                config: { speed: config.speed, minMult: ((config as EmitterConfigV2).minimumSpeedMultiplier ?? 1) },\n            });\n        }\n    }\n\n    // scale\n    if (config.scale)\n    {\n        if ('start' in config.scale)\n        {\n            const mult = config.scale.minimumScaleMultiplier ?? 1;\n\n            if (config.scale.start === config.scale.end)\n            {\n                out.behaviors.push({\n                    type: 'scaleStatic',\n                    config: {\n                        min: config.scale.start * mult,\n                        max: config.scale.start,\n                    },\n                });\n            }\n            else\n            {\n                const list: ValueList<number> = {\n                    list: [\n                        { time: 0, value: config.scale.start },\n                        { time: 1, value: config.scale.end },\n                    ],\n                };\n\n                out.behaviors.push({\n                    type: 'scale',\n                    config: { scale: list, minMult: mult },\n                });\n            }\n        }\n        else if (config.scale.list.length === 1)\n        {\n            const mult = (config as EmitterConfigV2).minimumScaleMultiplier ?? 1;\n            const scale = config.scale.list[0].value;\n\n            out.behaviors.push({\n                type: 'scaleStatic',\n                config: { min: scale * mult, max: scale },\n            });\n        }\n        else\n        {\n            out.behaviors.push({\n                type: 'scale',\n                config: { scale: config.scale, minMult: (config as EmitterConfigV2).minimumScaleMultiplier ?? 1 },\n            });\n        }\n    }\n\n    // color\n    if (config.color)\n    {\n        if ('start' in config.color)\n        {\n            if (config.color.start === config.color.end)\n            {\n                if (config.color.start !== 'ffffff')\n                {\n                    out.behaviors.push({\n                        type: 'colorStatic',\n                        config: { color: config.color.start },\n                    });\n                }\n            }\n            else\n            {\n                const list: ValueList<string> = {\n                    list: [\n                        { time: 0, value: config.color.start },\n                        { time: 1, value: config.color.end },\n                    ],\n                };\n\n                out.behaviors.push({\n                    type: 'color',\n                    config: { color: list },\n                });\n            }\n        }\n        else if (config.color.list.length === 1)\n        {\n            if (config.color.list[0].value !== 'ffffff')\n            {\n                out.behaviors.push({\n                    type: 'colorStatic',\n                    config: { color: config.color.list[0].value },\n                });\n            }\n        }\n        else\n        {\n            out.behaviors.push({\n                type: 'color',\n                config: { color: config.color },\n            });\n        }\n    }\n\n    // rotation\n    if (config.rotationAcceleration || config.rotationSpeed?.min || config.rotationSpeed.max)\n    {\n        out.behaviors.push({\n            type: 'rotation',\n            config: {\n                accel: config.rotationAcceleration || 0,\n                minSpeed: config.rotationSpeed?.min || 0,\n                maxSpeed: config.rotationSpeed?.max || 0,\n                minStart: config.startRotation?.min || 0,\n                maxStart: config.startRotation?.max || 0,\n            },\n        });\n    }\n    else if (config.startRotation?.min || config.startRotation?.max)\n    {\n        out.behaviors.push({\n            type: 'rotationStatic',\n            config: {\n                min: config.startRotation?.min || 0,\n                max: config.startRotation?.max || 0,\n            },\n        });\n    }\n    if (config.noRotation)\n    {\n        out.behaviors.push({\n            type: 'noRotation',\n            config: {},\n        });\n    }\n\n    // blend mode\n    if (config.blendMode && config.blendMode !== 'normal')\n    {\n        out.behaviors.push({\n            type: 'blendMode',\n            config: {\n                blendMode: config.blendMode,\n            },\n        });\n    }\n\n    // animated\n    if (Array.isArray(art) && typeof art[0] !== 'string' && 'framerate' in art[0])\n    {\n        for (let i = 0; i < art.length; ++i)\n        {\n            if (art[i].framerate === 'matchLife')\n            {\n                art[i].framerate = -1;\n            }\n        }\n        out.behaviors.push({\n            type: 'animatedRandom',\n            config: {\n                anims: art,\n            },\n        });\n    }\n    else if (typeof art !== 'string' && 'framerate' in art)\n    {\n        if (art.framerate === 'matchLife')\n        {\n            art.framerate = -1;\n        }\n        out.behaviors.push({\n            type: 'animatedSingle',\n            config: {\n                anim: art,\n            },\n        });\n    }\n    // ordered art\n    else if (config.orderedArt && Array.isArray(art))\n    {\n        out.behaviors.push({\n            type: 'textureOrdered',\n            config: {\n                textures: art,\n            },\n        });\n    }\n    // random texture\n    else if (Array.isArray(art))\n    {\n        out.behaviors.push({\n            type: 'textureRandom',\n            config: {\n                textures: art,\n            },\n        });\n    }\n    // single texture\n    else\n    {\n        out.behaviors.push({\n            type: 'textureSingle',\n            config: {\n                texture: art,\n            },\n        });\n    }\n\n    // spawn burst\n    if (config.spawnType === 'burst')\n    {\n        out.behaviors.push({\n            type: 'spawnBurst',\n            config: {\n                start: config.angleStart || 0,\n                spacing: config.particleSpacing,\n                // older formats bursted from a single point\n                distance: 0,\n            },\n        });\n    }\n    // spawn point\n    else if (config.spawnType === 'point')\n    {\n        out.behaviors.push({\n            type: 'spawnPoint',\n            config: {},\n        });\n    }\n    // spawn shape\n    else\n    {\n        let shape: any;\n\n        if (config.spawnType === 'ring')\n        {\n            shape = {\n                type: 'torus',\n                data: {\n                    x: config.spawnCircle.x,\n                    y: config.spawnCircle.y,\n                    radius: config.spawnCircle.r,\n                    innerRadius: config.spawnCircle.minR,\n                    affectRotation: true,\n                },\n            };\n        }\n        else if (config.spawnType === 'circle')\n        {\n            shape = {\n                type: 'torus',\n                data: {\n                    x: config.spawnCircle.x,\n                    y: config.spawnCircle.y,\n                    radius: config.spawnCircle.r,\n                    innerRadius: 0,\n                    affectRotation: false,\n                },\n            };\n        }\n        else if (config.spawnType === 'rect')\n        {\n            shape = {\n                type: 'rect',\n                data: config.spawnRect,\n            };\n        }\n        else if (config.spawnType === 'polygonalChain')\n        {\n            shape = {\n                type: 'polygonalChain',\n                data: config.spawnPolygon,\n            };\n        }\n        out.behaviors.push({\n            type: 'spawnShape',\n            config: shape,\n        });\n    }\n\n    return out;\n}\n\nexport interface EmitterConfigV2 {\n    alpha?: ValueList<number>;\n    speed?: ValueList<number>;\n    minimumSpeedMultiplier?: number;\n    maxSpeed?: number;\n    acceleration?: {x: number; y: number};\n    scale?: ValueList<number>;\n    minimumScaleMultiplier?: number;\n    color?: ValueList<string>;\n    startRotation?: RandNumber;\n    noRotation?: boolean;\n    rotationSpeed?: RandNumber;\n    rotationAcceleration?: number;\n    lifetime: RandNumber;\n    blendMode?: string;\n    ease?: SimpleEase | EaseSegment[];\n    extraData?: any;\n    particlesPerWave?: number;\n    /**\n     * Really \"rect\"|\"circle\"|\"ring\"|\"burst\"|\"point\"|\"polygonalChain\", but that\n     * tends to be too strict for random object creation.\n     */\n    spawnType?: string;\n    spawnRect?: {x: number; y: number; w: number; h: number};\n    spawnCircle?: {x: number; y: number; r: number; minR?: number};\n    particleSpacing?: number;\n    angleStart?: number;\n    spawnPolygon?: IPointData[] | IPointData[][];\n    frequency: number;\n    spawnChance?: number;\n    emitterLifetime?: number;\n    maxParticles?: number;\n    addAtBack?: boolean;\n    pos: {x: number; y: number};\n    emit?: boolean;\n    autoUpdate?: boolean;\n    orderedArt?: boolean;\n}\n\nexport interface BasicTweenable<T> {\n    start: T;\n    end: T;\n}\n\nexport interface EmitterConfigV1 {\n    alpha?: BasicTweenable<number>;\n    speed?: BasicTweenable<number> & {minimumSpeedMultiplier?: number};\n    maxSpeed?: number;\n    acceleration?: {x: number; y: number};\n    scale?: BasicTweenable<number> & {minimumScaleMultiplier?: number};\n    color?: BasicTweenable<string>;\n    startRotation?: RandNumber;\n    noRotation?: boolean;\n    rotationSpeed?: RandNumber;\n    rotationAcceleration?: number;\n    lifetime: RandNumber;\n    blendMode?: string;\n    ease?: SimpleEase | EaseSegment[];\n    extraData?: any;\n    particlesPerWave?: number;\n    /**\n     * Really \"rect\"|\"circle\"|\"ring\"|\"burst\"|\"point\"|\"polygonalChain\", but that\n     * tends to be too strict for random object creation.\n     */\n    spawnType?: string;\n    spawnRect?: {x: number; y: number; w: number; h: number};\n    spawnCircle?: {x: number; y: number; r: number; minR?: number};\n    particleSpacing?: number;\n    angleStart?: number;\n    spawnPolygon?: IPointData[] | IPointData[][];\n    frequency: number;\n    spawnChance?: number;\n    emitterLifetime?: number;\n    maxParticles?: number;\n    addAtBack?: boolean;\n    pos: {x: number; y: number};\n    emit?: boolean;\n    autoUpdate?: boolean;\n    orderedArt?: boolean;\n}\n"]}