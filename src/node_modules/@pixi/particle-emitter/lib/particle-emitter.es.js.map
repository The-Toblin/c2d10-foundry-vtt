{"version":3,"file":"particle-emitter.es.js","sources":["../src/PropertyNode.ts","../src/ParticleUtils.ts","../src/Particle.ts","../src/behaviors/Behaviors.ts","../src/Emitter.ts","../src/behaviors/shapes/Rectangle.ts","../src/behaviors/shapes/Torus.ts","../src/behaviors/shapes/PolygonalChain.ts","../src/behaviors/AccelerationMovement.ts","../src/PropertyList.ts","../src/behaviors/Alpha.ts","../src/behaviors/AnimatedTexture.ts","../src/behaviors/BlendMode.ts","../src/behaviors/BurstSpawn.ts","../src/behaviors/Color.ts","../src/behaviors/OrderedTexture.ts","../src/behaviors/PathMovement.ts","../src/behaviors/PointSpawn.ts","../src/behaviors/RandomTexture.ts","../src/behaviors/Rotation.ts","../src/behaviors/Scale.ts","../src/behaviors/ShapeSpawn.ts","../src/behaviors/SingleTexture.ts","../src/behaviors/SpeedMovement.ts","../src/behaviors/index.ts","../src/EmitterConfig.ts","../src/LinkedListContainer.ts","../src/index.ts"],"sourcesContent":["import { generateEase, hexToRGB, EaseSegment, SimpleEase, Color } from './ParticleUtils';\nimport { BasicTweenable } from './EmitterConfig';\n\n/**\n * A single step of a ValueList.\n */\nexport interface ValueStep<T> {\n    /**\n     * The color or number to use at this step.\n     */\n    value: T;\n    /**\n     * The percentage time of the particle's lifespan that this step happens at.\n     * Values are between 0 and 1, inclusive.\n     */\n    time: number;\n}\n\n/**\n * Configuration for an interpolated or stepped list of numeric or color particle values.\n */\nexport interface ValueList<T> {\n    /**\n     * The ordered list of values.\n     */\n    list: ValueStep<T>[];\n    /**\n     * If the list is stepped. Stepped lists don't determine any in-between values, instead sticking with each value\n     * until its time runs out.\n     */\n    isStepped?: boolean;\n    /**\n     * Easing that should be applied to this list, in order to alter how quickly the steps progress.\n     */\n    ease?: SimpleEase|EaseSegment[];\n}\n/**\n * A single node in a PropertyList.\n */\nexport class PropertyNode<V>\n{\n    /**\n     * Value for the node.\n     */\n    public value: V;\n    /**\n     * Time value for the node. Between 0-1.\n     */\n    public time: number;\n    /**\n     * The next node in line.\n     */\n    public next: PropertyNode<V>;\n    /**\n     * If this is the first node in the list, controls if the entire list is stepped or not.\n     */\n    public isStepped: boolean;\n    public ease: SimpleEase;\n\n    /**\n     * @param value The value for this node\n     * @param time The time for this node, between 0-1\n     * @param [ease] Custom ease for this list. Only relevant for the first node.\n     */\n    constructor(value: V, time: number, ease?: SimpleEase|EaseSegment[])\n    {\n        this.value = value;\n        this.time = time;\n        this.next = null;\n        this.isStepped = false;\n        if (ease)\n        {\n            this.ease = typeof ease === 'function' ? ease : generateEase(ease);\n        }\n        else\n        {\n            this.ease = null;\n        }\n    }\n\n    /**\n     * Creates a list of property values from a data object {list, isStepped} with a list of objects in\n     * the form {value, time}. Alternatively, the data object can be in the deprecated form of\n     * {start, end}.\n     * @param data The data for the list.\n     * @param data.list The array of value and time objects.\n     * @param data.isStepped If the list is stepped rather than interpolated.\n     * @param data.ease Custom ease for this list.\n     * @return The first node in the list\n     */\n    // eslint-disable-next-line max-len\n    public static createList<T extends(string|number)>(data: ValueList<T>|BasicTweenable<T>): PropertyNode<T extends string ? Color : T>\n    {\n        if ('list' in data)\n        {\n            const array = data.list;\n            let node;\n            const { value, time } = array[0];\n\n            // eslint-disable-next-line max-len\n            const first = node = new PropertyNode(typeof value === 'string' ? hexToRGB(value) : value, time, data.ease);\n\n            // only set up subsequent nodes if there are a bunch or the 2nd one is different from the first\n            if (array.length > 2 || (array.length === 2 && array[1].value !== value))\n            {\n                for (let i = 1; i < array.length; ++i)\n                {\n                    const { value, time } = array[i];\n\n                    node.next = new PropertyNode(typeof value === 'string' ? hexToRGB(value) : value, time);\n                    node = node.next;\n                }\n            }\n            first.isStepped = !!data.isStepped;\n\n            return first as PropertyNode<T extends string ? Color : T>;\n        }\n\n        // Handle deprecated version here\n        const start = new PropertyNode(typeof data.start === 'string' ? hexToRGB(data.start) : data.start, 0);\n        // only set up a next value if it is different from the starting value\n\n        if (data.end !== data.start)\n        {\n            start.next = new PropertyNode(typeof data.end === 'string' ? hexToRGB(data.end) : data.end, 1);\n        }\n\n        return start as PropertyNode<T extends string ? Color : T>;\n    }\n}\n","import { Texture } from '@pixi/core';\nimport { IPointData } from '@pixi/math';\nimport { BLEND_MODES } from '@pixi/constants';\nimport { PropertyNode, ValueStep } from './PropertyNode';\n\n/**\n * The method used by behaviors to fetch textures. Defaults to Texture.from.\n */\n// get Texture.from(), only supports V5 and V6 with individual packages\n// eslint-disable-next-line prefer-const\nexport let GetTextureFromString:(d:string) => Texture = Texture.from;\n\n/**\n * A color value, split apart for interpolation.\n */\nexport interface Color {\n    r: number;\n    g: number;\n    b: number;\n    a?: number;\n}\n\nexport interface EaseSegment {\n    cp: number;\n    s: number;\n    e: number;\n}\n\n/**\n * The basic easing function used. Takes in a value between 0-1, and outputs another value between 0-1.\n * For example, a basic quadratic in ease would be `(time) => time * time`\n */\nexport type SimpleEase = (time: number) => number;\n\n/**\n * If errors and warnings should be logged within the library.\n */\nexport const verbose = false;\n\nexport const DEG_TO_RADS = Math.PI / 180;\n\n/**\n * Rotates a point by a given angle.\n * @param angle The angle to rotate by in radians\n * @param p The point to rotate around 0,0.\n */\nexport function rotatePoint(angle: number, p: IPointData): void\n{\n    if (!angle) return;\n\n    const s = Math.sin(angle);\n    const c = Math.cos(angle);\n    const xnew = (p.x * c) - (p.y * s);\n    const ynew = (p.x * s) + (p.y * c);\n\n    p.x = xnew;\n    p.y = ynew;\n}\n\n/**\n * Combines separate color components (0-255) into a single uint color.\n * @param r The red value of the color\n * @param g The green value of the color\n * @param b The blue value of the color\n * @return The color in the form of 0xRRGGBB\n */\nexport function combineRGBComponents(r: number, g: number, b: number/* , a*/): number\n{\n    return /* a << 24 |*/ (r << 16) | (g << 8) | b;\n}\n\n/**\n * Returns the length (or magnitude) of this point.\n * @param point The point to measure length\n * @return The length of this point.\n */\nexport function length(point: IPointData): number\n{\n    return Math.sqrt((point.x * point.x) + (point.y * point.y));\n}\n\n/**\n * Reduces the point to a length of 1.\n * @param point The point to normalize\n */\nexport function normalize(point: IPointData): void\n{\n    const oneOverLen = 1 / length(point);\n\n    point.x *= oneOverLen;\n    point.y *= oneOverLen;\n}\n\n/**\n * Multiplies the x and y values of this point by a value.\n * @param point The point to scaleBy\n * @param value The value to scale by.\n */\nexport function scaleBy(point: IPointData, value: number): void\n{\n    point.x *= value;\n    point.y *= value;\n}\n\n/**\n * Converts a hex string from \"#AARRGGBB\", \"#RRGGBB\", \"0xAARRGGBB\", \"0xRRGGBB\",\n * \"AARRGGBB\", or \"RRGGBB\" to an object of ints of 0-255, as\n * {r, g, b, (a)}.\n * @param color The input color string.\n * @param output An object to put the output in. If omitted, a new object is created.\n * @return The object with r, g, and b properties, possibly with an a property.\n */\nexport function hexToRGB(color: string, output?: Color): Color\n{\n    if (!output)\n    {\n        output = {} as Color;\n    }\n    if (color.charAt(0) === '#')\n    {\n        color = color.substr(1);\n    }\n    else if (color.indexOf('0x') === 0)\n    {\n        color = color.substr(2);\n    }\n    let alpha;\n\n    if (color.length === 8)\n    {\n        alpha = color.substr(0, 2);\n        color = color.substr(2);\n    }\n    output.r = parseInt(color.substr(0, 2), 16);// Red\n    output.g = parseInt(color.substr(2, 2), 16);// Green\n    output.b = parseInt(color.substr(4, 2), 16);// Blue\n    if (alpha)\n    {\n        output.a = parseInt(alpha, 16);\n    }\n\n    return output;\n}\n\n/**\n * Generates a custom ease function, based on the GreenSock custom ease, as demonstrated\n * by the related tool at http://www.greensock.com/customease/.\n * @param segments An array of segments, as created by\n * http://www.greensock.com/customease/.\n * @return A function that calculates the percentage of change at\n *                    a given point in time (0-1 inclusive).\n */\nexport function generateEase(segments: EaseSegment[]): SimpleEase\n{\n    const qty = segments.length;\n    const oneOverQty = 1 / qty;\n    /*\n        * Calculates the percentage of change at a given point in time (0-1 inclusive).\n        * @param {Number} time The time of the ease, 0-1 inclusive.\n        * @return {Number} The percentage of the change, 0-1 inclusive (unless your\n        *                  ease goes outside those bounds).\n        */\n\n    // eslint-disable-next-line func-names\n    return function (time: number): number\n    {\n        const i = (qty * time) | 0;// do a quick floor operation\n\n        const t = (time - (i * oneOverQty)) * qty;\n        const s = segments[i] || segments[qty - 1];\n\n        return (s.s + (t * ((2 * (1 - t) * (s.cp - s.s)) + (t * (s.e - s.s)))));\n    };\n}\n\n/**\n * Gets a blend mode, ensuring that it is valid.\n * @param name The name of the blend mode to get.\n * @return The blend mode as specified in the PIXI.BLEND_MODES enumeration.\n */\nexport function getBlendMode(name: string): number\n{\n    if (!name) return BLEND_MODES.NORMAL;\n    name = name.toUpperCase().replace(/ /g, '_');\n\n    return (BLEND_MODES as any)[name] || BLEND_MODES.NORMAL;\n}\n\n/**\n * Converts a list of {value, time} objects starting at time 0 and ending at time 1 into an evenly\n * spaced stepped list of PropertyNodes for color values. This is primarily to handle conversion of\n * linear gradients to fewer colors, allowing for some optimization for Canvas2d fallbacks.\n * @param list The list of data to convert.\n * @param [numSteps=10] The number of steps to use.\n * @return The blend mode as specified in the PIXI.blendModes enumeration.\n */\nexport function createSteppedGradient(list: ValueStep<string>[], numSteps = 10): PropertyNode<Color>\n{\n    if (typeof numSteps !== 'number' || numSteps <= 0)\n    {\n        numSteps = 10;\n    }\n    const first = new PropertyNode<Color>(hexToRGB(list[0].value), list[0].time);\n\n    first.isStepped = true;\n    let currentNode = first;\n    let current = list[0];\n    let nextIndex = 1;\n    let next = list[nextIndex];\n\n    for (let i = 1; i < numSteps; ++i)\n    {\n        let lerp = i / numSteps;\n        // ensure we are on the right segment, if multiple\n\n        while (lerp > next.time)\n        {\n            current = next;\n            next = list[++nextIndex];\n        }\n        // convert the lerp value to the segment range\n        lerp = (lerp - current.time) / (next.time - current.time);\n        const curVal = hexToRGB(current.value);\n        const nextVal = hexToRGB(next.value);\n        const output: Color = {\n            r: ((nextVal.r - curVal.r) * lerp) + curVal.r,\n            g: ((nextVal.g - curVal.g) * lerp) + curVal.g,\n            b: ((nextVal.b - curVal.b) * lerp) + curVal.b,\n        };\n\n        currentNode.next = new PropertyNode(output, i / numSteps);\n        currentNode = currentNode.next;\n    }\n\n    // we don't need to have a PropertyNode for time of 1, because in a stepped version at that point\n    // the particle has died of old age\n    return first;\n}\n","import { Emitter } from './Emitter';\nimport { LinkedListChild } from './LinkedListContainer';\nimport { Sprite } from '@pixi/sprite';\n\n/**\n * An individual particle image. You shouldn't have to deal with these.\n */\nexport class Particle extends Sprite implements LinkedListChild\n{\n    /**\n     * The emitter that controls this particle.\n     */\n    public emitter: Emitter;\n    /**\n     * The maximum lifetime of this particle, in seconds.\n     */\n    public maxLife: number;\n    /**\n     * The current age of the particle, in seconds.\n     */\n    public age: number;\n    /**\n     * The current age of the particle as a normalized value between 0 and 1.\n     */\n    public agePercent: number;\n    /**\n     * One divided by the max life of the particle, saved for slightly faster math.\n     */\n    public oneOverLife: number;\n    /**\n     * Reference to the next particle in the list.\n     */\n    public next: Particle;\n\n    /**\n     * Reference to the previous particle in the list.\n     */\n    public prev: Particle;\n\n    public prevChild: LinkedListChild;\n    public nextChild: LinkedListChild;\n\n    /**\n     * Static per-particle configuration for behaviors to use. Is not cleared when recycling.\n     */\n    public config: {[key: string]: any};\n\n    /**\n     * @param emitter The emitter that controls this particle.\n     */\n    constructor(emitter: Emitter)\n    {\n        // start off the sprite with a blank texture, since we are going to replace it\n        // later when the particle is initialized.\n        super();\n        // initialize LinkedListChild props so they are included in underlying JS class definition\n        this.prevChild = this.nextChild = null;\n\n        this.emitter = emitter;\n        this.config = {};\n        // particles should be centered\n        this.anchor.x = this.anchor.y = 0.5;\n        this.maxLife = 0;\n        this.age = 0;\n        this.agePercent = 0;\n        this.oneOverLife = 0;\n        this.next = null;\n        this.prev = null;\n\n        // save often used functions on the instance instead of the prototype for better speed\n        this.init = this.init;\n        this.kill = this.kill;\n    }\n\n    /**\n     * Initializes the particle for use, based on the properties that have to\n     * have been set already on the particle.\n     */\n    public init(maxLife: number): void\n    {\n        this.maxLife = maxLife;\n        // reset the age\n        this.age = this.agePercent = 0;\n        // reset the sprite props\n        this.rotation = 0;\n        this.position.x = this.position.y = 0;\n        this.scale.x = this.scale.y = 1;\n        this.tint = 0xffffff;\n        this.alpha = 1;\n        // save our lerp helper\n        this.oneOverLife = 1 / this.maxLife;\n\n        // ensure visibility\n        this.visible = true;\n    }\n\n    /**\n     * Kills the particle, removing it from the display list\n     * and telling the emitter to recycle it.\n     */\n    public kill(): void\n    {\n        this.emitter.recycle(this);\n    }\n\n    /**\n     * Destroys the particle, removing references and preventing future use.\n     */\n    public destroy(): void\n    {\n        if (this.parent)\n        {\n            this.parent.removeChild(this);\n        }\n        this.emitter = this.next = this.prev = null;\n        super.destroy();\n    }\n}\n","import { Particle } from '../Particle';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * All behaviors instances must implement this interface, and the class must match the\n * {@link IEmitterBehaviorClass} interface. All behaviors must have an order property and\n * `initParticles` method. Implementing the `updateParticle` or `recycleParticle` methods is optional.\n */\nexport interface IEmitterBehavior\n{\n    /**\n     * Order in which the behavior will be handled. Lower numbers are handled earlier, with an order of 0 getting\n     * special treatment before the Emitter's transformation is applied.\n     */\n    order: number;\n    /**\n     * Called to initialize a wave of particles, with a reference to the first particle in the linked list.\n     * @param first The first (maybe only) particle in a newly spawned wave of particles.\n     */\n    initParticles(first: Particle): void;\n    /**\n     * Updates a single particle for a given period of time elapsed. Return `true` to recycle the particle.\n     * @param particle The particle to update.\n     * @param deltaSec The time to advance the particle by in seconds.\n     */\n    updateParticle?(particle: Particle, deltaSec: number): void|boolean;\n    /**\n     * A hook for when a particle is recycled.\n     * @param particle The particle that was just recycled.\n     * @param natural `true` if the reycling was due to natural lifecycle, `false` if it was due to emitter cleanup.\n     */\n    recycleParticle?(particle: Particle, natural: boolean): void;\n}\n\n/**\n * All behavior classes must match this interface. The instances need to implement the {@link IEmitterBehavior} interface.\n */\nexport interface IEmitterBehaviorClass\n{\n    /**\n     * The unique type name that the behavior is registered under.\n     */\n    type: string;\n    /**\n     * Configuration data for an editor to display this behavior. Does not need to exist in production code.\n     */\n    editorConfig?: BehaviorEditorConfig;\n    /**\n     * The behavior constructor itself.\n     * @param config The config for the behavior, which should match its defined specifications.\n     */\n    new (config: any): IEmitterBehavior;\n}\n\n/**\n * Standard behavior order values, specifying when/how they are used. Other numeric values can be used,\n * but only the Spawn value will be handled in a special way. All other values will be sorted numerically.\n * Behaviors with the same value will not be given any specific sort order, as they are assumed to not\n * interfere with each other.\n */\nexport enum BehaviorOrder\n{\n    /**\n     * Spawn - initial placement and/or rotation. This happens before rotation/translation due to\n     * emitter rotation/position is applied.\n     */\n    Spawn = 0,\n    /**\n     * Normal priority, for things that don't matter when they are applied.\n     */\n    Normal = 2,\n    /**\n     * Delayed priority, for things that need to read other values in order to act correctly.\n     */\n    Late = 5,\n}\n","import { generateEase, rotatePoint, SimpleEase } from './ParticleUtils';\nimport { Particle } from './Particle';\nimport { EmitterConfigV3 } from './EmitterConfig';\nimport { Container } from '@pixi/display';\nimport { Point } from '@pixi/math';\nimport { Ticker } from '@pixi/ticker';\nimport { BehaviorOrder, IEmitterBehavior, IEmitterBehaviorClass } from './behaviors/Behaviors';\n// get the shared ticker, only supports V5 and V6 with individual packages\n/**\n * @hidden\n */\nconst ticker = Ticker.shared;\n\n/**\n * Key used in sorted order to determine when to set particle position from the emitter position\n * and rotation.\n */\nconst PositionParticle = Symbol('Position particle per emitter position');\n\n/**\n * A particle emitter.\n */\nexport class Emitter\n{\n    private static knownBehaviors: {[key: string]: IEmitterBehaviorClass} = {};\n\n    /**\n     * Registers a new behavior, so that it will be recognized when initializing emitters.\n     * Behaviors registered later with duplicate types will override older ones, although there is no limit on\n     * the allowed types.\n     * @param constructor The behavior class to register.\n     */\n    public static registerBehavior(constructor: IEmitterBehaviorClass): void\n    {\n        Emitter.knownBehaviors[constructor.type] = constructor;\n    }\n\n    /**\n     * Active initialization behaviors for this emitter.\n     */\n    protected initBehaviors: (IEmitterBehavior | typeof PositionParticle)[];\n    /**\n     * Active update behaviors for this emitter.\n     */\n    protected updateBehaviors: IEmitterBehavior[];\n    /**\n     * Active recycle behaviors for this emitter.\n     */\n    protected recycleBehaviors: IEmitterBehavior[];\n    // properties for individual particles\n    /**\n     * The minimum lifetime for a particle, in seconds.\n     */\n    public minLifetime: number;\n    /**\n     * The maximum lifetime for a particle, in seconds.\n     */\n    public maxLifetime: number;\n    /**\n     * An easing function for nonlinear interpolation of values. Accepts a single\n     * parameter of time as a value from 0-1, inclusive. Expected outputs are values\n     * from 0-1, inclusive.\n     */\n    public customEase: SimpleEase;\n    // properties for spawning particles\n    /**\n     * Time between particle spawns in seconds.\n     */\n    protected _frequency: number;\n    /**\n     * Chance that a particle will be spawned on each opportunity to spawn one.\n     * 0 is 0%, 1 is 100%.\n     */\n    public spawnChance: number;\n    /**\n     * Maximum number of particles to keep alive at a time. If this limit\n     * is reached, no more particles will spawn until some have died.\n     */\n    public maxParticles: number;\n    /**\n     * The amount of time in seconds to emit for before setting emit to false.\n     * A value of -1 is an unlimited amount of time.\n     */\n    public emitterLifetime: number;\n    /**\n     * Position at which to spawn particles, relative to the emitter's owner's origin.\n     * For example, the flames of a rocket travelling right might have a spawnPos\n     * of {x:-50, y:0}.\n     * to spawn at the rear of the rocket.\n     * To change this, use updateSpawnPos().\n     */\n    public spawnPos: Point;\n    /**\n     * Number of particles to spawn time that the frequency allows for particles to spawn.\n     */\n    public particlesPerWave: number;\n    /**\n     * Rotation of the emitter or emitter's owner in degrees. This is added to\n     * the calculated spawn angle.\n     * To change this, use rotate().\n     */\n    protected rotation: number;\n    /**\n     * The world position of the emitter's owner, to add spawnPos to when\n     * spawning particles. To change this, use updateOwnerPos().\n     */\n    protected ownerPos: Point;\n    /**\n     * The origin + spawnPos in the previous update, so that the spawn position\n     * can be interpolated to space out particles better.\n     */\n    protected _prevEmitterPos: Point;\n    /**\n     * If _prevEmitterPos is valid, to prevent interpolation on the first update\n     */\n    protected _prevPosIsValid: boolean;\n    /**\n     * If either ownerPos or spawnPos has changed since the previous update.\n     */\n    protected _posChanged: boolean;\n    /**\n     * The container to add particles to.\n     */\n    protected _parent: Container;\n    /**\n     * If particles should be added at the back of the display list instead of the front.\n     */\n    public addAtBack: boolean;\n    /**\n     * The current number of active particles.\n     */\n    public particleCount: number;\n    /**\n     * If particles should be emitted during update() calls. Setting this to false\n     * stops new particles from being created, but allows existing ones to die out.\n     */\n    protected _emit: boolean;\n    /**\n     * The timer for when to spawn particles in seconds, where numbers less\n     * than 0 mean that particles should be spawned.\n     */\n    protected _spawnTimer: number;\n    /**\n     * The life of the emitter in seconds.\n     */\n    protected _emitterLife: number;\n    /**\n     * The particles that are active and on the display list. This is the first particle in a\n     * linked list.\n     */\n    protected _activeParticlesFirst: Particle;\n    /**\n     * The particles that are active and on the display list. This is the last particle in a\n     * linked list.\n     */\n    protected _activeParticlesLast: Particle;\n    /**\n     * The particles that are not currently being used. This is the first particle in a\n     * linked list.\n     */\n    protected _poolFirst: Particle;\n    /**\n     * The original config object that this emitter was initialized with.\n     */\n    protected _origConfig: any;\n    /**\n     * If the update function is called automatically from the shared ticker.\n     * Setting this to false requires calling the update function manually.\n     */\n    protected _autoUpdate: boolean;\n    /**\n     * If the emitter should destroy itself when all particles have died out. This is set by\n     * playOnceAndDestroy();\n     */\n    protected _destroyWhenComplete: boolean;\n    /**\n     * A callback for when all particles have died out. This is set by\n     * playOnceAndDestroy() or playOnce();\n     */\n    protected _completeCallback: () => void;\n\n    /**\n     * @param particleParent The container to add the particles to.\n     * @param particleImages A texture or array of textures to use\n     *                       for the particles. Strings will be turned\n     *                       into textures via Texture.from().\n     * @param config A configuration object containing settings for the emitter.\n     * @param config.emit If config.emit is explicitly passed as false, the\n     *                    Emitter will start disabled.\n     * @param config.autoUpdate If config.autoUpdate is explicitly passed as\n     *                          true, the Emitter will automatically call\n     *                          update via the PIXI shared ticker.\n     */\n    constructor(particleParent: Container, config: EmitterConfigV3)\n    {\n        this.initBehaviors = [];\n        this.updateBehaviors = [];\n        this.recycleBehaviors = [];\n        // properties for individual particles\n        this.minLifetime = 0;\n        this.maxLifetime = 0;\n        this.customEase = null;\n        // properties for spawning particles\n        this._frequency = 1;\n        this.spawnChance = 1;\n        this.maxParticles = 1000;\n        this.emitterLifetime = -1;\n        this.spawnPos = new Point();\n        this.particlesPerWave = 1;\n        // emitter properties\n        this.rotation = 0;\n        this.ownerPos = new Point();\n        this._prevEmitterPos = new Point();\n        this._prevPosIsValid = false;\n        this._posChanged = false;\n        this._parent = null;\n        this.addAtBack = false;\n        this.particleCount = 0;\n        this._emit = false;\n        this._spawnTimer = 0;\n        this._emitterLife = -1;\n        this._activeParticlesFirst = null;\n        this._activeParticlesLast = null;\n        this._poolFirst = null;\n        this._origConfig = null;\n        this._autoUpdate = false;\n        this._destroyWhenComplete = false;\n        this._completeCallback = null;\n\n        // set the initial parent\n        this.parent = particleParent;\n\n        if (config)\n        {\n            this.init(config);\n        }\n\n        // save often used functions on the instance instead of the prototype for better speed\n        this.recycle = this.recycle;\n        this.update = this.update;\n        this.rotate = this.rotate;\n        this.updateSpawnPos = this.updateSpawnPos;\n        this.updateOwnerPos = this.updateOwnerPos;\n    }\n\n    /**\n     * Time between particle spawns in seconds. If this value is not a number greater than 0,\n     * it will be set to 1 (particle per second) to prevent infinite loops.\n     */\n    public get frequency(): number { return this._frequency; }\n    public set frequency(value: number)\n    {\n        // do some error checking to prevent infinite loops\n        if (typeof value === 'number' && value > 0)\n        {\n            this._frequency = value;\n        }\n        else\n        {\n            this._frequency = 1;\n        }\n    }\n\n    /**\n    * The container to add particles to. Settings this will dump any active particles.\n    */\n    public get parent(): Container { return this._parent; }\n    public set parent(value: Container)\n    {\n        this.cleanup();\n        this._parent = value;\n    }\n\n    /**\n     * Sets up the emitter based on the config settings.\n     * @param config A configuration object containing settings for the emitter.\n     */\n    public init(config: EmitterConfigV3): void\n    {\n        if (!config)\n        {\n            return;\n        }\n        // clean up any existing particles\n        this.cleanup();\n\n        // store the original config and particle images, in case we need to re-initialize\n        // when the particle constructor is changed\n        this._origConfig = config;\n\n        // /////////////////////////\n        // Particle Properties    //\n        // /////////////////////////\n\n        // set up the lifetime\n        this.minLifetime = config.lifetime.min;\n        this.maxLifetime = config.lifetime.max;\n        // use the custom ease if provided\n        if (config.ease)\n        {\n            this.customEase = typeof config.ease === 'function'\n                ? config.ease : generateEase(config.ease);\n        }\n        else\n        {\n            this.customEase = null;\n        }\n        // ////////////////////////\n        // Emitter Properties    //\n        // ////////////////////////\n        // reset spawn type specific settings\n        this.particlesPerWave = 1;\n        if (config.particlesPerWave && config.particlesPerWave > 1)\n        {\n            this.particlesPerWave = config.particlesPerWave;\n        }\n        // set the spawning frequency\n        this.frequency = config.frequency;\n        this.spawnChance = (typeof config.spawnChance === 'number' && config.spawnChance > 0) ? config.spawnChance : 1;\n        // set the emitter lifetime\n        this.emitterLifetime = config.emitterLifetime || -1;\n        // set the max particles\n        this.maxParticles = config.maxParticles > 0 ? config.maxParticles : 1000;\n        // determine if we should add the particle at the back of the list or not\n        this.addAtBack = !!config.addAtBack;\n        // reset the emitter position and rotation variables\n        this.rotation = 0;\n        this.ownerPos.set(0);\n        if (config.pos)\n        {\n            this.spawnPos.copyFrom(config.pos);\n        }\n        else\n        {\n            this.spawnPos.set(0);\n        }\n\n        this._prevEmitterPos.copyFrom(this.spawnPos);\n        // previous emitter position is invalid and should not be used for interpolation\n        this._prevPosIsValid = false;\n        // start emitting\n        this._spawnTimer = 0;\n        this.emit = config.emit === undefined ? true : !!config.emit;\n        this.autoUpdate = !!config.autoUpdate;\n\n        // ////////////////////////\n        // Behaviors             //\n        // ////////////////////////\n        const behaviors: (IEmitterBehavior | typeof PositionParticle)[] = config.behaviors.map((data) =>\n        {\n            const constructor = Emitter.knownBehaviors[data.type];\n\n            if (!constructor)\n            {\n                console.error(`Unknown behavior: ${data.type}`);\n\n                return null;\n            }\n\n            return new constructor(data.config);\n        })\n            .filter((b) => !!b);\n\n        behaviors.push(PositionParticle);\n        behaviors.sort((a, b) =>\n        {\n            if (a === PositionParticle)\n            {\n                return (b as IEmitterBehavior).order === BehaviorOrder.Spawn ? 1 : -1;\n            }\n            else if (b === PositionParticle)\n            {\n                return (a as IEmitterBehavior).order === BehaviorOrder.Spawn ? -1 : 1;\n            }\n\n            return (a as IEmitterBehavior).order - (b as IEmitterBehavior).order;\n        });\n        this.initBehaviors = behaviors.slice();\n        this.updateBehaviors = behaviors.filter((b) => b !== PositionParticle && b.updateParticle) as IEmitterBehavior[];\n        this.recycleBehaviors = behaviors.filter((b) => b !== PositionParticle && b.recycleParticle) as IEmitterBehavior[];\n    }\n\n    /**\n     * Gets the instantiated behavior of the specified type, if it is present on this emitter.\n     * @param type The behavior type to find.\n     */\n    public getBehavior(type: string): IEmitterBehavior|null\n    {\n        // bail if we don't know about such an emitter\n        if (!Emitter.knownBehaviors[type]) return null;\n\n        // find one that is an instance of the specified type\n        return this.initBehaviors.find((b) => b instanceof Emitter.knownBehaviors[type]) as IEmitterBehavior || null;\n    }\n\n    /**\n     * Fills the pool with the specified number of particles, so that they don't have to be instantiated later.\n     * @param count The number of particles to create.\n     */\n    public fillPool(count: number): void\n    {\n        for (; count > 0; --count)\n        {\n            const p = new Particle(this);\n\n            p.next = this._poolFirst;\n            this._poolFirst = p;\n        }\n    }\n\n    /**\n     * Recycles an individual particle. For internal use only.\n     * @param particle The particle to recycle.\n     * @param fromCleanup If this is being called to manually clean up all particles.\n     * @internal\n     */\n    public recycle(particle: Particle, fromCleanup = false): void\n    {\n        for (let i = 0; i < this.recycleBehaviors.length; ++i)\n        {\n            this.recycleBehaviors[i].recycleParticle(particle, !fromCleanup);\n        }\n        if (particle.next)\n        {\n            particle.next.prev = particle.prev;\n        }\n        if (particle.prev)\n        {\n            particle.prev.next = particle.next;\n        }\n        if (particle === this._activeParticlesLast)\n        {\n            this._activeParticlesLast = particle.prev;\n        }\n        if (particle === this._activeParticlesFirst)\n        {\n            this._activeParticlesFirst = particle.next;\n        }\n        // add to pool\n        particle.prev = null;\n        particle.next = this._poolFirst;\n        this._poolFirst = particle;\n        // remove child from display, or make it invisible if it is in a ParticleContainer\n        if (particle.parent)\n        {\n            particle.parent.removeChild(particle);\n        }\n        // decrease count\n        --this.particleCount;\n    }\n\n    /**\n     * Sets the rotation of the emitter to a new value. This rotates the spawn position in addition\n     * to particle direction.\n     * @param newRot The new rotation, in degrees.\n     */\n    public rotate(newRot: number): void\n    {\n        if (this.rotation === newRot) return;\n        // caclulate the difference in rotation for rotating spawnPos\n        const diff = newRot - this.rotation;\n\n        this.rotation = newRot;\n        // rotate spawnPos\n        rotatePoint(diff, this.spawnPos);\n        // mark the position as having changed\n        this._posChanged = true;\n    }\n\n    /**\n     * Changes the spawn position of the emitter.\n     * @param x The new x value of the spawn position for the emitter.\n     * @param y The new y value of the spawn position for the emitter.\n     */\n    public updateSpawnPos(x: number, y: number): void\n    {\n        this._posChanged = true;\n        this.spawnPos.x = x;\n        this.spawnPos.y = y;\n    }\n\n    /**\n     * Changes the position of the emitter's owner. You should call this if you are adding\n     * particles to the world container that your emitter's owner is moving around in.\n     * @param x The new x value of the emitter's owner.\n     * @param y The new y value of the emitter's owner.\n     */\n    public updateOwnerPos(x: number, y: number): void\n    {\n        this._posChanged = true;\n        this.ownerPos.x = x;\n        this.ownerPos.y = y;\n    }\n\n    /**\n     * Prevents emitter position interpolation in the next update.\n     * This should be used if you made a major position change of your emitter's owner\n     * that was not normal movement.\n     */\n    public resetPositionTracking(): void\n    {\n        this._prevPosIsValid = false;\n    }\n\n    /**\n     * If particles should be emitted during update() calls. Setting this to false\n     * stops new particles from being created, but allows existing ones to die out.\n     */\n    public get emit(): boolean { return this._emit; }\n    public set emit(value: boolean)\n    {\n        this._emit = !!value;\n        this._emitterLife = this.emitterLifetime;\n    }\n\n    /**\n     * If the update function is called automatically from the shared ticker.\n     * Setting this to false requires calling the update function manually.\n     */\n    public get autoUpdate(): boolean { return this._autoUpdate; }\n    public set autoUpdate(value: boolean)\n    {\n        if (this._autoUpdate && !value)\n        {\n            ticker.remove(this.update, this);\n        }\n        else if (!this._autoUpdate && value)\n        {\n            ticker.add(this.update, this);\n        }\n        this._autoUpdate = !!value;\n    }\n\n    /**\n     * Starts emitting particles, sets autoUpdate to true, and sets up the Emitter to destroy itself\n     * when particle emission is complete.\n     * @param callback Callback for when emission is complete (all particles have died off)\n     */\n    public playOnceAndDestroy(callback?: () => void): void\n    {\n        this.autoUpdate = true;\n        this.emit = true;\n        this._destroyWhenComplete = true;\n        this._completeCallback = callback;\n    }\n\n    /**\n     * Starts emitting particles and optionally calls a callback when particle emission is complete.\n     * @param callback Callback for when emission is complete (all particles have died off)\n     */\n    public playOnce(callback?: () => void): void\n    {\n        this.emit = true;\n        this._completeCallback = callback;\n    }\n\n    /**\n     * Updates all particles spawned by this emitter and emits new ones.\n     * @param delta Time elapsed since the previous frame, in __seconds__.\n     */\n    public update(delta: number): void\n    {\n        if (this._autoUpdate)\n        {\n            delta = ticker.elapsedMS * 0.001;\n        }\n\n        // if we don't have a parent to add particles to, then don't do anything.\n        // this also works as a isDestroyed check\n        if (!this._parent) return;\n\n        // == update existing particles ==\n\n        // update all particle lifetimes before turning them over to behaviors\n        for (let particle = this._activeParticlesFirst, next; particle; particle = next)\n        {\n            // save next particle in case we recycle this one\n            next = particle.next;\n            // increase age\n            particle.age += delta;\n            // recycle particle if it is too old\n            if (particle.age > particle.maxLife || particle.age < 0)\n            {\n                this.recycle(particle);\n            }\n            else\n            {\n                // determine our interpolation value\n                let lerp = particle.age * particle.oneOverLife;// lifetime / maxLife;\n\n                // global ease affects all interpolation calculations\n                if (this.customEase)\n                {\n                    if (this.customEase.length === 4)\n                    {\n                        // the t, b, c, d parameters that some tween libraries use\n                        // (time, initial value, end value, duration)\n                        lerp = (this.customEase as any)(lerp, 0, 1, 1);\n                    }\n                    else\n                    {\n                        // the simplified version that we like that takes\n                        // one parameter, time from 0-1. TweenJS eases provide this usage.\n                        lerp = this.customEase(lerp);\n                    }\n                }\n\n                // set age percent for all interpolation calculations\n                particle.agePercent = lerp;\n\n                // let each behavior run wild on the active particles\n                for (let i = 0; i < this.updateBehaviors.length; ++i)\n                {\n                    if (this.updateBehaviors[i].updateParticle(particle, delta))\n                    {\n                        this.recycle(particle);\n                        break;\n                    }\n                }\n            }\n        }\n\n        let prevX: number;\n        let prevY: number;\n\n        // if the previous position is valid, store these for later interpolation\n        if (this._prevPosIsValid)\n        {\n            prevX = this._prevEmitterPos.x;\n            prevY = this._prevEmitterPos.y;\n        }\n        // store current position of the emitter as local variables\n        const curX = this.ownerPos.x + this.spawnPos.x;\n        const curY = this.ownerPos.y + this.spawnPos.y;\n        // spawn new particles\n\n        if (this._emit)\n        {\n            // decrease spawn timer\n            this._spawnTimer -= delta < 0 ? 0 : delta;\n            // while _spawnTimer < 0, we have particles to spawn\n            while (this._spawnTimer <= 0)\n            {\n                // determine if the emitter should stop spawning\n                if (this._emitterLife >= 0)\n                {\n                    this._emitterLife -= this._frequency;\n                    if (this._emitterLife <= 0)\n                    {\n                        this._spawnTimer = 0;\n                        this._emitterLife = 0;\n                        this.emit = false;\n                        break;\n                    }\n                }\n                // determine if we have hit the particle limit\n                if (this.particleCount >= this.maxParticles)\n                {\n                    this._spawnTimer += this._frequency;\n                    continue;\n                }\n                let emitPosX: number;\n                let emitPosY: number;\n\n                // If the position has changed and this isn't the first spawn,\n                // interpolate the spawn position\n                if (this._prevPosIsValid && this._posChanged)\n                {\n                    // 1 - _spawnTimer / delta, but _spawnTimer is negative\n                    const lerp = 1 + (this._spawnTimer / delta);\n\n                    emitPosX = ((curX - prevX) * lerp) + prevX;\n                    emitPosY = ((curY - prevY) * lerp) + prevY;\n                }\n                // otherwise just set to the spawn position\n                else\n                {\n                    emitPosX = curX;\n                    emitPosY = curY;\n                }\n\n                let waveFirst: Particle = null;\n                let waveLast: Particle = null;\n\n                // create enough particles to fill the wave\n                for (let len = Math.min(this.particlesPerWave, this.maxParticles - this.particleCount), i = 0; i < len; ++i)\n                {\n                    // see if we actually spawn one\n                    if (this.spawnChance < 1 && Math.random() >= this.spawnChance)\n                    {\n                        continue;\n                    }\n                    // determine the particle lifetime\n                    let lifetime;\n\n                    if (this.minLifetime === this.maxLifetime)\n                    {\n                        lifetime = this.minLifetime;\n                    }\n                    else\n                    {\n                        lifetime = (Math.random() * (this.maxLifetime - this.minLifetime)) + this.minLifetime;\n                    }\n                    // only make the particle if it wouldn't immediately destroy itself\n                    if (-this._spawnTimer >= lifetime)\n                    {\n                        continue;\n                    }\n                    // create particle\n                    let p: Particle;\n\n                    if (this._poolFirst)\n                    {\n                        p = this._poolFirst;\n                        this._poolFirst = this._poolFirst.next;\n                        p.next = null;\n                    }\n                    else\n                    {\n                        p = new Particle(this);\n                    }\n\n                    // initialize particle\n                    p.init(lifetime);\n                    // add the particle to the display list\n                    if (this.addAtBack)\n                    {\n                        this._parent.addChildAt(p, 0);\n                    }\n                    else\n                    {\n                        this._parent.addChild(p);\n                    }\n                    // add particles to list of ones in this wave\n                    if (waveFirst)\n                    {\n                        waveLast.next = p;\n                        p.prev = waveLast;\n                        waveLast = p;\n                    }\n                    else\n                    {\n                        waveLast = waveFirst = p;\n                    }\n                    // increase our particle count\n                    ++this.particleCount;\n                }\n\n                if (waveFirst)\n                {\n                    // add particle to list of active particles\n                    if (this._activeParticlesLast)\n                    {\n                        this._activeParticlesLast.next = waveFirst;\n                        waveFirst.prev = this._activeParticlesLast;\n                        this._activeParticlesLast = waveLast;\n                    }\n                    else\n                    {\n                        this._activeParticlesFirst = waveFirst;\n                        this._activeParticlesLast = waveLast;\n                    }\n                    // run behavior init on particles\n                    for (let i = 0; i < this.initBehaviors.length; ++i)\n                    {\n                        const behavior = this.initBehaviors[i];\n\n                        // if we hit our special key, interrupt behaviors to apply\n                        // emitter position/rotation\n                        if (behavior === PositionParticle)\n                        {\n                            for (let particle = waveFirst, next; particle; particle = next)\n                            {\n                                // save next particle in case we recycle this one\n                                next = particle.next;\n                                // rotate the particle's position by the emitter's rotation\n                                if (this.rotation !== 0)\n                                {\n                                    rotatePoint(this.rotation, particle.position);\n                                    particle.rotation += this.rotation;\n                                }\n                                // offset by the emitter's position\n                                particle.position.x += emitPosX;\n                                particle.position.y += emitPosY;\n\n                                // also, just update the particle's age properties while we are looping through\n                                particle.age += -this._spawnTimer;\n                                // determine our interpolation value\n                                let lerp = particle.age * particle.oneOverLife;// lifetime / maxLife;\n\n                                // global ease affects all interpolation calculations\n                                if (this.customEase)\n                                {\n                                    if (this.customEase.length === 4)\n                                    {\n                                        // the t, b, c, d parameters that some tween libraries use\n                                        // (time, initial value, end value, duration)\n                                        lerp = (this.customEase as any)(lerp, 0, 1, 1);\n                                    }\n                                    else\n                                    {\n                                        // the simplified version that we like that takes\n                                        // one parameter, time from 0-1. TweenJS eases provide this usage.\n                                        lerp = this.customEase(lerp);\n                                    }\n                                }\n                                // set age percent for all interpolation calculations\n                                particle.agePercent = lerp;\n                            }\n                        }\n                        else\n                        {\n                            behavior.initParticles(waveFirst);\n                        }\n                    }\n                    for (let particle = waveFirst, next; particle; particle = next)\n                    {\n                        // save next particle in case we recycle this one\n                        next = particle.next;\n                        // now update the particles by the time passed, so the particles are spread out properly\n                        for (let i = 0; i < this.updateBehaviors.length; ++i)\n                        {\n                            // we want a positive delta, because a negative delta messes things up\n                            if (this.updateBehaviors[i].updateParticle(particle, -this._spawnTimer))\n                            {\n                                // bail if the particle got reycled\n                                this.recycle(particle);\n                                break;\n                            }\n                        }\n                    }\n                }\n                // increase timer and continue on to any other particles that need to be created\n                this._spawnTimer += this._frequency;\n            }\n        }\n        // if the position changed before this update, then keep track of that\n        if (this._posChanged)\n        {\n            this._prevEmitterPos.x = curX;\n            this._prevEmitterPos.y = curY;\n            this._prevPosIsValid = true;\n            this._posChanged = false;\n        }\n\n        // if we are all done and should destroy ourselves, take care of that\n        if (!this._emit && !this._activeParticlesFirst)\n        {\n            if (this._completeCallback)\n            {\n                const cb = this._completeCallback;\n\n                this._completeCallback = null;\n                cb();\n            }\n            if (this._destroyWhenComplete)\n            {\n                this.destroy();\n            }\n        }\n    }\n\n    /**\n     * Emits a single wave of particles, using standard spawnChance & particlesPerWave settings. Does not affect\n     * regular spawning through the frequency, and ignores the emit property. The max particle count is respected, however,\n     * so if there are already too many particles then nothing will happen.\n     */\n    public emitNow(): void\n    {\n        const emitPosX = this.ownerPos.x + this.spawnPos.x;\n        const emitPosY = this.ownerPos.y + this.spawnPos.y;\n\n        let waveFirst: Particle = null;\n        let waveLast: Particle = null;\n\n        // create enough particles to fill the wave\n        for (let len = Math.min(this.particlesPerWave, this.maxParticles - this.particleCount), i = 0; i < len; ++i)\n        {\n            // see if we actually spawn one\n            if (this.spawnChance < 1 && Math.random() >= this.spawnChance)\n            {\n                continue;\n            }\n            // create particle\n            let p: Particle;\n\n            if (this._poolFirst)\n            {\n                p = this._poolFirst;\n                this._poolFirst = this._poolFirst.next;\n                p.next = null;\n            }\n            else\n            {\n                p = new Particle(this);\n            }\n\n            let lifetime: number;\n\n            if (this.minLifetime === this.maxLifetime)\n            {\n                lifetime = this.minLifetime;\n            }\n            else\n            {\n                lifetime = (Math.random() * (this.maxLifetime - this.minLifetime)) + this.minLifetime;\n            }\n            // initialize particle\n            p.init(lifetime);\n            // add the particle to the display list\n            if (this.addAtBack)\n            {\n                this._parent.addChildAt(p, 0);\n            }\n            else\n            {\n                this._parent.addChild(p);\n            }\n            // add particles to list of ones in this wave\n            if (waveFirst)\n            {\n                waveLast.next = p;\n                p.prev = waveLast;\n                waveLast = p;\n            }\n            else\n            {\n                waveLast = waveFirst = p;\n            }\n            // increase our particle count\n            ++this.particleCount;\n        }\n\n        if (waveFirst)\n        {\n            // add particle to list of active particles\n            if (this._activeParticlesLast)\n            {\n                this._activeParticlesLast.next = waveFirst;\n                waveFirst.prev = this._activeParticlesLast;\n                this._activeParticlesLast = waveLast;\n            }\n            else\n            {\n                this._activeParticlesFirst = waveFirst;\n                this._activeParticlesLast = waveLast;\n            }\n            // run behavior init on particles\n            for (let i = 0; i < this.initBehaviors.length; ++i)\n            {\n                const behavior = this.initBehaviors[i];\n\n                // if we hit our special key, interrupt behaviors to apply\n                // emitter position/rotation\n                if (behavior === PositionParticle)\n                {\n                    for (let particle = waveFirst, next; particle; particle = next)\n                    {\n                        // save next particle in case we recycle this one\n                        next = particle.next;\n                        // rotate the particle's position by the emitter's rotation\n                        if (this.rotation !== 0)\n                        {\n                            rotatePoint(this.rotation, particle.position);\n                            particle.rotation += this.rotation;\n                        }\n                        // offset by the emitter's position\n                        particle.position.x += emitPosX;\n                        particle.position.y += emitPosY;\n                    }\n                }\n                else\n                {\n                    behavior.initParticles(waveFirst);\n                }\n            }\n        }\n    }\n\n    /**\n     * Kills all active particles immediately.\n     */\n    public cleanup(): void\n    {\n        let particle;\n        let next;\n\n        for (particle = this._activeParticlesFirst; particle; particle = next)\n        {\n            next = particle.next;\n            this.recycle(particle, true);\n        }\n        this._activeParticlesFirst = this._activeParticlesLast = null;\n        this.particleCount = 0;\n    }\n\n    /**\n     * If this emitter has been destroyed. Note that a destroyed emitter can still be reused, after\n     * having a new parent set and being reinitialized.\n     */\n    public get destroyed(): boolean\n    {\n        return !(this._parent && this.initBehaviors.length);\n    }\n\n    /**\n     * Destroys the emitter and all of its particles.\n     */\n    public destroy(): void\n    {\n        // make sure we aren't still listening to any tickers\n        this.autoUpdate = false;\n        // puts all active particles in the pool, and removes them from the particle parent\n        this.cleanup();\n        // wipe the pool clean\n        let next;\n\n        for (let particle = this._poolFirst; particle; particle = next)\n        {\n            // store next value so we don't lose it in our destroy call\n            next = particle.next;\n            particle.destroy();\n        }\n        this._poolFirst = this._parent = this.spawnPos = this.ownerPos\n            = this.customEase = this._completeCallback = null;\n\n        this.initBehaviors.length = this.updateBehaviors.length = this.recycleBehaviors.length = 0;\n    }\n}\n","import { Particle } from '../../Particle';\nimport type { ObjectProperty } from '../editor/Types';\nimport { SpawnShape } from './SpawnShape';\n\n/**\n * A SpawnShape that randomly picks locations inside a rectangle.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'rect',\n *     data: {\n *          x: 0,\n *          y: 0,\n *          w: 10,\n *          h: 100\n *     }\n * }\n * ```\n */\nexport class Rectangle implements SpawnShape\n{\n    public static type = 'rect';\n    public static editorConfig: ObjectProperty = null;\n    /**\n     * X (left) position of the rectangle.\n     */\n    public x: number;\n    /**\n     * Y (top) position of the rectangle.\n     */\n    public y: number;\n    /**\n     * Width of the rectangle.\n     */\n    public w: number;\n    /**\n     * Height of the rectangle.\n     */\n    public h: number;\n\n    constructor(config: {\n        /**\n         * X (left) position of the rectangle.\n         */\n        x: number;\n        /**\n         * Y (top) position of the rectangle.\n         */\n        y: number;\n        /**\n         * Width of the rectangle.\n         */\n        w: number;\n        /**\n         * Height of the rectangle.\n         */\n        h: number;\n    })\n    {\n        this.x = config.x;\n        this.y = config.y;\n        this.w = config.w;\n        this.h = config.h;\n    }\n\n    getRandPos(particle: Particle): void\n    {\n        // place the particle at a random point in the rectangle\n        particle.x = (Math.random() * this.w) + this.x;\n        particle.y = (Math.random() * this.h) + this.y;\n    }\n}\n","import { Particle } from '../../Particle';\nimport { rotatePoint } from '../../ParticleUtils';\nimport { ObjectProperty } from '../editor/Types';\nimport { SpawnShape } from './SpawnShape';\n\n/**\n * A class for spawning particles in a circle or ring.\n * Can optionally apply rotation to particles so that they are aimed away from the center of the circle.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'torus',\n *     data: {\n *          radius: 30,\n *          x: 0,\n *          y: 0,\n *          innerRadius: 10,\n *          rotation: true\n *     }\n * }\n * ```\n */\nexport class Torus implements SpawnShape\n{\n    public static type = 'torus';\n    public static editorConfig: ObjectProperty = null;\n    /**\n     * X position of the center of the shape.\n     */\n    public x: number;\n    /**\n     * Y position of the center of the shape.\n     */\n    public y: number;\n    /**\n     * Radius of circle, or outer radius of a ring.\n     */\n    public radius: number;\n    /**\n     * Inner radius of a ring. Use 0 to have a circle.\n     */\n    public innerRadius: number;\n    /**\n     * If rotation should be applied to particles.\n     */\n    public rotation: boolean;\n\n    constructor(config: {\n        /**\n         * Radius of circle, or outer radius of a ring. Note that this uses the full name of 'radius',\n         * where earlier versions of the library may have used 'r'.\n         */\n        radius: number;\n        /**\n         * X position of the center of the shape.\n         */\n        x: number;\n        /**\n         * Y position of the center of the shape.\n         */\n        y: number;\n        /**\n         * Inner radius of a ring. Omit, or use 0, to have a circle.\n         */\n        innerRadius?: number;\n        /**\n         * If rotation should be applied to particles, pointing them away from the center of the torus.\n         * Defaults to false.\n         */\n        affectRotation?: boolean\n    })\n    {\n        this.x = config.x || 0;\n        this.y = config.y || 0;\n        this.radius = config.radius;\n        this.innerRadius = config.innerRadius || 0;\n        this.rotation = !!config.affectRotation;\n    }\n\n    getRandPos(particle: Particle): void\n    {\n        // place the particle at a random radius in the ring\n        if (this.innerRadius !== this.radius)\n        {\n            particle.x = (Math.random() * (this.radius - this.innerRadius)) + this.innerRadius;\n        }\n        else\n        {\n            particle.x = this.radius;\n        }\n        particle.y = 0;\n        // rotate the point to a random angle in the circle\n        const angle = Math.random() * Math.PI * 2;\n\n        if (this.rotation)\n        {\n            particle.rotation += angle;\n        }\n        rotatePoint(angle, particle.position);\n        // now add in the center of the torus\n        particle.position.x += this.x;\n        particle.position.y += this.y;\n    }\n}\n","import { IPointData } from '@pixi/math';\nimport { ListProperty } from '../editor/Types';\nimport { SpawnShape } from './SpawnShape';\n\n/**\n * Data structure for internal parsed data in PolygonalChain spawn shapes.\n */\nexport interface Segment\n{\n    p1: IPointData;\n    p2: IPointData;\n    l: number;\n}\n\n/**\n * A spawn shape that picks a random position along a series of line segments. If those\n * line segments form a polygon, particles will only be placed on the perimeter of that polygon.\n *\n * Example config:\n * ```javascript\n * {\n *      type: 'polygonalChain',\n *      data: [\n *          [{x: 0, y: 0}, {x: 10, y: 10}, {x: 20, y: 0}],\n *          [{x: 0, y, -10}, {x: 10, y: 0}, {x: 20, y: -10}]\n *      ]\n * }\n * ```\n */\nexport class PolygonalChain implements SpawnShape\n{\n    public static type = 'polygonalChain';\n    public static editorConfig: ListProperty = null;\n    /**\n     * List of segment objects in the chain.\n     */\n    private segments: Segment[];\n    /**\n     * Total length of all segments of the chain.\n     */\n    private totalLength: number;\n    /**\n     * Total length of segments up to and including the segment of the same index.\n     * Used for weighted random selection of segment.\n     */\n    private countingLengths: number[];\n\n    /**\n     * @param data Point data for polygon chains. Either a list of points for a single chain, or a list of chains.\n     */\n    constructor(data: IPointData[]|IPointData[][])\n    {\n        this.segments = [];\n        this.countingLengths = [];\n        this.totalLength = 0;\n        this.init(data);\n    }\n\n    /**\n     * @param data Point data for polygon chains. Either a list of points for a single chain, or a list of chains.\n     */\n    private init(data: IPointData[]|IPointData[][]): void\n    {\n        // if data is not present, set up a segment of length 0\n        if (!data || !data.length)\n        {\n            this.segments.push({ p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 }, l: 0 });\n        }\n        else if (Array.isArray(data[0]))\n        {\n            // list of segment chains, each defined as a list of points\n            for (let i = 0; i < data.length; ++i)\n            {\n                // loop through the chain, connecting points\n                const chain = data[i] as IPointData[];\n                let prevPoint = chain[0] as IPointData;\n\n                for (let j = 1; j < chain.length; ++j)\n                {\n                    const second = chain[j] as IPointData;\n\n                    this.segments.push({ p1: prevPoint, p2: second, l: 0 });\n                    prevPoint = second;\n                }\n            }\n        }\n        else\n        {\n            let prevPoint = data[0] as IPointData;\n            // list of points\n\n            for (let i = 1; i < data.length; ++i)\n            {\n                const second = data[i] as IPointData;\n\n                this.segments.push({ p1: prevPoint, p2: second, l: 0 });\n                prevPoint = second;\n            }\n        }\n        // now go through our segments to calculate the lengths so that we\n        // can set up a nice weighted random distribution\n        for (let i = 0; i < this.segments.length; ++i)\n        {\n            const { p1, p2 } = this.segments[i];\n            const segLength = Math.sqrt(((p2.x - p1.x) * (p2.x - p1.x)) + ((p2.y - p1.y) * (p2.y - p1.y)));\n            // save length so we can turn a random number into a 0-1 interpolation value later\n\n            this.segments[i].l = segLength;\n            this.totalLength += segLength;\n            // keep track of the length so far, counting up\n            this.countingLengths.push(this.totalLength);\n        }\n    }\n\n    /**\n     * Gets a random point in the chain.\n     * @param out The point to store the selected position in.\n     */\n    public getRandPos(out: IPointData): void\n    {\n        // select a random spot in the length of the chain\n        const rand = Math.random() * this.totalLength;\n        let chosenSeg: Segment;\n        let lerp: number;\n\n        // if only one segment, it wins\n        if (this.segments.length === 1)\n        {\n            chosenSeg = this.segments[0];\n            lerp = rand;\n        }\n        else\n        {\n            // otherwise, go through countingLengths until we have determined\n            // which segment we chose\n            for (let i = 0; i < this.countingLengths.length; ++i)\n            {\n                if (rand < this.countingLengths[i])\n                {\n                    chosenSeg = this.segments[i];\n                    // set lerp equal to the length into that segment\n                    // (i.e. the remainder after subtracting all the segments before it)\n                    lerp = i === 0 ? rand : rand - this.countingLengths[i - 1];\n                    break;\n                }\n            }\n        }\n        // divide lerp by the segment length, to result in a 0-1 number.\n        lerp /= chosenSeg.l || 1;\n        const { p1, p2 } = chosenSeg;\n        // now calculate the position in the segment that the lerp value represents\n\n        out.x = p1.x + (lerp * (p2.x - p1.x));\n        out.y = p1.y + (lerp * (p2.y - p1.y));\n    }\n}\n","import { Point } from '@pixi/math';\nimport { Particle } from '../Particle';\nimport { rotatePoint, scaleBy, length } from '../ParticleUtils';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * A Movement behavior that handles movement by applying a constant acceleration to all particles.\n *\n * Example configuration:\n * ```javascript\n * {\n *     \"type\": \"moveAcceleration\",\n *     \"config\": {\n *          \"accel\": {\n *               \"x\": 0,\n *               \"y\": 2000\n *          },\n *          \"minStart\": 600,\n *          \"maxStart\": 600,\n *          \"rotate\": true\n *     }\n *}\n * ```\n */\nexport class AccelerationBehavior implements IEmitterBehavior\n{\n    public static type = 'moveAcceleration';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    // doesn't _really_ need to be late, but doing so ensures that we can override any\n    // rotation behavior that is mistakenly added\n    public order = BehaviorOrder.Late;\n    private minStart: number;\n    private maxStart: number;\n    private accel: {x: number; y: number};\n    private rotate: boolean;\n    private maxSpeed: number;\n    constructor(config: {\n        /**\n         * Minimum speed when initializing the particle, in world units/second.\n         */\n        minStart: number;\n        /**\n         * Maximum speed when initializing the particle. in world units/second.\n         */\n        maxStart: number;\n        /**\n         * Constant acceleration, in the coordinate space of the particle parent, in world units/second.\n         */\n        accel: {x: number; y: number};\n        /**\n         * Rotate the particle with its direction of movement.\n         * While initial movement direction reacts to rotation settings, this overrides any dynamic rotation.\n         * Defaults to false.\n         */\n        rotate?: boolean;\n        /**\n         * Maximum linear speed. 0 is unlimited. Defaults to 0.\n         */\n        maxSpeed?: number;\n    })\n    {\n        this.minStart = config.minStart;\n        this.maxStart = config.maxStart;\n        this.accel = config.accel;\n        this.rotate = !!config.rotate;\n        this.maxSpeed = config.maxSpeed ?? 0;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            const speed = (Math.random() * (this.maxStart - this.minStart)) + this.minStart;\n\n            if (!next.config.velocity)\n            {\n                next.config.velocity = new Point(speed, 0);\n            }\n            else\n            {\n                (next.config.velocity as Point).set(speed, 0);\n            }\n\n            rotatePoint(next.rotation, next.config.velocity);\n\n            next = next.next;\n        }\n    }\n\n    updateParticle(particle: Particle, deltaSec: number): void\n    {\n        const vel = particle.config.velocity;\n        const oldVX = vel.x;\n        const oldVY = vel.y;\n\n        vel.x += this.accel.x * deltaSec;\n        vel.y += this.accel.y * deltaSec;\n        if (this.maxSpeed)\n        {\n            const currentSpeed = length(vel);\n            // if we are going faster than we should, clamp at the max speed\n            // DO NOT recalculate vector length\n\n            if (currentSpeed > this.maxSpeed)\n            {\n                scaleBy(vel, this.maxSpeed / currentSpeed);\n            }\n        }\n        // calculate position delta by the midpoint between our old velocity and our new velocity\n        particle.x += (oldVX + vel.x) / 2 * deltaSec;\n        particle.y += (oldVY + vel.y) / 2 * deltaSec;\n        if (this.rotate)\n        {\n            particle.rotation = Math.atan2(vel.y, vel.x);\n        }\n    }\n}\n","import { combineRGBComponents, SimpleEase, Color } from './ParticleUtils';\nimport { PropertyNode } from './PropertyNode';\n\nfunction intValueSimple(this: PropertyList<number>, lerp: number): number\n{\n    if (this.ease) lerp = this.ease(lerp);\n\n    return ((this.first.next.value - this.first.value) * lerp) + this.first.value;\n}\n\nfunction intColorSimple(this: PropertyList<Color>, lerp: number): number\n{\n    if (this.ease) lerp = this.ease(lerp);\n\n    const curVal = this.first.value;\n    const nextVal = this.first.next.value;\n    const r = ((nextVal.r - curVal.r) * lerp) + curVal.r;\n    const g = ((nextVal.g - curVal.g) * lerp) + curVal.g;\n    const b = ((nextVal.b - curVal.b) * lerp) + curVal.b;\n\n    return combineRGBComponents(r, g, b);\n}\n\nfunction intValueComplex(this: PropertyList<number>, lerp: number): number\n{\n    if (this.ease) lerp = this.ease(lerp);\n\n    // make sure we are on the right segment\n    let current = this.first;\n    let next = current.next;\n\n    while (lerp > next.time)\n    {\n        current = next;\n        next = next.next;\n    }\n    // convert the lerp value to the segment range\n    lerp = (lerp - current.time) / (next.time - current.time);\n\n    return ((next.value - current.value) * lerp) + current.value;\n}\n\nfunction intColorComplex(this: PropertyList<Color>, lerp: number): number\n{\n    if (this.ease) lerp = this.ease(lerp);\n\n    // make sure we are on the right segment\n    let current = this.first;\n    let next = current.next;\n\n    while (lerp > next.time)\n    {\n        current = next;\n        next = next.next;\n    }\n    // convert the lerp value to the segment range\n    lerp = (lerp - current.time) / (next.time - current.time);\n    const curVal = current.value;\n    const nextVal = next.value;\n    const r = ((nextVal.r - curVal.r) * lerp) + curVal.r;\n    const g = ((nextVal.g - curVal.g) * lerp) + curVal.g;\n    const b = ((nextVal.b - curVal.b) * lerp) + curVal.b;\n\n    return combineRGBComponents(r, g, b);\n}\n\nfunction intValueStepped(this: PropertyList<number>, lerp: number): number\n{\n    if (this.ease) lerp = this.ease(lerp);\n\n    // make sure we are on the right segment\n    let current = this.first;\n\n    while (current.next && lerp > current.next.time)\n    {\n        current = current.next;\n    }\n\n    return current.value;\n}\n\nfunction intColorStepped(this: PropertyList<Color>, lerp: number): number\n{\n    if (this.ease) lerp = this.ease(lerp);\n\n    // make sure we are on the right segment\n    let current = this.first;\n\n    while (current.next && lerp > current.next.time)\n    {\n        current = current.next;\n    }\n    const curVal = current.value;\n\n    return combineRGBComponents(curVal.r, curVal.g, curVal.b);\n}\n\n/**\n * Singly linked list container for keeping track of interpolated properties for particles.\n * Each Particle will have one of these for each interpolated property.\n */\nexport class PropertyList<V>\n{\n    /**\n     * The first property node in the linked list.\n     */\n    public first: PropertyNode<V>;\n    /**\n     * Calculates the correct value for the current interpolation value. This method is set in\n     * the reset() method.\n     * @param lerp The interpolation value from 0-1.\n     * @return The interpolated value. Colors are converted to the hex value.\n     */\n    public interpolate: (lerp: number) => number;\n    /**\n     * A custom easing method for this list.\n     * @param lerp The interpolation value from 0-1.\n     * @return The eased value, also from 0-1.\n     */\n    public ease: SimpleEase;\n    /**\n     * If this list manages colors, which requires a different method for interpolation.\n     */\n    private isColor: boolean;\n\n    /**\n     * @param isColor If this list handles color values\n     */\n    constructor(isColor = false)\n    {\n        this.first = null;\n        this.isColor = !!isColor;\n        this.interpolate = null;\n        this.ease = null;\n    }\n\n    /**\n     * Resets the list for use.\n     * @param first The first node in the list.\n     * @param first.isStepped If the values should be stepped instead of interpolated linearly.\n     */\n    public reset(first: PropertyNode<V>): void\n    {\n        this.first = first;\n        const isSimple = first.next && first.next.time >= 1;\n\n        if (isSimple)\n        {\n            this.interpolate = this.isColor ? intColorSimple : intValueSimple;\n        }\n        else if (first.isStepped)\n        {\n            this.interpolate = this.isColor ? intColorStepped : intValueStepped;\n        }\n        else\n        {\n            this.interpolate = this.isColor ? intColorComplex : intValueComplex;\n        }\n        this.ease = this.first.ease;\n    }\n}\n","import { Particle } from '../Particle';\nimport { PropertyList } from '../PropertyList';\nimport { PropertyNode, ValueList } from '../PropertyNode';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * An Alpha behavior that applies an interpolated or stepped list of values to the particle's opacity.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'alpha',\n *     config: {\n *         alpha: {\n *              list: [{value: 0, time: 0}, {value: 1, time: 0.25}, {value: 0, time: 1}]\n *         },\n *     }\n * }\n * ```\n */\nexport class AlphaBehavior implements IEmitterBehavior\n{\n    public static type = 'alpha';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private list: PropertyList<number>;\n    constructor(config: {\n        /**\n         * Transparency of the particles from 0 (transparent) to 1 (opaque)\n         */\n        alpha: ValueList<number>;\n    })\n    {\n        this.list = new PropertyList(false);\n        this.list.reset(PropertyNode.createList(config.alpha));\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            next.alpha = this.list.first.value;\n            next = next.next;\n        }\n    }\n\n    updateParticle(particle: Particle): void\n    {\n        particle.alpha = this.list.interpolate(particle.agePercent);\n    }\n}\n\n/**\n * An Alpha behavior that applies a static value to the particle's opacity at particle initialization.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'alphaStatic',\n *     config: {\n *         alpha: 0.75,\n *     }\n * }\n * ```\n */\nexport class StaticAlphaBehavior implements IEmitterBehavior\n{\n    public static type = 'alphaStatic';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private value: number;\n    constructor(config: {\n        /**\n         * Transparency of the particles from 0 (transparent) to 1 (opaque)\n         */\n        alpha: number;\n    })\n    {\n        this.value = config.alpha;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            next.alpha = this.value;\n            next = next.next;\n        }\n    }\n}\n","import { Texture } from '@pixi/core';\nimport { Particle } from '../Particle';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { GetTextureFromString } from '../ParticleUtils';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * The format of a single animation to be used on a particle.\n */\nexport interface AnimatedParticleArt\n{\n    /**\n     * Framerate for the animation (in frames per second). A value of -1 will tie the framerate to\n     * the particle's lifetime so that the animation lasts exactly as long as the particle.\n     */\n    framerate: -1|number;\n    /**\n     * If the animation should loop. Defaults to false.\n     */\n    loop?: boolean;\n    /**\n     * A list of textures or frame descriptions for duplicated frames.\n     * String values will be converted to textures with {@link ParticleUtils.GetTextureFromString}.\n     * Example of a texture repeated for 5 frames, followed by a second texture for one frame:\n     * ```javascript\n     * [{texture: 'myFirstTex', count: 5}, 'mySecondTex']\n     * ```\n     */\n    textures: (string|Texture|{texture: string|Texture; count: number})[];\n}\n\n/**\n * Internal data format for playback.\n */\nexport interface ParsedAnimatedParticleArt\n{\n    textures: Texture[];\n    duration: number;\n    framerate: number;\n    loop: boolean;\n}\n\nfunction getTextures(textures: (string|Texture|{texture: string|Texture; count: number})[]): Texture[]\n{\n    const outTextures: Texture[] = [];\n\n    for (let j = 0; j < textures.length; ++j)\n    {\n        let tex = textures[j];\n\n        if (typeof tex === 'string')\n        {\n            outTextures.push(GetTextureFromString(tex));\n        }\n        else if (tex instanceof Texture)\n        {\n            outTextures.push(tex);\n        }\n        // assume an object with extra data determining duplicate frame data\n        else\n        {\n            let dupe = tex.count || 1;\n\n            if (typeof tex.texture === 'string')\n            {\n                tex = GetTextureFromString(tex.texture);\n            }\n            else// if(tex.texture instanceof Texture)\n            {\n                tex = tex.texture;\n            }\n            for (; dupe > 0; --dupe)\n            {\n                outTextures.push(tex);\n            }\n        }\n    }\n\n    return outTextures;\n}\n\n/**\n * A Texture behavior that picks a random animation for each particle to play.\n * See {@link AnimatedParticleArt} for detailed configuration info.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'animatedRandom',\n *     config: {\n *         anims: [\n *              {\n *                  framerate: 25,\n *                  loop: true,\n *                  textures: ['frame1', 'frame2', 'frame3']\n *              },\n *              {\n *                  framerate: 25,\n *                  loop: true,\n *                  textures: ['frame3', 'frame2', 'frame1']\n *              }\n *         ],\n *     }\n * }\n * ```\n */\nexport class RandomAnimatedTextureBehavior implements IEmitterBehavior\n{\n    public static type = 'animatedRandom';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private anims: ParsedAnimatedParticleArt[];\n    constructor(config: {\n        /**\n         * Animation configuration to use for each particle, randomly chosen from the list.\n         */\n        anims: AnimatedParticleArt[];\n    })\n    {\n        this.anims = [];\n        for (let i = 0; i < config.anims.length; ++i)\n        {\n            const anim = config.anims[i];\n            const textures = getTextures(anim.textures);\n            // eslint-disable-next-line no-nested-ternary\n            const framerate = anim.framerate < 0 ? -1 : (anim.framerate > 0 ? anim.framerate : 60);\n            const parsedAnim: ParsedAnimatedParticleArt = {\n                textures,\n                duration: framerate > 0 ? textures.length / framerate : 0,\n                framerate,\n                loop: framerate > 0 ? !!anim.loop : false,\n            };\n\n            this.anims.push(parsedAnim);\n        }\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            const index = Math.floor(Math.random() * this.anims.length);\n            const anim = next.config.anim = this.anims[index];\n\n            next.texture = anim.textures[0];\n            next.config.animElapsed = 0;\n            // if anim should match particle life exactly\n            if (anim.framerate === -1)\n            {\n                next.config.animDuration = next.maxLife;\n                next.config.animFramerate = anim.textures.length / next.maxLife;\n            }\n            else\n            {\n                next.config.animDuration = anim.duration;\n                next.config.animFramerate = anim.framerate;\n            }\n\n            next = next.next;\n        }\n    }\n\n    updateParticle(particle: Particle, deltaSec: number): void\n    {\n        const config = particle.config;\n        const anim = config.anim;\n\n        config.animElapsed += deltaSec;\n        if (config.animElapsed >= config.animDuration)\n        {\n            // loop elapsed back around\n            if (config.anim.loop)\n            {\n                config.animElapsed = config.animElapsed % config.animDuration;\n            }\n            // subtract a small amount to prevent attempting to go past the end of the animation\n            else\n            {\n                config.animElapsed = config.animDuration - 0.000001;\n            }\n        }\n        // add a very small number to the frame and then floor it to avoid\n        // the frame being one short due to floating point errors.\n        const frame = ((config.animElapsed * config.animFramerate) + 0.0000001) | 0;\n\n        // in the very rare case that framerate * elapsed math ends up going past the end, use the last texture\n        particle.texture = anim.textures[frame] || anim.textures[anim.textures.length - 1] || Texture.EMPTY;\n    }\n}\n\n/**\n * A Texture behavior that uses a single animation for each particle to play.\n * See {@link AnimatedParticleArt} for detailed configuration info.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'animatedSingle',\n *     config: {\n *         anim: {\n *              framerate: 25,\n *              loop: true,\n *              textures: ['frame1', 'frame2', 'frame3']\n *         }\n *     }\n * }\n * ```\n */\nexport class SingleAnimatedTextureBehavior implements IEmitterBehavior\n{\n    public static type = 'animatedSingle';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private anim: ParsedAnimatedParticleArt;\n    constructor(config: {\n        /**\n         * Animation configuration to use for each particle.\n         */\n        anim: AnimatedParticleArt;\n    })\n    {\n        const anim = config.anim;\n        const textures = getTextures(anim.textures);\n        // eslint-disable-next-line no-nested-ternary\n        const framerate = anim.framerate < 0 ? -1 : (anim.framerate > 0 ? anim.framerate : 60);\n\n        this.anim = {\n            textures,\n            duration: framerate > 0 ? textures.length / framerate : 0,\n            framerate,\n            loop: framerate > 0 ? !!anim.loop : false,\n        };\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n        const anim = this.anim;\n\n        while (next)\n        {\n            next.texture = anim.textures[0];\n            next.config.animElapsed = 0;\n            // if anim should match particle life exactly\n            if (anim.framerate === -1)\n            {\n                next.config.animDuration = next.maxLife;\n                next.config.animFramerate = anim.textures.length / next.maxLife;\n            }\n            else\n            {\n                next.config.animDuration = anim.duration;\n                next.config.animFramerate = anim.framerate;\n            }\n\n            next = next.next;\n        }\n    }\n\n    updateParticle(particle: Particle, deltaSec: number): void\n    {\n        const anim = this.anim;\n        const config = particle.config;\n\n        config.animElapsed += deltaSec;\n        if (config.animElapsed >= config.animDuration)\n        {\n            // loop elapsed back around\n            if (anim.loop)\n            {\n                config.animElapsed = config.animElapsed % config.animDuration;\n            }\n            // subtract a small amount to prevent attempting to go past the end of the animation\n            else\n            {\n                config.animElapsed = config.animDuration - 0.000001;\n            }\n        }\n        // add a very small number to the frame and then floor it to avoid\n        // the frame being one short due to floating point errors.\n        const frame = ((config.animElapsed * config.animFramerate) + 0.0000001) | 0;\n\n        // in the very rare case that framerate * elapsed math ends up going past the end, use the last texture\n        particle.texture = anim.textures[frame] || anim.textures[anim.textures.length - 1] || Texture.EMPTY;\n    }\n}\n","import { Particle } from '../Particle';\nimport { getBlendMode } from '../ParticleUtils';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * A Blend Mode behavior that applies a blend mode value to the particle at initialization.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'blendMode',\n *     config: {\n *         blendMode: 'multiply',\n *     }\n * }\n * ```\n */\nexport class BlendModeBehavior implements IEmitterBehavior\n{\n    public static type = 'blendMode';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private value: string;\n    constructor(config: {\n        /**\n         * Blend mode of all particles. This value is a key from\n         * [PixiJs's BLEND_MODE enum](https://pixijs.download/release/docs/PIXI.html#BLEND_MODES).\n         */\n        blendMode: string;\n    })\n    {\n        this.value = config.blendMode;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            next.blendMode = getBlendMode(this.value);\n            next = next.next;\n        }\n    }\n}\n","import { Particle } from '../Particle';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { DEG_TO_RADS, rotatePoint } from '../ParticleUtils';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * A Spawn behavior that sends particles out from a single point or ring, and is capable of evenly spacing\n * the particle's starting angles.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'spawnBurst',\n *     config: {\n *          spacing: 90,\n *          start: 0,\n *          distance: 40,\n *     }\n * }\n * ```\n */\nexport class BurstSpawnBehavior implements IEmitterBehavior\n{\n    public static type = 'spawnBurst';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    order = BehaviorOrder.Spawn;\n    private spacing: number;\n    private start: number;\n    private distance: number;\n\n    constructor(config: {\n        /**\n         * Description: Spacing between each particle spawned in a wave, in degrees.\n         */\n        spacing: number;\n        /**\n         * Description: Angle to start placing particles at, in degrees. 0 is facing right, 90 is facing upwards.\n         */\n        start: number;\n        /**\n         * Description: Distance from the emitter to spawn particles, forming a ring/arc.\n         */\n        distance: number;\n    })\n    {\n        this.spacing = config.spacing * DEG_TO_RADS;\n        this.start = config.start * DEG_TO_RADS;\n        this.distance = config.distance;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let count = 0;\n        let next = first;\n\n        while (next)\n        {\n            let angle: number;\n\n            if (this.spacing)\n            {\n                angle = this.start + (this.spacing * count);\n            }\n            else\n            {\n                angle = Math.random() * Math.PI * 2;\n            }\n\n            next.rotation = angle;\n            if (this.distance)\n            {\n                next.position.x = this.distance;\n                rotatePoint(angle, next.position);\n            }\n            next = next.next;\n            ++count;\n        }\n    }\n}\n","import { Particle } from '../Particle';\nimport { Color, combineRGBComponents } from '../ParticleUtils';\nimport { PropertyList } from '../PropertyList';\nimport { PropertyNode, ValueList } from '../PropertyNode';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * A Color behavior that applies an interpolated or stepped list of values to the particle's tint property.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'color',\n *     config: {\n *         color: {\n *              list: [{value: '#ff0000' time: 0}, {value: '#00ff00', time: 0.5}, {value: '#0000ff', time: 1}]\n *         },\n *     }\n * }\n * ```\n */\nexport class ColorBehavior implements IEmitterBehavior\n{\n    public static type = 'color';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private list: PropertyList<Color>;\n    constructor(config: {\n        /**\n         * Color of the particles as 6 digit hex codes.\n         */\n        color: ValueList<string>;\n    })\n    {\n        this.list = new PropertyList(true);\n        this.list.reset(PropertyNode.createList(config.color));\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n        const color = this.list.first.value;\n        const tint = combineRGBComponents(color.r, color.g, color.b);\n\n        while (next)\n        {\n            next.tint = tint;\n            next = next.next;\n        }\n    }\n\n    updateParticle(particle: Particle): void\n    {\n        particle.tint = this.list.interpolate(particle.agePercent);\n    }\n}\n\n/**\n * A Color behavior that applies a single color to the particle's tint property at initialization.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'colorStatic',\n *     config: {\n *         color: '#ffff00',\n *     }\n * }\n * ```\n */\nexport class StaticColorBehavior implements IEmitterBehavior\n{\n    public static type = 'colorStatic';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private value: number;\n    constructor(config: {\n        /**\n         * Color of the particles as 6 digit hex codes.\n         */\n        color: string;\n    })\n    {\n        let color = config.color;\n\n        if (color.charAt(0) === '#')\n        {\n            color = color.substr(1);\n        }\n        else if (color.indexOf('0x') === 0)\n        {\n            color = color.substr(2);\n        }\n\n        this.value = parseInt(color, 16);\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            next.tint = this.value;\n            next = next.next;\n        }\n    }\n}\n","import { Texture } from '@pixi/core';\nimport { Particle } from '../Particle';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { GetTextureFromString } from '../ParticleUtils';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * A Texture behavior that assigns a texture to each particle from its list, in order, before looping around to the first\n * texture again. String values will be converted to textures with {@link ParticleUtils.GetTextureFromString}.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'textureOrdered',\n *     config: {\n *         textures: [\"myTex1Id\", \"myTex2Id\", \"myTex3Id\", \"myTex4Id\"],\n *     }\n * }\n * ```\n */\nexport class OrderedTextureBehavior implements IEmitterBehavior\n{\n    public static type = 'textureOrdered';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private textures: Texture[];\n    private index: number;\n    constructor(config: {\n        /**\n         * Images to use for each particle, used in order before looping around\n         */\n        textures: Texture[];\n    })\n    {\n        this.index = 0;\n        this.textures = config.textures.map((tex) => (typeof tex === 'string' ? GetTextureFromString(tex) : tex));\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            next.texture = this.textures[this.index];\n            if (++this.index >= this.textures.length)\n            {\n                this.index = 0;\n            }\n            next = next.next;\n        }\n    }\n}\n","import { Point } from '@pixi/math';\nimport { Particle } from '../Particle';\nimport { rotatePoint, verbose } from '../ParticleUtils';\nimport { PropertyList } from '../PropertyList';\nimport { PropertyNode, ValueList } from '../PropertyNode';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * A helper point for math things.\n * @hidden\n */\nconst helperPoint = new Point();\n\n/**\n * A hand picked list of Math functions (and a couple properties) that are\n * allowable. They should be used without the preceding \"Math.\"\n * @hidden\n */\nconst MATH_FUNCS = [\n    'E',\n    'LN2',\n    'LN10',\n    'LOG2E',\n    'LOG10E',\n    'PI',\n    'SQRT1_2',\n    'SQRT2',\n    'abs',\n    'acos',\n    'acosh',\n    'asin',\n    'asinh',\n    'atan',\n    'atanh',\n    'atan2',\n    'cbrt',\n    'ceil',\n    'cos',\n    'cosh',\n    'exp',\n    'expm1',\n    'floor',\n    'fround',\n    'hypot',\n    'log',\n    'log1p',\n    'log10',\n    'log2',\n    'max',\n    'min',\n    'pow',\n    'random',\n    'round',\n    'sign',\n    'sin',\n    'sinh',\n    'sqrt',\n    'tan',\n    'tanh',\n];\n/**\n * create an actual regular expression object from the string\n * @hidden\n */\nconst WHITELISTER = new RegExp(\n    [\n        // Allow the 4 basic operations, parentheses and all numbers/decimals, as well\n        // as 'x', for the variable usage.\n        '[01234567890\\\\.\\\\*\\\\-\\\\+\\\\/\\\\(\\\\)x ,]',\n    ].concat(MATH_FUNCS).join('|'),\n    'g',\n);\n\n/**\n * Parses a string into a function for path following.\n * This involves whitelisting the string for safety, inserting \"Math.\" to math function\n * names, and using `new Function()` to generate a function.\n * @hidden\n * @param pathString The string to parse.\n * @return The path function - takes x, outputs y.\n */\nfunction parsePath(pathString: string): (x: number) => number\n{\n    const matches = pathString.match(WHITELISTER);\n\n    for (let i = matches.length - 1; i >= 0; --i)\n    {\n        if (MATH_FUNCS.indexOf(matches[i]) >= 0)\n        { matches[i] = `Math.${matches[i]}`; }\n    }\n    pathString = matches.join('');\n\n    // eslint-disable-next-line no-new-func\n    return new Function('x', `return ${pathString};`) as (x: number) => number;\n}\n\n/**\n * A particle that follows a path defined by an algebraic expression, e.g. \"sin(x)\" or\n * \"5x + 3\".\n * To use this class, the behavior config must have a \"path\" string or function.\n *\n * A string should have \"x\" in it to represent movement (from the\n * speed settings of the behavior). It may have numbers, parentheses, the four basic\n * operations, and any Math functions or properties (without the preceding \"Math.\").\n * The overall movement of the particle and the expression value become x and y positions for\n * the particle, respectively. The final position is rotated by the spawn rotation/angle of\n * the particle.\n *\n * A function merely needs to accept the \"x\" argument and output the a corresponding \"y\" value.\n *\n * Some example paths:\n *\n * * `\"sin(x/10) * 20\"` A sine wave path.\n * * `\"cos(x/100) * 30\"` Particles curve counterclockwise (for medium speed/low lifetime particles)\n * * `\"pow(x/10, 2) / 2\"` Particles curve clockwise (remember, +y is down).\n * * `(x) => Math.floor(x) * 3` Supplying an existing function should look like this\n *\n * Example configuration:\n * ```javascript\n * {\n *     \"type\": \"movePath\",\n *     \"config\": {\n *          \"path\": \"round(sin(x) * 2\",\n *          \"speed\": {\n *              \"list\": [{value: 10, time: 0}, {value: 100, time: 0.25}, {value: 0, time: 1}],\n *          },\n *          \"minMult\": 0.8\n *     }\n *}\n */\nexport class PathBehavior implements IEmitterBehavior\n{\n    public static type = 'movePath';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    // *MUST* happen after other behaviors do initialization so that we can read initial transformations\n    public order = BehaviorOrder.Late;\n    /**\n     * The function representing the path the particle should take.\n     */\n    private path: (x: number) => number;\n    private list: PropertyList<number>;\n    private minMult: number;\n    constructor(config: {\n        /**\n         * Algebraic expression describing the movement of the particle.\n         */\n        path: string|((x: number) => number);\n        /**\n         * Speed of the particles in world units/second. This affects the x value in the path.\n         * Unlike normal speed movement, this can have negative values.\n         */\n        speed: ValueList<number>;\n        /**\n         * A value between minimum speed multipler and 1 is randomly generated and multiplied\n         * with each speed value to generate the actual speed for each particle.\n         */\n        minMult: number;\n    })\n    {\n        if (config.path)\n        {\n            if (typeof config.path === 'function')\n            {\n                this.path = config.path;\n            }\n            else\n            {\n                try\n                {\n                    this.path = parsePath(config.path);\n                }\n                catch (e)\n                {\n                    if (verbose)\n                    {\n                        console.error('PathParticle: error in parsing path expression', e);\n                    }\n                    this.path = null;\n                }\n            }\n        }\n        else\n        {\n            if (verbose)\n            {\n                console.error('PathParticle requires a path value in its config!');\n            }\n            // eslint-disable-next-line @typescript-eslint/explicit-function-return-type\n            this.path = (x) => x;\n        }\n        this.list = new PropertyList(false);\n        this.list.reset(PropertyNode.createList(config.speed));\n        this.minMult = config.minMult ?? 1;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            /*\n             * The initial rotation in degrees of the particle, because the direction of the path\n             * is based on that.\n             */\n            next.config.initRotation = next.rotation;\n            /* The initial position of the particle, as all path movement is added to that. */\n            if (!next.config.initPosition)\n            {\n                next.config.initPosition = new Point(next.x, next.y);\n            }\n            else\n            {\n                (next.config.initPosition as Point).copyFrom(next.position);\n            }\n            /* Total single directional movement, due to speed. */\n            next.config.movement = 0;\n\n            // also do speed multiplier, since this includes basic speed movement\n            const mult = (Math.random() * (1 - this.minMult)) + this.minMult;\n\n            next.config.speedMult = mult;\n\n            next = next.next;\n        }\n    }\n\n    updateParticle(particle: Particle, deltaSec: number): void\n    {\n        // increase linear movement based on speed\n        const speed = this.list.interpolate(particle.agePercent) * particle.config.speedMult;\n\n        particle.config.movement += speed * deltaSec;\n        // set up the helper point for rotation\n        helperPoint.x = particle.config.movement;\n        helperPoint.y = this.path(helperPoint.x);\n        rotatePoint(particle.config.initRotation, helperPoint);\n        particle.position.x = particle.config.initPosition.x + helperPoint.x;\n        particle.position.y = particle.config.initPosition.y + helperPoint.y;\n    }\n}\n","import { Particle } from '../Particle';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * A Spawn behavior that sends particles out from a single point at the emitter's position.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'spawnPoint',\n *     config: {}\n * }\n * ```\n */\nexport class PointSpawnBehavior implements IEmitterBehavior\n{\n    public static type = 'spawnPoint';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    order = BehaviorOrder.Spawn;\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    initParticles(_first: Particle): void\n    {\n        // really just a no-op\n    }\n}\n","import { Texture } from '@pixi/core';\nimport { Particle } from '../Particle';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { GetTextureFromString } from '../ParticleUtils';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * A Texture behavior that assigns a random texture to each particle from its list.\n * String values will be converted to textures with {@link ParticleUtils.GetTextureFromString}.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'textureRandom',\n *     config: {\n *         textures: [\"myTex1Id\", \"myTex2Id\", \"myTex3Id\", \"myTex4Id\"],\n *     }\n * }\n * ```\n */\nexport class RandomTextureBehavior implements IEmitterBehavior\n{\n    public static type = 'textureRandom';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private textures: Texture[];\n    constructor(config: {\n        /**\n         * Images to use for each particle, randomly chosen from the list.\n         */\n        textures: (Texture|string)[];\n    })\n    {\n        this.textures = config.textures.map((tex) => (typeof tex === 'string' ? GetTextureFromString(tex) : tex));\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            const index = Math.floor(Math.random() * this.textures.length);\n\n            next.texture = this.textures[index];\n\n            next = next.next;\n        }\n    }\n}\n","import { Particle } from '../Particle';\nimport { DEG_TO_RADS } from '../ParticleUtils';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * A Rotation behavior that handles starting rotation, rotation speed, and rotational acceleration.\n *\n * Example configuration:\n * ```javascript\n * {\n *     \"type\": \"rotation\",\n *     \"config\": {\n *          \"minStart\": 0,\n *          \"maxStart\": 180,\n *          \"minSpeed\": 30,\n *          \"maxSpeed\": 45,\n *          \"accel\": 20\n *     }\n *}\n * ```\n */\nexport class RotationBehavior implements IEmitterBehavior\n{\n    public static type = 'rotation';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private minStart: number;\n    private maxStart: number;\n    private minSpeed: number;\n    private maxSpeed: number;\n    private accel: number;\n    constructor(config: {\n        /**\n         * Minimum starting rotation of the particles, in degrees. 0 is facing right, 90 is upwards.\n         */\n        minStart: number;\n        /**\n         * Maximum starting rotation of the particles, in degrees. 0 is facing right, 90 is upwards.\n         */\n        maxStart: number;\n        /**\n         * Minimum rotation speed of the particles, in degrees/second. Positive is counter-clockwise.\n         */\n        minSpeed: number;\n        /**\n         * Maximum rotation speed of the particles, in degrees/second. Positive is counter-clockwise.\n         */\n        maxSpeed: number;\n        /**\n         * Constant rotational acceleration of the particles, in degrees/second/second.\n         */\n        accel: number;\n    })\n    {\n        this.minStart = config.minStart * DEG_TO_RADS;\n        this.maxStart = config.maxStart * DEG_TO_RADS;\n        this.minSpeed = config.minSpeed * DEG_TO_RADS;\n        this.maxSpeed = config.maxSpeed * DEG_TO_RADS;\n        this.accel = config.accel * DEG_TO_RADS;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            if (this.minStart === this.maxStart)\n            {\n                next.rotation += this.maxStart;\n            }\n            else\n            {\n                next.rotation += (Math.random() * (this.maxStart - this.minStart)) + this.minStart;\n            }\n            next.config.rotSpeed = (Math.random() * (this.maxSpeed - this.minSpeed)) + this.minSpeed;\n\n            next = next.next;\n        }\n    }\n\n    updateParticle(particle: Particle, deltaSec: number): void\n    {\n        if (this.accel)\n        {\n            const oldSpeed = particle.config.rotSpeed;\n\n            particle.config.rotSpeed += this.accel * deltaSec;\n            particle.rotation += (particle.config.rotSpeed + oldSpeed) / 2 * deltaSec;\n        }\n        else\n        {\n            particle.rotation += particle.config.rotSpeed * deltaSec;\n        }\n    }\n}\n\n/**\n * A Rotation behavior that handles starting rotation.\n *\n * Example configuration:\n * ```javascript\n * {\n *     \"type\": \"rotationStatic\",\n *     \"config\": {\n *          \"min\": 0,\n *          \"max\": 180,\n *     }\n *}\n * ```\n */\nexport class StaticRotationBehavior implements IEmitterBehavior\n{\n    public static type = 'rotationStatic';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private min: number;\n    private max: number;\n    constructor(config: {\n        /**\n         * Minimum starting rotation of the particles, in degrees. 0 is facing right, 90 is upwards.\n         */\n        min: number;\n        /**\n         * Maximum starting rotation of the particles, in degrees. 0 is facing right, 90 is upwards.\n         */\n        max: number;\n    })\n    {\n        this.min = config.min * DEG_TO_RADS;\n        this.max = config.max * DEG_TO_RADS;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            if (this.min === this.max)\n            {\n                next.rotation += this.max;\n            }\n            else\n            {\n                next.rotation += (Math.random() * (this.max - this.min)) + this.min;\n            }\n\n            next = next.next;\n        }\n    }\n}\n\n/**\n * A Rotation behavior that blocks all rotation caused by spawn settings,\n * by resetting it to the specified rotation (or 0).\n *\n * Example configuration:\n * ```javascript\n * {\n *     \"type\": \"noRotation\",\n *     \"config\": {\n *          \"rotation\": 0\n *     }\n *}\n * ```\n */\nexport class NoRotationBehavior implements IEmitterBehavior\n{\n    public static type = 'noRotation';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Late + 1;\n\n    private rotation: number;\n    constructor(config: {\n        /**\n         * Locked rotation of the particles, in degrees. 0 is facing right, 90 is upwards.\n         */\n        rotation?: number;\n    })\n    {\n        this.rotation = (config.rotation || 0) * DEG_TO_RADS;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            next.rotation = this.rotation;\n\n            next = next.next;\n        }\n    }\n}\n","import { Particle } from '../Particle';\nimport { PropertyList } from '../PropertyList';\nimport { PropertyNode, ValueList } from '../PropertyNode';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * A Scale behavior that applies an interpolated or stepped list of values to the particle's x & y scale.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'scale',\n *     config: {\n *          scale: {\n *              list: [{value: 0, time: 0}, {value: 1, time: 0.25}, {value: 0, time: 1}],\n *              isStepped: true\n *          },\n *          minMult: 0.5\n *     }\n * }\n * ```\n */\nexport class ScaleBehavior implements IEmitterBehavior\n{\n    public static type = 'scale';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private list: PropertyList<number>;\n    private minMult: number;\n    constructor(config: {\n        /**\n         * Scale of the particles, with a minimum value of 0\n         */\n        scale: ValueList<number>;\n        /**\n         * A value between minimum scale multipler and 1 is randomly\n         * generated and multiplied with each scale value to provide the actual scale for each particle.\n         */\n        minMult: number;\n    })\n    {\n        this.list = new PropertyList(false);\n        this.list.reset(PropertyNode.createList(config.scale));\n        this.minMult = config.minMult ?? 1;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            const mult = (Math.random() * (1 - this.minMult)) + this.minMult;\n\n            next.config.scaleMult = mult;\n            next.scale.x = next.scale.y = this.list.first.value * mult;\n\n            next = next.next;\n        }\n    }\n\n    updateParticle(particle: Particle): void\n    {\n        particle.scale.x = particle.scale.y = this.list.interpolate(particle.agePercent) * particle.config.scaleMult;\n    }\n}\n\n/**\n * A Scale behavior that applies a randomly picked value to the particle's x & y scale at initialization.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'scaleStatic',\n *     config: {\n *         min: 0.25,\n *         max: 0.75,\n *     }\n * }\n * ```\n */\nexport class StaticScaleBehavior implements IEmitterBehavior\n{\n    public static type = 'scaleStatic';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private min: number;\n    private max: number;\n    constructor(config: {\n        /**\n         * Minimum scale of the particles, with a minimum value of 0\n         */\n        min: number;\n        /**\n         * Maximum scale of the particles, with a minimum value of 0\n         */\n        max: number;\n    })\n    {\n        this.min = config.min;\n        this.max = config.max;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            const scale = (Math.random() * (this.max - this.min)) + this.min;\n\n            next.scale.x = next.scale.y = scale;\n\n            next = next.next;\n        }\n    }\n}\n","import { Particle } from '../Particle';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { SpawnShape, SpawnShapeClass } from './shapes/SpawnShape';\nimport { PolygonalChain } from './shapes/PolygonalChain';\nimport { Rectangle } from './shapes/Rectangle';\nimport { Torus } from './shapes/Torus';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * A Spawn behavior that places (and optionally rotates) particles according to a\n * specified shape. Additional shapes can be registered with {@link registerShape | SpawnShape.registerShape()}.\n * Additional shapes must implement the {@link SpawnShape} interface, and their class must match the\n * {@link SpawnShapeClass} interface.\n * Shapes included by default are:\n * * {@link Rectangle}\n * * {@link Torus}\n * * {@link PolygonalChain}\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'spawnShape',\n *     config: {\n *          type: 'rect',\n *          data: {\n *              x: 0,\n *              y: 0,\n *              width: 20,\n *              height: 300,\n *          }\n *     }\n * }\n * ```\n */\nexport class ShapeSpawnBehavior implements IEmitterBehavior\n{\n    public static type = 'spawnShape';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    /**\n     * Dictionary of all registered shape classes.\n     */\n    private static shapes: {[key: string]: SpawnShapeClass} = {};\n\n    /**\n     * Registers a shape to be used by the ShapeSpawn behavior.\n     * @param constructor The shape class constructor to use, with a static `type` property to reference it by.\n     * @param typeOverride An optional type override, primarily for registering a shape under multiple names.\n     */\n    public static registerShape(constructor: SpawnShapeClass, typeOverride?: string): void\n    {\n        ShapeSpawnBehavior.shapes[typeOverride || constructor.type] = constructor;\n    }\n\n    order = BehaviorOrder.Spawn;\n    private shape: SpawnShape;\n\n    constructor(config: {\n        /**\n         * Type of the shape to spawn\n         */\n        type: string;\n        /**\n         * Configuration data for the spawn shape.\n         */\n        data: any;\n    })\n    {\n        const ShapeClass = ShapeSpawnBehavior.shapes[config.type];\n\n        if (!ShapeClass)\n        {\n            throw new Error(`No shape found with type '${config.type}'`);\n        }\n        this.shape = new ShapeClass(config.data);\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            this.shape.getRandPos(next);\n            next = next.next;\n        }\n    }\n}\n\nShapeSpawnBehavior.registerShape(PolygonalChain);\nShapeSpawnBehavior.registerShape(Rectangle);\nShapeSpawnBehavior.registerShape(Torus);\nShapeSpawnBehavior.registerShape(Torus, 'circle');\n","import { Texture } from '@pixi/core';\nimport { Particle } from '../Particle';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { GetTextureFromString } from '../ParticleUtils';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * A Textuure behavior that assigns a single texture to each particle.\n * String values will be converted to textures with {@link ParticleUtils.GetTextureFromString}.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'textureSingle',\n *     config: {\n *         texture: Texture.from('myTexId'),\n *     }\n * }\n * ```\n */\nexport class SingleTextureBehavior implements IEmitterBehavior\n{\n    public static type = 'textureSingle';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private texture: Texture;\n    constructor(config: {\n        /**\n         * Image to use for each particle.\n         */\n        texture: Texture|string;\n    })\n    {\n        this.texture = typeof config.texture === 'string' ? GetTextureFromString(config.texture) : config.texture;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            next.texture = this.texture;\n\n            next = next.next;\n        }\n    }\n}\n","import { Point } from '@pixi/math';\nimport { Particle } from '../Particle';\nimport { rotatePoint, normalize, scaleBy } from '../ParticleUtils';\nimport { PropertyList } from '../PropertyList';\nimport { PropertyNode, ValueList } from '../PropertyNode';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * A Movement behavior that uses an interpolated or stepped list of values for a particles speed at any given moment.\n * Movement direction is controlled by the particle's starting rotation.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'moveSpeed',\n *     config: {\n *          speed: {\n *              list: [{value: 10, time: 0}, {value: 100, time: 0.25}, {value: 0, time: 1}],\n *          },\n *          minMult: 0.8\n *     }\n * }\n * ```\n */\nexport class SpeedBehavior implements IEmitterBehavior\n{\n    public static type = 'moveSpeed';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Late;\n    private list: PropertyList<number>;\n    private minMult: number;\n    constructor(config: {\n        /**\n         * Speed of the particles in world units/second, with a minimum value of 0\n         */\n        speed: ValueList<number>;\n        /**\n         * A value between minimum speed multipler and 1 is randomly\n         * generated and multiplied with each speed value to generate the actual speed for each particle.\n         */\n        minMult: number;\n    })\n    {\n        this.list = new PropertyList(false);\n        this.list.reset(PropertyNode.createList(config.speed));\n        this.minMult = config.minMult ?? 1;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            const mult = (Math.random() * (1 - this.minMult)) + this.minMult;\n\n            next.config.speedMult = mult;\n            if (!next.config.velocity)\n            {\n                next.config.velocity = new Point(this.list.first.value * mult, 0);\n            }\n            else\n            {\n                (next.config.velocity as Point).set(this.list.first.value * mult, 0);\n            }\n\n            rotatePoint(next.rotation, next.config.velocity);\n\n            next = next.next;\n        }\n    }\n\n    updateParticle(particle: Particle, deltaSec: number): void\n    {\n        const speed = this.list.interpolate(particle.agePercent) * particle.config.speedMult;\n        const vel = particle.config.velocity;\n\n        normalize(vel);\n        scaleBy(vel, speed);\n        particle.x += vel.x * deltaSec;\n        particle.y += vel.y * deltaSec;\n    }\n}\n\n/**\n * A Movement behavior that uses a randomly picked constant speed throughout a particle's lifetime.\n * Movement direction is controlled by the particle's starting rotation.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'moveSpeedStatic',\n *     config: {\n *          min: 100,\n *          max: 150\n *     }\n * }\n * ```\n */\nexport class StaticSpeedBehavior implements IEmitterBehavior\n{\n    public static type = 'moveSpeedStatic';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Late;\n    private min: number;\n    private max: number;\n    constructor(config: {\n        /**\n         * Minimum speed when initializing the particle.\n         */\n        min: number;\n        /**\n         * Maximum speed when initializing the particle.\n         */\n        max: number;\n    })\n    {\n        this.min = config.min;\n        this.max = config.max;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            const speed = (Math.random() * (this.max - this.min)) + this.min;\n\n            if (!next.config.velocity)\n            {\n                next.config.velocity = new Point(speed, 0);\n            }\n            else\n            {\n                (next.config.velocity as Point).set(speed, 0);\n            }\n\n            rotatePoint(next.rotation, next.config.velocity);\n\n            next = next.next;\n        }\n    }\n\n    updateParticle(particle: Particle, deltaSec: number): void\n    {\n        const velocity = particle.config.velocity;\n\n        particle.x += velocity.x * deltaSec;\n        particle.y += velocity.y * deltaSec;\n    }\n}\n","// export support types for external use\nimport * as spawnShapes from './shapes';\nexport { spawnShapes };\nexport * from './Behaviors';\n\nimport * as editor from './editor/Types';\nexport { editor };\n\n// export all of the individual behaviors\nexport * from './AccelerationMovement';\nexport * from './Alpha';\nexport * from './AnimatedTexture';\nexport * from './BlendMode';\nexport * from './BurstSpawn';\nexport * from './Color';\nexport * from './OrderedTexture';\nexport * from './PathMovement';\nexport * from './PointSpawn';\nexport * from './RandomTexture';\nexport * from './Rotation';\nexport * from './Scale';\nexport * from './ShapeSpawn';\nexport * from './SingleTexture';\nexport * from './SpeedMovement';\n","/* eslint-disable no-lonely-if */\nimport { EaseSegment, SimpleEase } from './ParticleUtils';\nimport { ValueList } from './PropertyNode';\nimport { IPointData } from '@pixi/math';\n\n/**\n * Full Emitter configuration for initializing an Emitter instance.\n */\nexport interface EmitterConfigV3\n{\n    /**\n     * Random number configuration for picking the lifetime for each particle..\n     */\n    lifetime: RandNumber;\n    /**\n     * Easing to be applied to all interpolated or stepped values across the particle lifetime.\n     */\n    ease?: SimpleEase | EaseSegment[];\n    /**\n     * How many particles to spawn at once, each time that it is determined that particles should be spawned.\n     * If omitted, only one particle will spawn at a time.\n     */\n    particlesPerWave?: number;\n    /**\n     * How often to spawn particles. This is a value in seconds, so a value of 0.5 would be twice a second.\n     */\n    frequency: number;\n    /**\n     * Defines a chance to not spawn particles. Values lower than 1 mean particles may not be spawned each time.\n     * If omitted, particles will always spawn.\n     */\n    spawnChance?: number;\n    /**\n     * How long to run the Emitter before it stops spawning particles. If omitted, runs forever (or until told to stop\n     * manually).\n     */\n    emitterLifetime?: number;\n    /**\n     * Maximum number of particles that can be alive at any given time for this emitter.\n     */\n    maxParticles?: number;\n    /**\n     * If newly spawned particles should be added to the back of the parent container (to make them less conspicuous\n     * as they pop in). If omitted, particles will be added to the top of the container.\n     */\n    addAtBack?: boolean;\n    /**\n     * Default position to spawn particles from inside the parent container.\n     */\n    pos: { x: number; y: number };\n    /**\n     * If the emitter should start out emitting particles. If omitted, it will be treated as `true` and will emit particles\n     * immediately.\n     */\n    emit?: boolean;\n    /**\n     * If the Emitter should hook into PixiJS's shared ticker. If this is false or emitted, you will be responsible for\n     * connecting it to update ticks.\n     */\n    autoUpdate?: boolean;\n\n    /**\n     * The list of behaviors to apply to this emitter. See the behaviors namespace for\n     * a list of built in behaviors. Custom behaviors may be registered with {@link Emitter.registerBehavior}.\n     */\n    behaviors: BehaviorEntry[];\n}\n\n/**\n * See {@link EmitterConfigV3.behaviors}\n */\nexport interface BehaviorEntry\n{\n    /**\n     * The behavior type, as defined as the static `type` property of a behavior class.\n     */\n    type: string;\n    /**\n     * Configuration data specific to that behavior.\n     */\n    config: any;\n}\n\n/**\n * Configuration for how to pick a random number (inclusive).\n */\nexport interface RandNumber\n{\n    /**\n     * Maximum pickable value.\n     */\n    max: number;\n    /**\n     * Minimum pickable value.\n     */\n    min: number;\n}\n\n/**\n * Converts emitter configuration from pre-5.0.0 library values into the current version.\n *\n * Example usage:\n * ```javascript\n * const emitter = new Emitter(myContainer, upgradeConfig(myOldConfig, [myTexture, myOtherTexture]));\n * ```\n * @param config The old emitter config to upgrade.\n * @param art The old art values as would have been passed into the Emitter constructor or `Emitter.init()`\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function upgradeConfig(config: EmitterConfigV2|EmitterConfigV1, art: any): EmitterConfigV3\n{\n    // just ensure we aren't given any V3 config data\n    if ('behaviors' in config)\n    {\n        return config;\n    }\n\n    const out: EmitterConfigV3 = {\n        lifetime: config.lifetime,\n        ease: config.ease,\n        particlesPerWave: config.particlesPerWave,\n        frequency: config.frequency,\n        spawnChance: config.spawnChance,\n        emitterLifetime: config.emitterLifetime,\n        maxParticles: config.maxParticles,\n        addAtBack: config.addAtBack,\n        pos: config.pos,\n        emit: config.emit,\n        autoUpdate: config.autoUpdate,\n        behaviors: [],\n    };\n\n    // set up the alpha\n    if (config.alpha)\n    {\n        if ('start' in config.alpha)\n        {\n            if (config.alpha.start === config.alpha.end)\n            {\n                if (config.alpha.start !== 1)\n                {\n                    out.behaviors.push({\n                        type: 'alphaStatic',\n                        config: { alpha: config.alpha.start },\n                    });\n                }\n            }\n            else\n            {\n                const list: ValueList<number> = {\n                    list: [\n                        { time: 0, value: config.alpha.start },\n                        { time: 1, value: config.alpha.end },\n                    ],\n                };\n\n                out.behaviors.push({\n                    type: 'alpha',\n                    config: { alpha: list },\n                });\n            }\n        }\n        else if (config.alpha.list.length === 1)\n        {\n            if (config.alpha.list[0].value !== 1)\n            {\n                out.behaviors.push({\n                    type: 'alphaStatic',\n                    config: { alpha: config.alpha.list[0].value },\n                });\n            }\n        }\n        else\n        {\n            out.behaviors.push({\n                type: 'alpha',\n                config: { alpha: config.alpha },\n            });\n        }\n    }\n\n    // acceleration movement\n    if (config.acceleration && (config.acceleration.x || config.acceleration.y))\n    {\n        let minStart: number;\n        let maxStart: number;\n\n        if ('start' in config.speed)\n        {\n            minStart = config.speed.start * (config.speed.minimumSpeedMultiplier ?? 1);\n            maxStart = config.speed.start;\n        }\n        else\n        {\n            minStart = config.speed.list[0].value * ((config as EmitterConfigV2).minimumSpeedMultiplier ?? 1);\n            maxStart = config.speed.list[0].value;\n        }\n\n        out.behaviors.push({\n            type: 'moveAcceleration',\n            config: {\n                accel: config.acceleration,\n                minStart,\n                maxStart,\n                rotate: !config.noRotation,\n                maxSpeed: config.maxSpeed,\n            },\n        });\n    }\n    // path movement\n    else if (config.extraData?.path)\n    {\n        let list: ValueList<number>;\n        let mult: number;\n\n        if ('start' in config.speed)\n        {\n            mult = config.speed.minimumSpeedMultiplier ?? 1;\n            if (config.speed.start === config.speed.end)\n            {\n                list = {\n                    list: [{ time: 0, value: config.speed.start }],\n                };\n            }\n            else\n            {\n                list = {\n                    list: [\n                        { time: 0, value: config.speed.start },\n                        { time: 1, value: config.speed.end },\n                    ],\n                };\n            }\n        }\n        else\n        {\n            list = config.speed;\n            mult = ((config as EmitterConfigV2).minimumSpeedMultiplier ?? 1);\n        }\n\n        out.behaviors.push({\n            type: 'movePath',\n            config: {\n                path: config.extraData.path,\n                speed: list,\n                minMult: mult,\n            },\n        });\n    }\n    // normal speed movement\n    else\n    {\n        if (config.speed)\n        {\n            if ('start' in config.speed)\n            {\n                if (config.speed.start === config.speed.end)\n                {\n                    out.behaviors.push({\n                        type: 'moveSpeedStatic',\n                        config: {\n                            min: config.speed.start * (config.speed.minimumSpeedMultiplier ?? 1),\n                            max: config.speed.start,\n                        },\n                    });\n                }\n                else\n                {\n                    const list: ValueList<number> = {\n                        list: [\n                            { time: 0, value: config.speed.start },\n                            { time: 1, value: config.speed.end },\n                        ],\n                    };\n\n                    out.behaviors.push({\n                        type: 'moveSpeed',\n                        config: { speed: list, minMult: config.speed.minimumSpeedMultiplier },\n                    });\n                }\n            }\n            else if (config.speed.list.length === 1)\n            {\n                out.behaviors.push({\n                    type: 'moveSpeedStatic',\n                    config: {\n                        min: config.speed.list[0].value * ((config as EmitterConfigV2).minimumSpeedMultiplier ?? 1),\n                        max: config.speed.list[0].value,\n                    },\n                });\n            }\n            else\n            {\n                out.behaviors.push({\n                    type: 'moveSpeed',\n                    config: { speed: config.speed, minMult: ((config as EmitterConfigV2).minimumSpeedMultiplier ?? 1) },\n                });\n            }\n        }\n    }\n\n    // scale\n    if (config.scale)\n    {\n        if ('start' in config.scale)\n        {\n            const mult = config.scale.minimumScaleMultiplier ?? 1;\n\n            if (config.scale.start === config.scale.end)\n            {\n                out.behaviors.push({\n                    type: 'scaleStatic',\n                    config: {\n                        min: config.scale.start * mult,\n                        max: config.scale.start,\n                    },\n                });\n            }\n            else\n            {\n                const list: ValueList<number> = {\n                    list: [\n                        { time: 0, value: config.scale.start },\n                        { time: 1, value: config.scale.end },\n                    ],\n                };\n\n                out.behaviors.push({\n                    type: 'scale',\n                    config: { scale: list, minMult: mult },\n                });\n            }\n        }\n        else if (config.scale.list.length === 1)\n        {\n            const mult = (config as EmitterConfigV2).minimumScaleMultiplier ?? 1;\n            const scale = config.scale.list[0].value;\n\n            out.behaviors.push({\n                type: 'scaleStatic',\n                config: { min: scale * mult, max: scale },\n            });\n        }\n        else\n        {\n            out.behaviors.push({\n                type: 'scale',\n                config: { scale: config.scale, minMult: (config as EmitterConfigV2).minimumScaleMultiplier ?? 1 },\n            });\n        }\n    }\n\n    // color\n    if (config.color)\n    {\n        if ('start' in config.color)\n        {\n            if (config.color.start === config.color.end)\n            {\n                if (config.color.start !== 'ffffff')\n                {\n                    out.behaviors.push({\n                        type: 'colorStatic',\n                        config: { color: config.color.start },\n                    });\n                }\n            }\n            else\n            {\n                const list: ValueList<string> = {\n                    list: [\n                        { time: 0, value: config.color.start },\n                        { time: 1, value: config.color.end },\n                    ],\n                };\n\n                out.behaviors.push({\n                    type: 'color',\n                    config: { color: list },\n                });\n            }\n        }\n        else if (config.color.list.length === 1)\n        {\n            if (config.color.list[0].value !== 'ffffff')\n            {\n                out.behaviors.push({\n                    type: 'colorStatic',\n                    config: { color: config.color.list[0].value },\n                });\n            }\n        }\n        else\n        {\n            out.behaviors.push({\n                type: 'color',\n                config: { color: config.color },\n            });\n        }\n    }\n\n    // rotation\n    if (config.rotationAcceleration || config.rotationSpeed?.min || config.rotationSpeed?.max)\n    {\n        out.behaviors.push({\n            type: 'rotation',\n            config: {\n                accel: config.rotationAcceleration || 0,\n                minSpeed: config.rotationSpeed?.min || 0,\n                maxSpeed: config.rotationSpeed?.max || 0,\n                minStart: config.startRotation?.min || 0,\n                maxStart: config.startRotation?.max || 0,\n            },\n        });\n    }\n    else if (config.startRotation?.min || config.startRotation?.max)\n    {\n        out.behaviors.push({\n            type: 'rotationStatic',\n            config: {\n                min: config.startRotation?.min || 0,\n                max: config.startRotation?.max || 0,\n            },\n        });\n    }\n    if (config.noRotation)\n    {\n        out.behaviors.push({\n            type: 'noRotation',\n            config: {},\n        });\n    }\n\n    // blend mode\n    if (config.blendMode && config.blendMode !== 'normal')\n    {\n        out.behaviors.push({\n            type: 'blendMode',\n            config: {\n                blendMode: config.blendMode,\n            },\n        });\n    }\n\n    // animated\n    if (Array.isArray(art) && typeof art[0] !== 'string' && 'framerate' in art[0])\n    {\n        for (let i = 0; i < art.length; ++i)\n        {\n            if (art[i].framerate === 'matchLife')\n            {\n                art[i].framerate = -1;\n            }\n        }\n        out.behaviors.push({\n            type: 'animatedRandom',\n            config: {\n                anims: art,\n            },\n        });\n    }\n    else if (typeof art !== 'string' && 'framerate' in art)\n    {\n        if (art.framerate === 'matchLife')\n        {\n            art.framerate = -1;\n        }\n        out.behaviors.push({\n            type: 'animatedSingle',\n            config: {\n                anim: art,\n            },\n        });\n    }\n    // ordered art\n    else if (config.orderedArt && Array.isArray(art))\n    {\n        out.behaviors.push({\n            type: 'textureOrdered',\n            config: {\n                textures: art,\n            },\n        });\n    }\n    // random texture\n    else if (Array.isArray(art))\n    {\n        out.behaviors.push({\n            type: 'textureRandom',\n            config: {\n                textures: art,\n            },\n        });\n    }\n    // single texture\n    else\n    {\n        out.behaviors.push({\n            type: 'textureSingle',\n            config: {\n                texture: art,\n            },\n        });\n    }\n\n    // spawn burst\n    if (config.spawnType === 'burst')\n    {\n        out.behaviors.push({\n            type: 'spawnBurst',\n            config: {\n                start: config.angleStart || 0,\n                spacing: config.particleSpacing,\n                // older formats bursted from a single point\n                distance: 0,\n            },\n        });\n    }\n    // spawn point\n    else if (config.spawnType === 'point')\n    {\n        out.behaviors.push({\n            type: 'spawnPoint',\n            config: {},\n        });\n    }\n    // spawn shape\n    else\n    {\n        let shape: any;\n\n        if (config.spawnType === 'ring')\n        {\n            shape = {\n                type: 'torus',\n                data: {\n                    x: config.spawnCircle.x,\n                    y: config.spawnCircle.y,\n                    radius: config.spawnCircle.r,\n                    innerRadius: config.spawnCircle.minR,\n                    affectRotation: true,\n                },\n            };\n        }\n        else if (config.spawnType === 'circle')\n        {\n            shape = {\n                type: 'torus',\n                data: {\n                    x: config.spawnCircle.x,\n                    y: config.spawnCircle.y,\n                    radius: config.spawnCircle.r,\n                    innerRadius: 0,\n                    affectRotation: false,\n                },\n            };\n        }\n        else if (config.spawnType === 'rect')\n        {\n            shape = {\n                type: 'rect',\n                data: config.spawnRect,\n            };\n        }\n        else if (config.spawnType === 'polygonalChain')\n        {\n            shape = {\n                type: 'polygonalChain',\n                data: config.spawnPolygon,\n            };\n        }\n\n        if (shape)\n        {\n            out.behaviors.push({\n                type: 'spawnShape',\n                config: shape,\n            });\n        }\n    }\n\n    return out;\n}\n\n/**\n * The obsolete emitter configuration format from version 3.0.0 of the library.\n * This type information is kept to make it easy to upgrade, but otherwise\n * configuration should be made as {@link EmitterConfigV3}.\n */\nexport interface EmitterConfigV2 {\n    alpha?: ValueList<number>;\n    speed?: ValueList<number>;\n    minimumSpeedMultiplier?: number;\n    maxSpeed?: number;\n    acceleration?: {x: number; y: number};\n    scale?: ValueList<number>;\n    minimumScaleMultiplier?: number;\n    color?: ValueList<string>;\n    startRotation?: RandNumber;\n    noRotation?: boolean;\n    rotationSpeed?: RandNumber;\n    rotationAcceleration?: number;\n    lifetime: RandNumber;\n    blendMode?: string;\n    ease?: SimpleEase | EaseSegment[];\n    extraData?: any;\n    particlesPerWave?: number;\n    /**\n     * Really \"rect\"|\"circle\"|\"ring\"|\"burst\"|\"point\"|\"polygonalChain\", but that\n     * tends to be too strict for random object creation.\n     */\n    spawnType?: string;\n    spawnRect?: {x: number; y: number; w: number; h: number};\n    spawnCircle?: {x: number; y: number; r: number; minR?: number};\n    particleSpacing?: number;\n    angleStart?: number;\n    spawnPolygon?: IPointData[] | IPointData[][];\n    frequency: number;\n    spawnChance?: number;\n    emitterLifetime?: number;\n    maxParticles?: number;\n    addAtBack?: boolean;\n    pos: {x: number; y: number};\n    emit?: boolean;\n    autoUpdate?: boolean;\n    orderedArt?: boolean;\n}\n\nexport interface BasicTweenable<T> {\n    start: T;\n    end: T;\n}\n\n/**\n * The obsolete emitter configuration format of the initial library release.\n * This type information is kept to maintain compatibility with the older particle tool, but otherwise\n * configuration should be made as {@link EmitterConfigV3}.\n */\nexport interface EmitterConfigV1 {\n    alpha?: BasicTweenable<number>;\n    speed?: BasicTweenable<number> & {minimumSpeedMultiplier?: number};\n    maxSpeed?: number;\n    acceleration?: {x: number; y: number};\n    scale?: BasicTweenable<number> & {minimumScaleMultiplier?: number};\n    color?: BasicTweenable<string>;\n    startRotation?: RandNumber;\n    noRotation?: boolean;\n    rotationSpeed?: RandNumber;\n    rotationAcceleration?: number;\n    lifetime: RandNumber;\n    blendMode?: string;\n    ease?: SimpleEase | EaseSegment[];\n    extraData?: any;\n    particlesPerWave?: number;\n    /**\n     * Really \"rect\"|\"circle\"|\"ring\"|\"burst\"|\"point\"|\"polygonalChain\", but that\n     * tends to be too strict for random object creation.\n     */\n    spawnType?: string;\n    spawnRect?: {x: number; y: number; w: number; h: number};\n    spawnCircle?: {x: number; y: number; r: number; minR?: number};\n    particleSpacing?: number;\n    angleStart?: number;\n    spawnPolygon?: IPointData[] | IPointData[][];\n    frequency: number;\n    spawnChance?: number;\n    emitterLifetime?: number;\n    maxParticles?: number;\n    addAtBack?: boolean;\n    pos: {x: number; y: number};\n    emit?: boolean;\n    autoUpdate?: boolean;\n    orderedArt?: boolean;\n}\n","import { Container, DisplayObject } from '@pixi/display';\nimport { Renderer, MaskData } from '@pixi/core';\nimport { Rectangle } from '@pixi/math';\n\n/** Interface for a child of a LinkedListContainer (has the prev/next properties added) */\nexport interface LinkedListChild extends DisplayObject\n{\n    nextChild: LinkedListChild|null;\n    prevChild: LinkedListChild|null;\n}\n\n/**\n * A semi-experimental Container that uses a doubly linked list to manage children instead of an\n * array. This means that adding/removing children often is not the same performance hit that\n * it would to be continually pushing/splicing.\n * However, this is primarily intended to be used for heavy particle usage, and may not handle\n * edge cases well if used as a complete Container replacement.\n */\nexport class LinkedListContainer extends Container\n{\n    private _firstChild: LinkedListChild|null = null;\n    private _lastChild: LinkedListChild|null = null;\n    private _childCount = 0;\n\n    public get firstChild(): LinkedListChild\n    {\n        return this._firstChild;\n    }\n\n    public get lastChild(): LinkedListChild\n    {\n        return this._lastChild;\n    }\n\n    public get childCount(): number\n    {\n        return this._childCount;\n    }\n\n    public addChild<T extends DisplayObject[]>(...children: T): T[0]\n    {\n        // if there is only one argument we can bypass looping through the them\n        if (children.length > 1)\n        {\n            // loop through the array and add all children\n            for (let i = 0; i < children.length; i++)\n            {\n                // eslint-disable-next-line prefer-rest-params\n                this.addChild(children[i]);\n            }\n        }\n        else\n        {\n            const child = children[0] as LinkedListChild;\n            // if the child has a parent then lets remove it as PixiJS objects can only exist in one place\n\n            if (child.parent)\n            {\n                child.parent.removeChild(child);\n            }\n\n            child.parent = this;\n            this.sortDirty = true;\n\n            // ensure child transform will be recalculated\n            child.transform._parentID = -1;\n\n            // add to list if we have a list\n            if (this._lastChild)\n            {\n                this._lastChild.nextChild = child;\n                child.prevChild = this._lastChild;\n                this._lastChild = child;\n            }\n            // otherwise initialize the list\n            else\n            {\n                this._firstChild = this._lastChild = child;\n            }\n\n            // update child count\n            ++this._childCount;\n\n            // ensure bounds will be recalculated\n            this._boundsID++;\n\n            // TODO - lets either do all callbacks or all events.. not both!\n            this.onChildrenChange();\n            this.emit('childAdded', child, this, this._childCount);\n            child.emit('added', this);\n        }\n\n        return children[0];\n    }\n\n    public addChildAt<T extends DisplayObject>(child: T, index: number): T\n    {\n        if (index < 0 || index > this._childCount)\n        {\n            throw new Error(`addChildAt: The index ${index} supplied is out of bounds ${this._childCount}`);\n        }\n\n        if (child.parent)\n        {\n            child.parent.removeChild(child);\n        }\n\n        child.parent = this;\n        this.sortDirty = true;\n\n        // ensure child transform will be recalculated\n        child.transform._parentID = -1;\n\n        const c = (child as any) as LinkedListChild;\n\n        // if no children, do basic initialization\n        if (!this._firstChild)\n        {\n            this._firstChild = this._lastChild = c;\n        }\n        // add at beginning (back)\n        else if (index === 0)\n        {\n            this._firstChild.prevChild = c;\n            c.nextChild = this._firstChild;\n            this._firstChild = c;\n        }\n        // add at end (front)\n        else if (index === this._childCount)\n        {\n            this._lastChild.nextChild = c;\n            c.prevChild = this._lastChild;\n            this._lastChild = c;\n        }\n        // otherwise we have to start counting through the children to find the right one\n        // - SLOW, only provided to fully support the possibility of use\n        else\n        {\n            let i = 0;\n            let target = this._firstChild;\n\n            while (i < index)\n            {\n                target = target.nextChild;\n                ++i;\n            }\n            // insert before the target that we found at the specified index\n            target.prevChild.nextChild = c;\n            c.prevChild = target.prevChild;\n            c.nextChild = target;\n            target.prevChild = c;\n        }\n\n        // update child count\n        ++this._childCount;\n\n        // ensure bounds will be recalculated\n        this._boundsID++;\n\n        // TODO - lets either do all callbacks or all events.. not both!\n        this.onChildrenChange(index);\n        child.emit('added', this);\n        this.emit('childAdded', child, this, index);\n\n        return child;\n    }\n\n    /**\n     * Adds a child to the container to be rendered below another child.\n     *\n     * @param child The child to add\n     * @param relative - The current child to add the new child relative to.\n     * @return The child that was added.\n     */\n    public addChildBelow<T extends DisplayObject>(child: T, relative: DisplayObject): T\n    {\n        if (relative.parent !== this)\n        {\n            throw new Error(`addChildBelow: The relative target must be a child of this parent`);\n        }\n\n        if (child.parent)\n        {\n            child.parent.removeChild(child);\n        }\n\n        child.parent = this;\n        this.sortDirty = true;\n\n        // ensure child transform will be recalculated\n        child.transform._parentID = -1;\n\n        // insert before the target that we were given\n        (relative as LinkedListChild).prevChild.nextChild = (child as any as LinkedListChild);\n        (child as any as LinkedListChild).prevChild = (relative as LinkedListChild).prevChild;\n        (child as any as LinkedListChild).nextChild = (relative as LinkedListChild);\n        (relative as LinkedListChild).prevChild = (child as any as LinkedListChild);\n        if (this._firstChild === relative)\n        {\n            this._firstChild = (child as any as LinkedListChild);\n        }\n\n        // update child count\n        ++this._childCount;\n\n        // ensure bounds will be recalculated\n        this._boundsID++;\n\n        // TODO - lets either do all callbacks or all events.. not both!\n        this.onChildrenChange();\n        this.emit('childAdded', child, this, this._childCount);\n        child.emit('added', this);\n\n        return child;\n    }\n\n    /**\n     * Adds a child to the container to be rendered above another child.\n     *\n     * @param child The child to add\n     * @param relative - The current child to add the new child relative to.\n     * @return The child that was added.\n     */\n    public addChildAbove<T extends DisplayObject>(child: T, relative: DisplayObject): T\n    {\n        if (relative.parent !== this)\n        {\n            throw new Error(`addChildBelow: The relative target must be a child of this parent`);\n        }\n\n        if (child.parent)\n        {\n            child.parent.removeChild(child);\n        }\n\n        child.parent = this;\n        this.sortDirty = true;\n\n        // ensure child transform will be recalculated\n        child.transform._parentID = -1;\n\n        // insert after the target that we were given\n        (relative as LinkedListChild).nextChild.prevChild = (child as any as LinkedListChild);\n        (child as any as LinkedListChild).nextChild = (relative as LinkedListChild).nextChild;\n        (child as any as LinkedListChild).prevChild = (relative as LinkedListChild);\n        (relative as LinkedListChild).nextChild = (child as any as LinkedListChild);\n        if (this._lastChild === relative)\n        {\n            this._lastChild = (child as any as LinkedListChild);\n        }\n\n        // update child count\n        ++this._childCount;\n\n        // ensure bounds will be recalculated\n        this._boundsID++;\n\n        // TODO - lets either do all callbacks or all events.. not both!\n        this.onChildrenChange();\n        this.emit('childAdded', child, this, this._childCount);\n        child.emit('added', this);\n\n        return child;\n    }\n\n    public swapChildren(child: DisplayObject, child2: DisplayObject): void\n    {\n        if (child === child2 || child.parent !== this || child2.parent !== this)\n        {\n            return;\n        }\n\n        const { prevChild, nextChild } = (child as LinkedListChild);\n\n        (child as LinkedListChild).prevChild = (child2 as LinkedListChild).prevChild;\n        (child as LinkedListChild).nextChild = (child2 as LinkedListChild).nextChild;\n        (child2 as LinkedListChild).prevChild = prevChild;\n        (child2 as LinkedListChild).nextChild = nextChild;\n\n        if (this._firstChild === child)\n        {\n            this._firstChild = child2 as LinkedListChild;\n        }\n        else if (this._firstChild === child2)\n        {\n            this._firstChild = child as LinkedListChild;\n        }\n        if (this._lastChild === child)\n        {\n            this._lastChild = child2 as LinkedListChild;\n        }\n        else if (this._lastChild === child2)\n        {\n            this._lastChild = child as LinkedListChild;\n        }\n\n        this.onChildrenChange();\n    }\n\n    public getChildIndex(child: DisplayObject): number\n    {\n        let index = 0;\n        let test = this._firstChild;\n\n        while (test)\n        {\n            if (test === child)\n            {\n                break;\n            }\n            test = test.nextChild;\n            ++index;\n        }\n        if (!test)\n        {\n            throw new Error('The supplied DisplayObject must be a child of the caller');\n        }\n\n        return index;\n    }\n\n    setChildIndex(child: DisplayObject, index: number): void\n    {\n        if (index < 0 || index >= this._childCount)\n        {\n            throw new Error(`The index ${index} supplied is out of bounds ${this._childCount}`);\n        }\n        if (child.parent !== this)\n        {\n            throw new Error('The supplied DisplayObject must be a child of the caller');\n        }\n\n        // remove child\n        if ((child as LinkedListChild).nextChild)\n        {\n            (child as LinkedListChild).nextChild.prevChild = (child as LinkedListChild).prevChild;\n        }\n        if ((child as LinkedListChild).prevChild)\n        {\n            (child as LinkedListChild).prevChild.nextChild = (child as LinkedListChild).nextChild;\n        }\n        if (this._firstChild === (child as LinkedListChild))\n        {\n            this._firstChild = (child as LinkedListChild).nextChild;\n        }\n        if (this._lastChild === (child as LinkedListChild))\n        {\n            this._lastChild = (child as LinkedListChild).prevChild;\n        }\n        (child as LinkedListChild).nextChild = null;\n        (child as LinkedListChild).prevChild = null;\n\n        // do addChildAt\n        if (!this._firstChild)\n        {\n            this._firstChild = this._lastChild = (child as LinkedListChild);\n        }\n        else if (index === 0)\n        {\n            this._firstChild.prevChild = (child as LinkedListChild);\n            (child as LinkedListChild).nextChild = this._firstChild;\n            this._firstChild = (child as LinkedListChild);\n        }\n        else if (index === this._childCount)\n        {\n            this._lastChild.nextChild = (child as LinkedListChild);\n            (child as LinkedListChild).prevChild = this._lastChild;\n            this._lastChild = (child as LinkedListChild);\n        }\n        else\n        {\n            let i = 0;\n            let target = this._firstChild;\n\n            while (i < index)\n            {\n                target = target.nextChild;\n                ++i;\n            }\n            target.prevChild.nextChild = (child as LinkedListChild);\n            (child as LinkedListChild).prevChild = target.prevChild;\n            (child as LinkedListChild).nextChild = target;\n            target.prevChild = (child as LinkedListChild);\n        }\n\n        this.onChildrenChange(index);\n    }\n\n    public removeChild<T extends DisplayObject[]>(...children: T): T[0]\n    {\n        // if there is only one argument we can bypass looping through the them\n        if (children.length > 1)\n        {\n            // loop through the arguments property and remove all children\n            for (let i = 0; i < children.length; i++)\n            {\n                this.removeChild(children[i]);\n            }\n        }\n        else\n        {\n            const child = children[0] as LinkedListChild;\n\n            // bail if not actually our child\n            if (child.parent !== this) return null;\n\n            child.parent = null;\n            // ensure child transform will be recalculated\n            child.transform._parentID = -1;\n\n            // swap out child references\n            if (child.nextChild)\n            {\n                child.nextChild.prevChild = child.prevChild;\n            }\n            if (child.prevChild)\n            {\n                child.prevChild.nextChild = child.nextChild;\n            }\n            if (this._firstChild === child)\n            {\n                this._firstChild = child.nextChild;\n            }\n            if (this._lastChild === child)\n            {\n                this._lastChild = child.prevChild;\n            }\n            // clear sibling references\n            child.nextChild = null;\n            child.prevChild = null;\n\n            // update child count\n            --this._childCount;\n\n            // ensure bounds will be recalculated\n            this._boundsID++;\n\n            // TODO - lets either do all callbacks or all events.. not both!\n            this.onChildrenChange();\n            child.emit('removed', this);\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            this.emit('childRemoved', child, this);\n        }\n\n        return children[0];\n    }\n\n    public getChildAt(index: number): DisplayObject\n    {\n        if (index < 0 || index >= this._childCount)\n        {\n            throw new Error(`getChildAt: Index (${index}) does not exist.`);\n        }\n\n        if (index === 0)\n        {\n            return this._firstChild;\n        }\n        // add at end (front)\n        else if (index === this._childCount)\n        {\n            return this._lastChild;\n        }\n        // otherwise we have to start counting through the children to find the right one\n        // - SLOW, only provided to fully support the possibility of use\n        let i = 0;\n        let target = this._firstChild;\n\n        while (i < index)\n        {\n            target = target.nextChild;\n            ++i;\n        }\n\n        return target;\n    }\n\n    public removeChildAt(index: number): DisplayObject\n    {\n        const child = this.getChildAt(index) as LinkedListChild;\n\n        // ensure child transform will be recalculated..\n        child.parent = null;\n        child.transform._parentID = -1;\n        // swap out child references\n        if (child.nextChild)\n        {\n            child.nextChild.prevChild = child.prevChild;\n        }\n        if (child.prevChild)\n        {\n            child.prevChild.nextChild = child.nextChild;\n        }\n        if (this._firstChild === child)\n        {\n            this._firstChild = child.nextChild;\n        }\n        if (this._lastChild === child)\n        {\n            this._lastChild = child.prevChild;\n        }\n        // clear sibling references\n        child.nextChild = null;\n        child.prevChild = null;\n\n        // update child count\n        --this._childCount;\n\n        // ensure bounds will be recalculated\n        this._boundsID++;\n\n        // TODO - lets either do all callbacks or all events.. not both!\n        this.onChildrenChange(index);\n        child.emit('removed', this);\n        this.emit('childRemoved', child, this, index);\n\n        return child;\n    }\n\n    public removeChildren(beginIndex = 0, endIndex = this._childCount): DisplayObject[]\n    {\n        const begin = beginIndex;\n\n        // because Container.destroy() has removeChildren(0, this.children.count), assume that an end index of 0\n        // should actually be _childCount.\n        if (endIndex === 0 && this._childCount > 0)\n        {\n            endIndex = this._childCount;\n        }\n        const end = endIndex;\n        const range = end - begin;\n\n        if (range > 0 && range <= end)\n        {\n            const removed: LinkedListChild[] = [];\n            let child = this._firstChild;\n\n            for (let i = 0; i <= end && child; ++i, child = child.nextChild)\n            {\n                if (i >= begin)\n                {\n                    removed.push(child);\n                }\n            }\n\n            // child before removed section\n            const prevChild = removed[0].prevChild;\n            // child after removed section\n            const nextChild = removed[removed.length - 1].nextChild;\n\n            if (!nextChild)\n            {\n                // if we removed the last child, then the new last child is the one before\n                // the removed section\n                this._lastChild = prevChild;\n            }\n            else\n            {\n                // otherwise, stitch the child before the section to the child after\n                nextChild.prevChild = prevChild;\n            }\n            if (!prevChild)\n            {\n                // if we removed the first child, then the new first child is the one after\n                // the removed section\n                this._firstChild = nextChild;\n            }\n            else\n            {\n                // otherwise stich the child after the section to the one before\n                prevChild.nextChild = nextChild;\n            }\n\n            for (let i = 0; i < removed.length; ++i)\n            {\n                // clear parenting and sibling references for all removed children\n                removed[i].parent = null;\n                if (removed[i].transform)\n                {\n                    removed[i].transform._parentID = -1;\n                }\n                removed[i].nextChild = null;\n                removed[i].prevChild = null;\n            }\n\n            this._boundsID++;\n\n            this.onChildrenChange(beginIndex);\n\n            for (let i = 0; i < removed.length; ++i)\n            {\n                removed[i].emit('removed', this);\n                this.emit('childRemoved', removed[i], this, i);\n            }\n\n            return removed;\n        }\n        else if (range === 0 && this._childCount === 0)\n        {\n            return [];\n        }\n\n        throw new RangeError('removeChildren: numeric values are outside the acceptable range.');\n    }\n\n    /**\n     * Updates the transform on all children of this container for rendering.\n     * Copied from and overrides PixiJS v5 method (v4 method is identical)\n     */\n    updateTransform(): void\n    {\n        this._boundsID++;\n\n        this.transform.updateTransform(this.parent.transform);\n\n        // TODO: check render flags, how to process stuff here\n        this.worldAlpha = this.alpha * this.parent.worldAlpha;\n\n        let child;\n        let next;\n\n        for (child = this._firstChild; child; child = next)\n        {\n            next = child.nextChild;\n\n            if (child.visible)\n            {\n                child.updateTransform();\n            }\n        }\n    }\n\n    /**\n     * Recalculates the bounds of the container.\n     * Copied from and overrides PixiJS v5 method (v4 method is identical)\n     */\n    calculateBounds(): void\n    {\n        this._bounds.clear();\n\n        this._calculateBounds();\n\n        let child;\n        let next;\n\n        for (child = this._firstChild; child; child = next)\n        {\n            next = child.nextChild;\n\n            if (!child.visible || !child.renderable)\n            {\n                continue;\n            }\n\n            child.calculateBounds();\n\n            // TODO: filter+mask, need to mask both somehow\n            if (child._mask)\n            {\n                const maskObject = ((child._mask as MaskData).maskObject || child._mask) as Container;\n\n                maskObject.calculateBounds();\n                this._bounds.addBoundsMask(child._bounds, maskObject._bounds);\n            }\n            else if (child.filterArea)\n            {\n                this._bounds.addBoundsArea(child._bounds, child.filterArea);\n            }\n            else\n            {\n                this._bounds.addBounds(child._bounds);\n            }\n        }\n\n        this._bounds.updateID = this._boundsID;\n    }\n\n    /**\n     * Retrieves the local bounds of the displayObject as a rectangle object. Copied from and overrides PixiJS v5 method\n     */\n    public getLocalBounds(rect?: Rectangle, skipChildrenUpdate = false): Rectangle\n    {\n        // skip Container's getLocalBounds, go directly to DisplayObject\n        const result = DisplayObject.prototype.getLocalBounds.call(this, rect);\n\n        if (!skipChildrenUpdate)\n        {\n            let child;\n            let next;\n\n            for (child = this._firstChild; child; child = next)\n            {\n                next = child.nextChild;\n\n                if (child.visible)\n                {\n                    child.updateTransform();\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Renders the object using the WebGL renderer. Copied from and overrides PixiJS v5 method\n     */\n    render(renderer: Renderer): void\n    {\n        // if the object is not visible or the alpha is 0 then no need to render this element\n        if (!this.visible || this.worldAlpha <= 0 || !this.renderable)\n        {\n            return;\n        }\n\n        // do a quick check to see if this element has a mask or a filter.\n        if (this._mask || (this.filters && this.filters.length))\n        {\n            this.renderAdvanced(renderer);\n        }\n        else\n        {\n            this._render(renderer);\n\n            let child;\n            let next;\n\n            // simple render children!\n            for (child = this._firstChild; child; child = next)\n            {\n                next = child.nextChild;\n                child.render(renderer);\n            }\n        }\n    }\n\n    /**\n     * Render the object using the WebGL renderer and advanced features. Copied from and overrides PixiJS v5 method\n     */\n    protected renderAdvanced(renderer: Renderer): void\n    {\n        renderer.batch.flush();\n\n        const filters = this.filters;\n        const mask = this._mask;\n\n        // _enabledFilters note: As of development, _enabledFilters is not documented in pixi.js\n        // types but is in code of current release (5.2.4).\n\n        // push filter first as we need to ensure the stencil buffer is correct for any masking\n        if (filters)\n        {\n            if (!this._enabledFilters)\n            {\n                this._enabledFilters = [];\n            }\n\n            this._enabledFilters.length = 0;\n\n            for (let i = 0; i < filters.length; i++)\n            {\n                if (filters[i].enabled)\n                {\n                    this._enabledFilters.push(filters[i]);\n                }\n            }\n\n            if (this._enabledFilters.length)\n            {\n                renderer.filter.push(this, this._enabledFilters);\n            }\n        }\n\n        if (mask)\n        {\n            renderer.mask.push(this, this._mask);\n        }\n\n        // add this object to the batch, only rendered if it has a texture.\n        this._render(renderer);\n\n        let child;\n        let next;\n\n        // now loop through the children and make sure they get rendered\n        for (child = this._firstChild; child; child = next)\n        {\n            next = child.nextChild;\n            child.render(renderer);\n        }\n\n        renderer.batch.flush();\n\n        if (mask)\n        {\n            renderer.mask.pop(this);\n        }\n\n        if (filters && this._enabledFilters && this._enabledFilters.length)\n        {\n            renderer.filter.pop();\n        }\n    }\n\n    /**\n     * Renders the object using the Canvas renderer. Copied from and overrides PixiJS Canvas mixin in V5 and V6.\n     */\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    renderCanvas(renderer: any): void\n    {\n        // if not visible or the alpha is 0 then no need to render this\n        if (!this.visible || this.worldAlpha <= 0 || !this.renderable)\n        {\n            return;\n        }\n\n        if (this._mask)\n        {\n            renderer.maskManager.pushMask(this._mask);\n        }\n\n        (this as any)._renderCanvas(renderer);\n\n        let child;\n        let next;\n\n        for (child = this._firstChild; child; child = next)\n        {\n            next = child.nextChild;\n            (child as any).renderCanvas(renderer);\n        }\n\n        if (this._mask)\n        {\n            renderer.maskManager.popMask(renderer);\n        }\n    }\n}\n","import { Emitter } from './Emitter';\nimport * as behaviors from './behaviors';\n\nEmitter.registerBehavior(behaviors.AccelerationBehavior);\nEmitter.registerBehavior(behaviors.AlphaBehavior);\nEmitter.registerBehavior(behaviors.StaticAlphaBehavior);\nEmitter.registerBehavior(behaviors.RandomAnimatedTextureBehavior);\nEmitter.registerBehavior(behaviors.SingleAnimatedTextureBehavior);\nEmitter.registerBehavior(behaviors.BlendModeBehavior);\nEmitter.registerBehavior(behaviors.BurstSpawnBehavior);\nEmitter.registerBehavior(behaviors.ColorBehavior);\nEmitter.registerBehavior(behaviors.StaticColorBehavior);\nEmitter.registerBehavior(behaviors.OrderedTextureBehavior);\nEmitter.registerBehavior(behaviors.PathBehavior);\nEmitter.registerBehavior(behaviors.PointSpawnBehavior);\nEmitter.registerBehavior(behaviors.RandomTextureBehavior);\nEmitter.registerBehavior(behaviors.RotationBehavior);\nEmitter.registerBehavior(behaviors.StaticRotationBehavior);\nEmitter.registerBehavior(behaviors.NoRotationBehavior);\nEmitter.registerBehavior(behaviors.ScaleBehavior);\nEmitter.registerBehavior(behaviors.StaticScaleBehavior);\nEmitter.registerBehavior(behaviors.ShapeSpawnBehavior);\nEmitter.registerBehavior(behaviors.SingleTextureBehavior);\nEmitter.registerBehavior(behaviors.SpeedBehavior);\nEmitter.registerBehavior(behaviors.StaticSpeedBehavior);\n\nexport * as behaviors from './behaviors';\nexport * as ParticleUtils from './ParticleUtils';\nexport * from './Particle';\nexport * from './Emitter';\nexport * from './EmitterConfig';\nexport * from './PropertyList';\nexport * from './PropertyNode';\nexport * from './LinkedListContainer';\n"],"names":["behaviors.AccelerationBehavior","behaviors.AlphaBehavior","behaviors.StaticAlphaBehavior","behaviors.RandomAnimatedTextureBehavior","behaviors.SingleAnimatedTextureBehavior","behaviors.BlendModeBehavior","behaviors.BurstSpawnBehavior","behaviors.ColorBehavior","behaviors.StaticColorBehavior","behaviors.OrderedTextureBehavior","behaviors.PathBehavior","behaviors.PointSpawnBehavior","behaviors.RandomTextureBehavior","behaviors.RotationBehavior","behaviors.StaticRotationBehavior","behaviors.NoRotationBehavior","behaviors.ScaleBehavior","behaviors.StaticScaleBehavior","behaviors.ShapeSpawnBehavior","behaviors.SingleTextureBehavior","behaviors.SpeedBehavior","behaviors.StaticSpeedBehavior"],"mappings":"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"}