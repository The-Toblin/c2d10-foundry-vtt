import { Buffer, Geometry, Matrix } from '@pixi/core';
import { Bounds } from '@pixi/display';
import { BatchDrawCall, IGraphicsBatchSettings } from './core/BatchDrawCall';
import { BatchPart } from './core/BatchPart';
import { BuildData } from './core/BuildData';
import { FillStyle } from './core/FillStyle';
import { LineStyle } from './core/LineStyle';
import { SegmentPacker } from './core/SegmentPacker';
import { SmoothGraphicsData } from './core/SmoothGraphicsData';
import type { Circle, Ellipse, IPointData, Polygon, Rectangle, RoundedRectangle } from '@pixi/core';
export type IShape = Circle | Ellipse | Polygon | Rectangle | RoundedRectangle;
export declare const BATCH_POOL: Array<BatchPart>;
export declare const DRAW_CALL_POOL: Array<BatchDrawCall>;
/**
 * @memberof PIXI.smooth
 */
export declare class SmoothGraphicsGeometry extends Geometry {
    static BATCHABLE_SIZE: number;
    boundsPadding: number;
    indicesUint16: Uint16Array | Uint32Array;
    batchable: boolean;
    buildData: BuildData;
    get points(): number[];
    get closePointEps(): number;
    graphicsData: Array<SmoothGraphicsData>;
    drawCalls: Array<BatchDrawCall>;
    batchDirty: number;
    batches: Array<BatchPart>;
    packer: SegmentPacker;
    packSize: number;
    pack32index: boolean;
    strideFloats: number;
    protected dirty: number;
    protected cacheDirty: number;
    protected clearDirty: number;
    protected shapeBuildIndex: number;
    protected shapeBatchIndex: number;
    protected _bounds: Bounds;
    protected boundsDirty: number;
    _buffer: Buffer;
    _indexBuffer: Buffer;
    _bufferFloats: Float32Array;
    _bufferUint: Uint32Array;
    initAttributes(_static: boolean): void;
    constructor();
    checkInstancing(instanced: boolean, allow32Indices: boolean): void;
    /**
     * Get the current bounds of the graphic geometry.
     *
     * @member {PIXI.Bounds}
     * @readonly
     */
    get bounds(): Bounds;
    /**
     * Call if you changed graphicsData manually.
     * Empties all batch buffers.
     */
    protected invalidate(): void;
    clear(): SmoothGraphicsGeometry;
    drawShape(shape: IShape, fillStyle?: FillStyle, lineStyle?: LineStyle, matrix?: Matrix): SmoothGraphicsGeometry;
    drawHole(shape: IShape, matrix?: Matrix): SmoothGraphicsGeometry;
    destroy(): void;
    /**
     * Check to see if a point is contained within this geometry.
     *
     * @param {PIXI.IPointData} point - Point to check if it's contained.
     * @return {Boolean} `true` if the point is contained within geometry.
     */
    containsPoint(point: IPointData): boolean;
    updatePoints(): void;
    updateBufferSize(): void;
    updateBuild(): void;
    updateBatches(shaderSettings?: IGraphicsBatchSettings): void;
    updatePack(): void;
    /**
     * Affinity check
     *
     * @param {PIXI.FillStyle | PIXI.LineStyle} styleA
     * @param {PIXI.FillStyle | PIXI.LineStyle} styleB
     */
    protected _compareStyles(styleA: FillStyle | LineStyle, styleB: FillStyle | LineStyle): boolean;
    /**
     * Test geometry for batching process.
     *
     * @protected
     */
    protected validateBatching(): boolean;
    /**
     * Offset the indices so that it works with the batcher.
     *
     * @protected
     */
    protected packBatches(): void;
    protected isBatchable(): boolean;
    /**
     * Converts intermediate batches data to drawCalls.
     *
     * @protected
     */
    protected buildDrawCalls(shaderSettings?: IGraphicsBatchSettings): void;
    protected processHoles(holes: Array<SmoothGraphicsData>): void;
    /**
     * Update the local bounds of the object. Expensive to use performance-wise.
     *
     * @protected
     */
    protected calculateBounds(): void;
    /**
     * Transform points using matrix.
     *
     * @protected
     * @param {number[]} points - Points to transform
     * @param {PIXI.Matrix} matrix - Transform matrix
     */
    protected transformPoints(points: Array<number>, matrix: Matrix): void;
}
