{"version":3,"file":"SmoothGraphicsGeometry.js","sources":["../src/SmoothGraphicsGeometry.ts"],"sourcesContent":["import {\n    Buffer,\n    Color,\n    Geometry,\n    Matrix,\n    Point,\n    SHAPES,\n    Texture,\n    TYPES,\n    WRAP_MODES,\n} from '@pixi/core';\nimport { Bounds } from '@pixi/display';\nimport { BatchDrawCall, IGraphicsBatchSettings, matrixEquals } from './core/BatchDrawCall';\nimport { BatchPart } from './core/BatchPart';\nimport { BuildData } from './core/BuildData';\nimport { FillStyle } from './core/FillStyle';\nimport { LineStyle } from './core/LineStyle';\nimport { SegmentPacker } from './core/SegmentPacker';\nimport { SmoothGraphicsData } from './core/SmoothGraphicsData';\nimport { FILL_COMMANDS } from './shapes';\n\nimport type { Circle, Ellipse, IPointData, Polygon, Rectangle, RoundedRectangle } from '@pixi/core';\n\n/*\n * Complex shape type\n * @todo Move to Math shapes\n */\nexport type IShape = Circle | Ellipse | Polygon | Rectangle | RoundedRectangle;\n\nexport const BATCH_POOL: Array<BatchPart> = [];\nexport const DRAW_CALL_POOL: Array<BatchDrawCall> = [];\n\nconst tmpPoint = new Point();\nconst tmpBounds = new Bounds();\n\n/**\n * @memberof PIXI.smooth\n */\nexport class SmoothGraphicsGeometry extends Geometry\n{\n    public static BATCHABLE_SIZE = 100;\n\n    public boundsPadding: number;\n\n    indicesUint16: Uint16Array | Uint32Array = null;\n    batchable: boolean;\n\n    buildData: BuildData;\n\n    get points()\n    {\n        return this.buildData.verts;\n    }\n\n    get closePointEps()\n    {\n        return this.buildData.closePointEps;\n    }\n\n    graphicsData: Array<SmoothGraphicsData>;\n    drawCalls: Array<BatchDrawCall>;\n    batchDirty: number;\n    batches: Array<BatchPart>;\n    packer: SegmentPacker;\n    packSize: number;\n    pack32index: boolean;\n    strideFloats: number;\n\n    protected dirty: number;\n    protected cacheDirty: number;\n    protected clearDirty: number;\n    protected shapeBuildIndex: number;\n    protected shapeBatchIndex: number;\n    protected _bounds: Bounds;\n    protected boundsDirty: number;\n\n    _buffer: Buffer;\n    _indexBuffer: Buffer;\n    _bufferFloats: Float32Array;\n    _bufferUint: Uint32Array;\n\n    initAttributes(_static: boolean)\n    {\n        this._buffer = new Buffer(null, _static, false);\n        this._bufferFloats = new Float32Array();\n        this._bufferUint = new Uint32Array();\n\n        this._indexBuffer = new Buffer(null, _static, true);\n        this.addAttribute('aPrev', this._buffer, 2, false, TYPES.FLOAT)\n            .addAttribute('aPoint1', this._buffer, 2, false, TYPES.FLOAT)\n            .addAttribute('aPoint2', this._buffer, 2, false, TYPES.FLOAT)\n            .addAttribute('aNext', this._buffer, 2, false, TYPES.FLOAT)\n            .addAttribute('aTravel', this._buffer, 1, false, TYPES.FLOAT)\n            // number of vertex\n            .addAttribute('aVertexJoint', this._buffer, 1, false, TYPES.FLOAT)\n            // line width, alignment\n            .addAttribute('aStyleId', this._buffer, 1, false, TYPES.FLOAT)\n            // the usual\n            .addAttribute('aColor', this._buffer, 4, true, TYPES.UNSIGNED_BYTE)\n            .addIndex(this._indexBuffer);\n\n        this.strideFloats = 12;\n    }\n\n    constructor()\n    {\n        super();\n\n        this.initAttributes(false);\n\n        this.buildData = new BuildData();\n\n        this.graphicsData = [];\n\n        this.dirty = 0;\n\n        this.batchDirty = -1;\n\n        this.cacheDirty = -1;\n\n        this.clearDirty = 0;\n\n        this.drawCalls = [];\n\n        this.batches = [];\n\n        this.shapeBuildIndex = 0;\n\n        this.shapeBatchIndex = 0;\n\n        this._bounds = new Bounds();\n\n        this.boundsDirty = -1;\n\n        this.boundsPadding = 0;\n\n        this.batchable = false;\n\n        this.indicesUint16 = null;\n\n        this.packer = null;\n        this.packSize = 0;\n        this.pack32index = null;\n    }\n\n    public checkInstancing(instanced: boolean, allow32Indices: boolean)\n    {\n        if (this.packer)\n        {\n            return;\n        }\n        this.packer = new SegmentPacker();\n        this.pack32index = allow32Indices;\n    }\n\n    /**\n     * Get the current bounds of the graphic geometry.\n     *\n     * @member {PIXI.Bounds}\n     * @readonly\n     */\n    public get bounds(): Bounds\n    {\n        if (this.boundsDirty !== this.dirty)\n        {\n            this.boundsDirty = this.dirty;\n            this.calculateBounds();\n        }\n\n        return this._bounds;\n    }\n\n    /**\n     * Call if you changed graphicsData manually.\n     * Empties all batch buffers.\n     */\n    protected invalidate(): void\n    {\n        this.boundsDirty = -1;\n        this.dirty++;\n        this.batchDirty++;\n        this.shapeBuildIndex = 0;\n        this.shapeBatchIndex = 0;\n        this.packSize = 0;\n\n        this.buildData.clear();\n\n        for (let i = 0; i < this.drawCalls.length; i++)\n        {\n            this.drawCalls[i].clear();\n            DRAW_CALL_POOL.push(this.drawCalls[i]);\n        }\n\n        this.drawCalls.length = 0;\n\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            const batchPart = this.batches[i];\n\n            batchPart.reset();\n            BATCH_POOL.push(batchPart);\n        }\n\n        this.batches.length = 0;\n    }\n\n    public clear(): SmoothGraphicsGeometry\n    {\n        if (this.graphicsData.length > 0)\n        {\n            this.invalidate();\n            this.clearDirty++;\n            this.graphicsData.length = 0;\n        }\n\n        return this;\n    }\n\n    public drawShape(\n        shape: IShape,\n        fillStyle: FillStyle = null,\n        lineStyle: LineStyle = null,\n        matrix: Matrix = null): SmoothGraphicsGeometry\n    {\n        const data = new SmoothGraphicsData(shape, fillStyle, lineStyle, matrix);\n\n        this.graphicsData.push(data);\n        this.dirty++;\n\n        return this;\n    }\n\n    public drawHole(shape: IShape, matrix: Matrix = null): SmoothGraphicsGeometry\n    {\n        if (!this.graphicsData.length)\n        {\n            return null;\n        }\n\n        const data = new SmoothGraphicsData(shape, null, null, matrix);\n\n        const lastShape = this.graphicsData[this.graphicsData.length - 1];\n\n        data.lineStyle = lastShape.lineStyle;\n\n        lastShape.holes.push(data);\n\n        this.dirty++;\n\n        return this;\n    }\n\n    public destroy(): void\n    {\n        super.destroy();\n\n        // destroy each of the SmoothGraphicsData objects\n        for (let i = 0; i < this.graphicsData.length; ++i)\n        {\n            this.graphicsData[i].destroy();\n        }\n\n        this.buildData.destroy();\n        this.buildData = null;\n        this.indexBuffer.destroy();\n        this.indexBuffer = null;\n        this.graphicsData.length = 0;\n        this.graphicsData = null;\n        this.drawCalls.length = 0;\n        this.drawCalls = null;\n        this.batches.length = 0;\n        this.batches = null;\n        this._bounds = null;\n    }\n\n    /**\n     * Check to see if a point is contained within this geometry.\n     *\n     * @param {PIXI.IPointData} point - Point to check if it's contained.\n     * @return {Boolean} `true` if the point is contained within geometry.\n     */\n    public containsPoint(point: IPointData): boolean\n    {\n        const graphicsData = this.graphicsData;\n\n        for (let i = 0; i < graphicsData.length; ++i)\n        {\n            const data = graphicsData[i];\n\n            if (!data.fillStyle.visible)\n            {\n                continue;\n            }\n\n            // only deal with fills..\n            if (data.shape)\n            {\n                if (data.matrix)\n                {\n                    data.matrix.applyInverse(point, tmpPoint);\n                }\n                else\n                {\n                    tmpPoint.copyFrom(point);\n                }\n\n                if (data.shape.contains(tmpPoint.x, tmpPoint.y))\n                {\n                    let hitHole = false;\n\n                    if (data.holes)\n                    {\n                        for (let i = 0; i < data.holes.length; i++)\n                        {\n                            const hole = data.holes[i];\n\n                            if (hole.shape.contains(tmpPoint.x, tmpPoint.y))\n                            {\n                                hitHole = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (!hitHole)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    updatePoints(): void\n    {\n        // do nothing\n    }\n\n    updateBufferSize(): void\n    {\n        this._buffer.update(new Float32Array());\n    }\n\n    updateBuild(): void\n    {\n        const { graphicsData, buildData } = this;\n        const len = graphicsData.length;\n\n        for (let i = this.shapeBuildIndex; i < len; i++)\n        {\n            const data = graphicsData[i];\n\n            data.strokeStart = 0;\n            data.strokeLen = 0;\n            data.fillStart = 0;\n            data.fillLen = 0;\n            const { fillStyle, lineStyle, holes } = data;\n\n            if (!fillStyle.visible && !lineStyle.visible)\n            {\n                continue;\n            }\n\n            const command = FILL_COMMANDS[data.type];\n\n            data.clearPath();\n\n            command.path(data, buildData);\n            if (data.matrix)\n            {\n                this.transformPoints(data.points, data.matrix);\n            }\n\n            data.clearBuild();\n            if (data.points.length <= 2)\n            {\n                continue;\n            }\n            if (fillStyle.visible || lineStyle.visible)\n            {\n                this.processHoles(holes);\n            }\n            if (fillStyle.visible)\n            {\n                data.fillAA = (data.fillStyle as any).smooth\n                    && data.fillStyle.texture === Texture.WHITE\n                    && holes.length === 0\n                    && !(data.closeStroke\n                    && data.lineStyle.visible\n                    && !data.lineStyle.shader\n                    && data.lineStyle.alpha >= 0.99\n                    && data.lineStyle.width * Math.min(data.lineStyle.alignment, 1 - data.lineStyle.alignment) >= 0.495);\n\n                data.fillStart = buildData.joints.length;\n\n                if (holes.length)\n                {\n                    FILL_COMMANDS[SHAPES.POLY].fill(data, buildData);\n                }\n                else\n                {\n                    command.fill(data, buildData);\n                }\n\n                data.fillLen = buildData.joints.length - data.fillStart;\n            }\n            if (lineStyle.visible)\n            {\n                data.strokeStart = buildData.joints.length;\n                command.line(data, buildData);\n                for (let i = 0; i < holes.length; i++)\n                {\n                    const hole = holes[i];\n\n                    FILL_COMMANDS[hole.type].line(hole, buildData);\n                }\n                data.strokeLen = buildData.joints.length - data.strokeStart;\n            }\n        }\n        this.shapeBuildIndex = len;\n    }\n\n    updateBatches(shaderSettings?: IGraphicsBatchSettings): void\n    {\n        if (!this.graphicsData.length)\n        {\n            this.batchable = true;\n\n            return;\n        }\n        this.updateBuild();\n\n        if (!this.validateBatching())\n        {\n            return;\n        }\n\n        const { buildData, graphicsData } = this;\n        const len = graphicsData.length;\n\n        this.cacheDirty = this.dirty;\n\n        let batchPart: BatchPart = null;\n\n        let currentStyle = null;\n\n        if (this.batches.length > 0)\n        {\n            batchPart = this.batches[this.batches.length - 1];\n            currentStyle = batchPart.style;\n        }\n\n        for (let i = this.shapeBatchIndex; i < len; i++)\n        {\n            const data = graphicsData[i];\n            const fillStyle = data.fillStyle;\n            const lineStyle = data.lineStyle;\n\n            if (data.matrix)\n            {\n                this.transformPoints(data.points, data.matrix);\n            }\n            if (!fillStyle.visible && !lineStyle.visible)\n            {\n                continue;\n            }\n            for (let j = 0; j < 2; j++)\n            {\n                const style = (j === 0) ? fillStyle : lineStyle;\n\n                if (!style.visible) continue;\n\n                const nextTexture = style.texture.baseTexture;\n                const attribOld = buildData.vertexSize;\n                const indexOld = buildData.indexSize;\n\n                nextTexture.wrapMode = WRAP_MODES.REPEAT;\n                if (j === 0)\n                {\n                    this.packer.updateBufferSize(data.fillStart, data.fillLen, data.triangles.length, buildData);\n                }\n                else\n                {\n                    this.packer.updateBufferSize(data.strokeStart, data.strokeLen, data.triangles.length, buildData);\n                }\n\n                const attribSize = buildData.vertexSize;\n\n                if (attribSize === attribOld) continue;\n                // close batch if style is different\n                if (batchPart && !this._compareStyles(currentStyle, style))\n                {\n                    batchPart.end(indexOld, attribOld);\n                    batchPart = null;\n                }\n                // spawn new batch if its first batch or previous was closed\n                if (!batchPart)\n                {\n                    batchPart = BATCH_POOL.pop() || new BatchPart();\n                    batchPart.begin(style, indexOld, attribOld);\n                    this.batches.push(batchPart);\n                    currentStyle = style;\n                }\n\n                if (j === 0)\n                {\n                    batchPart.jointEnd = data.fillStart + data.fillLen;\n                }\n                else\n                {\n                    batchPart.jointEnd = data.strokeStart + data.strokeLen;\n                }\n            }\n        }\n        this.shapeBatchIndex = len;\n\n        if (batchPart)\n        {\n            batchPart.end(buildData.indexSize, buildData.vertexSize);\n        }\n\n        if (this.batches.length === 0)\n        {\n            // there are no visible styles in SmoothGraphicsData\n            // its possible that someone wants Graphics just for the bounds\n            this.batchable = true;\n\n            return;\n        }\n\n        // TODO make this a const..\n        this.batchable = this.isBatchable();\n\n        if (this.batchable)\n        {\n            this.packBatches();\n        }\n        else\n        {\n            this.buildDrawCalls(shaderSettings);\n            this.updatePack();\n        }\n    }\n\n    updatePack()\n    {\n        const { vertexSize, indexSize } = this.buildData;\n\n        if (this.packSize === vertexSize)\n        {\n            return;\n        }\n\n        const { strideFloats, packer, buildData, batches } = this;\n        const buffer = this._buffer;\n        const index = this._indexBuffer;\n        const floatsSize = vertexSize * strideFloats;\n\n        if (buffer.data.length !== floatsSize)\n        {\n            const arrBuf = new ArrayBuffer(floatsSize * 4);\n\n            this._bufferFloats = new Float32Array(arrBuf);\n            this._bufferUint = new Uint32Array(arrBuf);\n            buffer.data = this._bufferFloats;\n        }\n        if (index.data.length !== indexSize)\n        {\n            if (vertexSize > 0xffff && this.pack32index)\n            {\n                index.data = new Uint32Array(indexSize);\n            }\n            else\n            {\n                index.data = new Uint16Array(indexSize);\n            }\n        }\n\n        packer.beginPack(buildData, this._bufferFloats, this._bufferUint, index.data as Uint16Array);\n\n        let j = 0;\n\n        for (let i = 0; i < this.graphicsData.length; i++)\n        {\n            const data = this.graphicsData[i];\n\n            if (data.fillLen)\n            {\n                while (batches[j].jointEnd <= data.fillStart)\n                {\n                    j++;\n                }\n                packer.packInterleavedGeometry(data.fillStart, data.fillLen, data.triangles,\n                    batches[j].styleId, batches[j].rgba);\n            }\n            if (data.strokeLen)\n            {\n                while (batches[j].jointEnd <= data.strokeStart)\n                {\n                    j++;\n                }\n                packer.packInterleavedGeometry(data.strokeStart, data.strokeLen, data.triangles,\n                    batches[j].styleId, batches[j].rgba);\n            }\n        }\n\n        buffer.update();\n        index.update();\n        this.packSize = vertexSize;\n    }\n\n    /**\n     * Affinity check\n     *\n     * @param {PIXI.FillStyle | PIXI.LineStyle} styleA\n     * @param {PIXI.FillStyle | PIXI.LineStyle} styleB\n     */\n    protected _compareStyles(styleA: FillStyle | LineStyle, styleB: FillStyle | LineStyle): boolean\n    {\n        if (!styleA || !styleB)\n        {\n            return false;\n        }\n\n        if (styleA.texture.baseTexture !== styleB.texture.baseTexture)\n        {\n            return false;\n        }\n\n        if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha)\n        {\n            return false;\n        }\n\n        if (styleA.shader !== styleB.shader)\n        {\n            return false;\n        }\n        // TODO: propagate width for FillStyle\n        if ((styleA as LineStyle).width !== (styleB as LineStyle).width)\n        {\n            return false;\n        }\n        if ((styleA as LineStyle).scaleMode !== (styleB as LineStyle).scaleMode)\n        {\n            return false;\n        }\n        if ((styleA as LineStyle).alignment !== (styleB as LineStyle).alignment)\n        {\n            return false;\n        }\n\n        const mat1 = styleA.matrix || Matrix.IDENTITY;\n        const mat2 = styleB.matrix || Matrix.IDENTITY;\n\n        return matrixEquals(mat1, mat2);\n    }\n\n    /**\n     * Test geometry for batching process.\n     *\n     * @protected\n     */\n    protected validateBatching(): boolean\n    {\n        if (this.dirty === this.cacheDirty || !this.graphicsData.length)\n        {\n            return false;\n        }\n\n        for (let i = 0, l = this.graphicsData.length; i < l; i++)\n        {\n            const data = this.graphicsData[i];\n            const fill = data.fillStyle;\n            const line = data.lineStyle;\n\n            if (fill && !fill.texture.baseTexture.valid) return false;\n            if (line && !line.texture.baseTexture.valid) return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Offset the indices so that it works with the batcher.\n     *\n     * @protected\n     */\n    protected packBatches(): void\n    {\n        this.batchDirty++;\n        const batches = this.batches;\n\n        for (let i = 0, l = batches.length; i < l; i++)\n        {\n            const batch = batches[i];\n\n            for (let j = 0; j < batch.size; j++)\n            {\n                const index = batch.start + j;\n\n                this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;\n            }\n        }\n    }\n\n    protected isBatchable(): boolean\n    {\n        return false;\n\n        // prevent heavy mesh batching\n        // if (this.points.length > 0xffff * 2) {\n        //     return false;\n        // }\n        //\n        // const batches = this.batches;\n        //\n        // for (let i = 0; i < batches.length; i++) {\n        //     if ((batches[i].style as LineStyle).native) {\n        //         return false;\n        //     }\n        // }\n        //\n        // return (this.points.length < SmoothGraphicsGeometry.BATCHABLE_SIZE * 2);\n    }\n\n    /**\n     * Converts intermediate batches data to drawCalls.\n     *\n     * @protected\n     */\n    protected buildDrawCalls(shaderSettings?: IGraphicsBatchSettings)\n    {\n        for (let i = 0; i < this.drawCalls.length; i++)\n        {\n            this.drawCalls[i].clear();\n            DRAW_CALL_POOL.push(this.drawCalls[i]);\n        }\n\n        this.drawCalls.length = 0;\n\n        let currentGroup = DRAW_CALL_POOL.pop() || new BatchDrawCall();\n\n        currentGroup.begin(shaderSettings, null);\n\n        let index = 0;\n\n        this.drawCalls.push(currentGroup);\n\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            const batchData = this.batches[i];\n            const style = batchData.style as LineStyle;\n\n            if (batchData.attribSize === 0)\n            {\n                // I don't know how why do we have size=0 sometimes\n                continue;\n            }\n\n            let styleId = -1;\n            const mat = style.getTextureMatrix();\n\n            if (currentGroup.check(style.shader))\n            {\n                styleId = currentGroup.add(style.texture, mat,\n                    style.width, style.alignment || 0, style.packLineScale());\n            }\n            if (styleId < 0)\n            {\n                currentGroup = DRAW_CALL_POOL.pop() || new BatchDrawCall();\n                this.drawCalls.push(currentGroup);\n                currentGroup.begin(shaderSettings, style.shader);\n                currentGroup.start = index;\n                styleId = currentGroup.add(style.texture, mat,\n                    style.width, style.alignment || 0, style.packLineScale());\n            }\n            currentGroup.size += batchData.size;\n            index += batchData.size;\n\n            const { color, alpha } = style;\n            const bgr = Color.shared\n                .setValue(color)\n                .toLittleEndianNumber();\n\n            batchData.rgba = Color.shared\n                .setValue(bgr)\n                .toPremultiplied(alpha);\n            batchData.styleId = styleId;\n        }\n    }\n\n    protected processHoles(holes: Array<SmoothGraphicsData>): void\n    {\n        for (let i = 0; i < holes.length; i++)\n        {\n            const hole = holes[i];\n            const command = FILL_COMMANDS[hole.type];\n\n            hole.clearPath();\n\n            command.path(hole, this.buildData);\n\n            if (hole.matrix)\n            {\n                this.transformPoints(hole.points, hole.matrix);\n            }\n        }\n    }\n\n    /**\n     * Update the local bounds of the object. Expensive to use performance-wise.\n     *\n     * @protected\n     */\n    protected calculateBounds(): void\n    {\n        const bounds = this._bounds;\n        const sequenceBounds = tmpBounds;\n        let curMatrix = Matrix.IDENTITY;\n\n        this._bounds.clear();\n        sequenceBounds.clear();\n\n        for (let i = 0; i < this.graphicsData.length; i++)\n        {\n            const data = this.graphicsData[i];\n            const shape = data.shape;\n            const type = data.type;\n            const lineStyle = data.lineStyle;\n            const nextMatrix = data.matrix || Matrix.IDENTITY;\n            let lineWidth = 0.0;\n\n            if (lineStyle && lineStyle.visible)\n            {\n                lineWidth = lineStyle.width;\n\n                if (type !== SHAPES.POLY || data.fillStyle.visible)\n                {\n                    lineWidth *= Math.max(0, lineStyle.alignment);\n                }\n                else\n                {\n                    lineWidth *= Math.max(lineStyle.alignment, 1 - lineStyle.alignment);\n                }\n            }\n\n            if (curMatrix !== nextMatrix)\n            {\n                if (!sequenceBounds.isEmpty())\n                {\n                    bounds.addBoundsMatrix(sequenceBounds, curMatrix);\n                    sequenceBounds.clear();\n                }\n                curMatrix = nextMatrix;\n            }\n\n            if (type === SHAPES.RECT || type === SHAPES.RREC)\n            {\n                const rect = shape as Rectangle | RoundedRectangle;\n\n                sequenceBounds.addFramePad(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height,\n                    lineWidth, lineWidth);\n            }\n            else if (type === SHAPES.CIRC)\n            {\n                const circle = shape as Circle;\n\n                sequenceBounds.addFramePad(circle.x, circle.y, circle.x, circle.y,\n                    circle.radius + lineWidth, circle.radius + lineWidth);\n            }\n            else if (type === SHAPES.ELIP)\n            {\n                const ellipse = shape as Ellipse;\n\n                sequenceBounds.addFramePad(ellipse.x, ellipse.y, ellipse.x, ellipse.y,\n                    ellipse.width + lineWidth, ellipse.height + lineWidth);\n            }\n            else\n            {\n                const poly = shape as Polygon;\n                // adding directly to the bounds\n\n                bounds.addVerticesMatrix(curMatrix, (poly.points as any), 0, poly.points.length, lineWidth, lineWidth);\n            }\n        }\n\n        if (!sequenceBounds.isEmpty())\n        {\n            bounds.addBoundsMatrix(sequenceBounds, curMatrix);\n        }\n\n        bounds.pad(this.boundsPadding, this.boundsPadding);\n    }\n\n    /**\n     * Transform points using matrix.\n     *\n     * @protected\n     * @param {number[]} points - Points to transform\n     * @param {PIXI.Matrix} matrix - Transform matrix\n     */\n    protected transformPoints(points: Array<number>, matrix: Matrix): void\n    {\n        for (let i = 0; i < points.length / 2; i++)\n        {\n            const x = points[(i * 2)];\n            const y = points[(i * 2) + 1];\n\n            points[(i * 2)] = (matrix.a * x) + (matrix.c * y) + matrix.tx;\n            points[(i * 2) + 1] = (matrix.b * x) + (matrix.d * y) + matrix.ty;\n        }\n    }\n}\n"],"names":["Point","Bounds","Geometry","BuildData","Buffer","TYPES","SegmentPacker","SmoothGraphicsData","i","FILL_COMMANDS","Texture","SHAPES","WRAP_MODES","BatchPart","Matrix","matrixEquals","BatchDrawCall","Color"],"mappings":";;;;;;;;;;;AA6BO,MAAM,aAA+B,GAAC;AACtC,MAAM,iBAAuC,GAAC;AAErD,MAAM,QAAA,GAAW,IAAIA,UAAM,EAAA,CAAA;AAC3B,MAAM,SAAA,GAAY,IAAIC,cAAO,EAAA,CAAA;AAKtB,MAAM,+BAA+BC,aAC5C,CAAA;AAAA,EAiEI,WACA,GAAA;AACI,IAAM,KAAA,EAAA,CAAA;AA9DV,IAA2C,IAAA,CAAA,aAAA,GAAA,IAAA,CAAA;AAgEvC,IAAA,IAAA,CAAK,eAAe,KAAK,CAAA,CAAA;AAEzB,IAAK,IAAA,CAAA,SAAA,GAAY,IAAIC,mBAAU,EAAA,CAAA;AAE/B,IAAA,IAAA,CAAK,eAAe,EAAC,CAAA;AAErB,IAAA,IAAA,CAAK,KAAQ,GAAA,CAAA,CAAA;AAEb,IAAA,IAAA,CAAK,UAAa,GAAA,CAAA,CAAA,CAAA;AAElB,IAAA,IAAA,CAAK,UAAa,GAAA,CAAA,CAAA,CAAA;AAElB,IAAA,IAAA,CAAK,UAAa,GAAA,CAAA,CAAA;AAElB,IAAA,IAAA,CAAK,YAAY,EAAC,CAAA;AAElB,IAAA,IAAA,CAAK,UAAU,EAAC,CAAA;AAEhB,IAAA,IAAA,CAAK,eAAkB,GAAA,CAAA,CAAA;AAEvB,IAAA,IAAA,CAAK,eAAkB,GAAA,CAAA,CAAA;AAEvB,IAAK,IAAA,CAAA,OAAA,GAAU,IAAIF,cAAO,EAAA,CAAA;AAE1B,IAAA,IAAA,CAAK,WAAc,GAAA,CAAA,CAAA,CAAA;AAEnB,IAAA,IAAA,CAAK,aAAgB,GAAA,CAAA,CAAA;AAErB,IAAA,IAAA,CAAK,SAAY,GAAA,KAAA,CAAA;AAEjB,IAAA,IAAA,CAAK,aAAgB,GAAA,IAAA,CAAA;AAErB,IAAA,IAAA,CAAK,MAAS,GAAA,IAAA,CAAA;AACd,IAAA,IAAA,CAAK,QAAW,GAAA,CAAA,CAAA;AAChB,IAAA,IAAA,CAAK,WAAc,GAAA,IAAA,CAAA;AAAA,GACvB;AAAA,EA9FA,IAAI,MACJ,GAAA;AACI,IAAA,OAAO,KAAK,SAAU,CAAA,KAAA,CAAA;AAAA,GAC1B;AAAA,EAEA,IAAI,aACJ,GAAA;AACI,IAAA,OAAO,KAAK,SAAU,CAAA,aAAA,CAAA;AAAA,GAC1B;AAAA,EAwBA,eAAe,OACf,EAAA;AACI,IAAA,IAAA,CAAK,OAAU,GAAA,IAAIG,WAAO,CAAA,IAAA,EAAM,SAAS,KAAK,CAAA,CAAA;AAC9C,IAAK,IAAA,CAAA,aAAA,GAAgB,IAAI,YAAa,EAAA,CAAA;AACtC,IAAK,IAAA,CAAA,WAAA,GAAc,IAAI,WAAY,EAAA,CAAA;AAEnC,IAAA,IAAA,CAAK,YAAe,GAAA,IAAIA,WAAO,CAAA,IAAA,EAAM,SAAS,IAAI,CAAA,CAAA;AAClD,IAAA,IAAA,CAAK,YAAa,CAAA,OAAA,EAAS,IAAK,CAAA,OAAA,EAAS,GAAG,KAAO,EAAAC,UAAA,CAAM,KAAK,CAAA,CACzD,aAAa,SAAW,EAAA,IAAA,CAAK,OAAS,EAAA,CAAA,EAAG,OAAOA,UAAM,CAAA,KAAK,CAC3D,CAAA,YAAA,CAAa,WAAW,IAAK,CAAA,OAAA,EAAS,CAAG,EAAA,KAAA,EAAOA,WAAM,KAAK,CAAA,CAC3D,YAAa,CAAA,OAAA,EAAS,KAAK,OAAS,EAAA,CAAA,EAAG,KAAO,EAAAA,UAAA,CAAM,KAAK,CACzD,CAAA,YAAA,CAAa,SAAW,EAAA,IAAA,CAAK,OAAS,EAAA,CAAA,EAAG,KAAO,EAAAA,UAAA,CAAM,KAAK,CAE3D,CAAA,YAAA,CAAa,cAAgB,EAAA,IAAA,CAAK,SAAS,CAAG,EAAA,KAAA,EAAOA,UAAM,CAAA,KAAK,EAEhE,YAAa,CAAA,UAAA,EAAY,IAAK,CAAA,OAAA,EAAS,GAAG,KAAO,EAAAA,UAAA,CAAM,KAAK,CAAA,CAE5D,aAAa,QAAU,EAAA,IAAA,CAAK,OAAS,EAAA,CAAA,EAAG,MAAMA,UAAM,CAAA,aAAa,CACjE,CAAA,QAAA,CAAS,KAAK,YAAY,CAAA,CAAA;AAE/B,IAAA,IAAA,CAAK,YAAe,GAAA,EAAA,CAAA;AAAA,GACxB;AAAA,EA2CO,eAAA,CAAgB,WAAoB,cAC3C,EAAA;AACI,IAAA,IAAI,KAAK,MACT,EAAA;AACI,MAAA,OAAA;AAAA,KACJ;AACA,IAAK,IAAA,CAAA,MAAA,GAAS,IAAIC,2BAAc,EAAA,CAAA;AAChC,IAAA,IAAA,CAAK,WAAc,GAAA,cAAA,CAAA;AAAA,GACvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,IAAW,MACX,GAAA;AACI,IAAI,IAAA,IAAA,CAAK,WAAgB,KAAA,IAAA,CAAK,KAC9B,EAAA;AACI,MAAA,IAAA,CAAK,cAAc,IAAK,CAAA,KAAA,CAAA;AACxB,MAAA,IAAA,CAAK,eAAgB,EAAA,CAAA;AAAA,KACzB;AAEA,IAAA,OAAO,IAAK,CAAA,OAAA,CAAA;AAAA,GAChB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMU,UACV,GAAA;AACI,IAAA,IAAA,CAAK,WAAc,GAAA,CAAA,CAAA,CAAA;AACnB,IAAK,IAAA,CAAA,KAAA,EAAA,CAAA;AACL,IAAK,IAAA,CAAA,UAAA,EAAA,CAAA;AACL,IAAA,IAAA,CAAK,eAAkB,GAAA,CAAA,CAAA;AACvB,IAAA,IAAA,CAAK,eAAkB,GAAA,CAAA,CAAA;AACvB,IAAA,IAAA,CAAK,QAAW,GAAA,CAAA,CAAA;AAEhB,IAAA,IAAA,CAAK,UAAU,KAAM,EAAA,CAAA;AAErB,IAAA,KAAA,IAAS,IAAI,CAAG,EAAA,CAAA,GAAI,IAAK,CAAA,SAAA,CAAU,QAAQ,CAC3C,EAAA,EAAA;AACI,MAAK,IAAA,CAAA,SAAA,CAAU,CAAC,CAAA,CAAE,KAAM,EAAA,CAAA;AACxB,MAAA,cAAA,CAAe,IAAK,CAAA,IAAA,CAAK,SAAU,CAAA,CAAC,CAAC,CAAA,CAAA;AAAA,KACzC;AAEA,IAAA,IAAA,CAAK,UAAU,MAAS,GAAA,CAAA,CAAA;AAExB,IAAA,KAAA,IAAS,IAAI,CAAG,EAAA,CAAA,GAAI,IAAK,CAAA,OAAA,CAAQ,QAAQ,CACzC,EAAA,EAAA;AACI,MAAM,MAAA,SAAA,GAAY,IAAK,CAAA,OAAA,CAAQ,CAAC,CAAA,CAAA;AAEhC,MAAA,SAAA,CAAU,KAAM,EAAA,CAAA;AAChB,MAAA,UAAA,CAAW,KAAK,SAAS,CAAA,CAAA;AAAA,KAC7B;AAEA,IAAA,IAAA,CAAK,QAAQ,MAAS,GAAA,CAAA,CAAA;AAAA,GAC1B;AAAA,EAEO,KACP,GAAA;AACI,IAAI,IAAA,IAAA,CAAK,YAAa,CAAA,MAAA,GAAS,CAC/B,EAAA;AACI,MAAA,IAAA,CAAK,UAAW,EAAA,CAAA;AAChB,MAAK,IAAA,CAAA,UAAA,EAAA,CAAA;AACL,MAAA,IAAA,CAAK,aAAa,MAAS,GAAA,CAAA,CAAA;AAAA,KAC/B;AAEA,IAAO,OAAA,IAAA,CAAA;AAAA,GACX;AAAA,EAEO,UACH,KACA,EAAA,SAAA,GAAuB,MACvB,SAAuB,GAAA,IAAA,EACvB,SAAiB,IACrB,EAAA;AACI,IAAA,MAAM,OAAO,IAAIC,qCAAA,CAAmB,KAAO,EAAA,SAAA,EAAW,WAAW,MAAM,CAAA,CAAA;AAEvE,IAAK,IAAA,CAAA,YAAA,CAAa,KAAK,IAAI,CAAA,CAAA;AAC3B,IAAK,IAAA,CAAA,KAAA,EAAA,CAAA;AAEL,IAAO,OAAA,IAAA,CAAA;AAAA,GACX;AAAA,EAEO,QAAA,CAAS,KAAe,EAAA,MAAA,GAAiB,IAChD,EAAA;AACI,IAAI,IAAA,CAAC,IAAK,CAAA,YAAA,CAAa,MACvB,EAAA;AACI,MAAO,OAAA,IAAA,CAAA;AAAA,KACX;AAEA,IAAA,MAAM,OAAO,IAAIA,qCAAA,CAAmB,KAAO,EAAA,IAAA,EAAM,MAAM,MAAM,CAAA,CAAA;AAE7D,IAAA,MAAM,YAAY,IAAK,CAAA,YAAA,CAAa,IAAK,CAAA,YAAA,CAAa,SAAS,CAAC,CAAA,CAAA;AAEhE,IAAA,IAAA,CAAK,YAAY,SAAU,CAAA,SAAA,CAAA;AAE3B,IAAU,SAAA,CAAA,KAAA,CAAM,KAAK,IAAI,CAAA,CAAA;AAEzB,IAAK,IAAA,CAAA,KAAA,EAAA,CAAA;AAEL,IAAO,OAAA,IAAA,CAAA;AAAA,GACX;AAAA,EAEO,OACP,GAAA;AACI,IAAA,KAAA,CAAM,OAAQ,EAAA,CAAA;AAGd,IAAA,KAAA,IAAS,IAAI,CAAG,EAAA,CAAA,GAAI,KAAK,YAAa,CAAA,MAAA,EAAQ,EAAE,CAChD,EAAA;AACI,MAAK,IAAA,CAAA,YAAA,CAAa,CAAC,CAAA,CAAE,OAAQ,EAAA,CAAA;AAAA,KACjC;AAEA,IAAA,IAAA,CAAK,UAAU,OAAQ,EAAA,CAAA;AACvB,IAAA,IAAA,CAAK,SAAY,GAAA,IAAA,CAAA;AACjB,IAAA,IAAA,CAAK,YAAY,OAAQ,EAAA,CAAA;AACzB,IAAA,IAAA,CAAK,WAAc,GAAA,IAAA,CAAA;AACnB,IAAA,IAAA,CAAK,aAAa,MAAS,GAAA,CAAA,CAAA;AAC3B,IAAA,IAAA,CAAK,YAAe,GAAA,IAAA,CAAA;AACpB,IAAA,IAAA,CAAK,UAAU,MAAS,GAAA,CAAA,CAAA;AACxB,IAAA,IAAA,CAAK,SAAY,GAAA,IAAA,CAAA;AACjB,IAAA,IAAA,CAAK,QAAQ,MAAS,GAAA,CAAA,CAAA;AACtB,IAAA,IAAA,CAAK,OAAU,GAAA,IAAA,CAAA;AACf,IAAA,IAAA,CAAK,OAAU,GAAA,IAAA,CAAA;AAAA,GACnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,cAAc,KACrB,EAAA;AACI,IAAA,MAAM,eAAe,IAAK,CAAA,YAAA,CAAA;AAE1B,IAAA,KAAA,IAAS,IAAI,CAAG,EAAA,CAAA,GAAI,YAAa,CAAA,MAAA,EAAQ,EAAE,CAC3C,EAAA;AACI,MAAM,MAAA,IAAA,GAAO,aAAa,CAAC,CAAA,CAAA;AAE3B,MAAI,IAAA,CAAC,IAAK,CAAA,SAAA,CAAU,OACpB,EAAA;AACI,QAAA,SAAA;AAAA,OACJ;AAGA,MAAA,IAAI,KAAK,KACT,EAAA;AACI,QAAA,IAAI,KAAK,MACT,EAAA;AACI,UAAK,IAAA,CAAA,MAAA,CAAO,YAAa,CAAA,KAAA,EAAO,QAAQ,CAAA,CAAA;AAAA,SAG5C,MAAA;AACI,UAAA,QAAA,CAAS,SAAS,KAAK,CAAA,CAAA;AAAA,SAC3B;AAEA,QAAA,IAAI,KAAK,KAAM,CAAA,QAAA,CAAS,SAAS,CAAG,EAAA,QAAA,CAAS,CAAC,CAC9C,EAAA;AACI,UAAA,IAAI,OAAU,GAAA,KAAA,CAAA;AAEd,UAAA,IAAI,KAAK,KACT,EAAA;AACI,YAAA,KAAA,IAASC,KAAI,CAAGA,EAAAA,EAAAA,GAAI,IAAK,CAAA,KAAA,CAAM,QAAQA,EACvC,EAAA,EAAA;AACI,cAAM,MAAA,IAAA,GAAO,IAAK,CAAA,KAAA,CAAMA,EAAC,CAAA,CAAA;AAEzB,cAAA,IAAI,KAAK,KAAM,CAAA,QAAA,CAAS,SAAS,CAAG,EAAA,QAAA,CAAS,CAAC,CAC9C,EAAA;AACI,gBAAU,OAAA,GAAA,IAAA,CAAA;AACV,gBAAA,MAAA;AAAA,eACJ;AAAA,aACJ;AAAA,WACJ;AAEA,UAAA,IAAI,CAAC,OACL,EAAA;AACI,YAAO,OAAA,IAAA,CAAA;AAAA,WACX;AAAA,SACJ;AAAA,OACJ;AAAA,KACJ;AAEA,IAAO,OAAA,KAAA,CAAA;AAAA,GACX;AAAA,EAEA,YACA,GAAA;AAAA,GAEA;AAAA,EAEA,gBACA,GAAA;AACI,IAAA,IAAA,CAAK,OAAQ,CAAA,MAAA,CAAO,IAAI,YAAA,EAAc,CAAA,CAAA;AAAA,GAC1C;AAAA,EAEA,WACA,GAAA;AACI,IAAM,MAAA,EAAE,YAAc,EAAA,SAAA,EAAc,GAAA,IAAA,CAAA;AACpC,IAAA,MAAM,MAAM,YAAa,CAAA,MAAA,CAAA;AAEzB,IAAA,KAAA,IAAS,CAAI,GAAA,IAAA,CAAK,eAAiB,EAAA,CAAA,GAAI,KAAK,CAC5C,EAAA,EAAA;AACI,MAAM,MAAA,IAAA,GAAO,aAAa,CAAC,CAAA,CAAA;AAE3B,MAAA,IAAA,CAAK,WAAc,GAAA,CAAA,CAAA;AACnB,MAAA,IAAA,CAAK,SAAY,GAAA,CAAA,CAAA;AACjB,MAAA,IAAA,CAAK,SAAY,GAAA,CAAA,CAAA;AACjB,MAAA,IAAA,CAAK,OAAU,GAAA,CAAA,CAAA;AACf,MAAA,MAAM,EAAE,SAAA,EAAW,SAAW,EAAA,KAAA,EAAU,GAAA,IAAA,CAAA;AAExC,MAAA,IAAI,CAAC,SAAA,CAAU,OAAW,IAAA,CAAC,UAAU,OACrC,EAAA;AACI,QAAA,SAAA;AAAA,OACJ;AAEA,MAAM,MAAA,OAAA,GAAUC,mBAAc,CAAA,IAAA,CAAK,IAAI,CAAA,CAAA;AAEvC,MAAA,IAAA,CAAK,SAAU,EAAA,CAAA;AAEf,MAAQ,OAAA,CAAA,IAAA,CAAK,MAAM,SAAS,CAAA,CAAA;AAC5B,MAAA,IAAI,KAAK,MACT,EAAA;AACI,QAAA,IAAA,CAAK,eAAgB,CAAA,IAAA,CAAK,MAAQ,EAAA,IAAA,CAAK,MAAM,CAAA,CAAA;AAAA,OACjD;AAEA,MAAA,IAAA,CAAK,UAAW,EAAA,CAAA;AAChB,MAAI,IAAA,IAAA,CAAK,MAAO,CAAA,MAAA,IAAU,CAC1B,EAAA;AACI,QAAA,SAAA;AAAA,OACJ;AACA,MAAI,IAAA,SAAA,CAAU,OAAW,IAAA,SAAA,CAAU,OACnC,EAAA;AACI,QAAA,IAAA,CAAK,aAAa,KAAK,CAAA,CAAA;AAAA,OAC3B;AACA,MAAA,IAAI,UAAU,OACd,EAAA;AACI,QAAA,IAAA,CAAK,SAAU,IAAK,CAAA,SAAA,CAAkB,MAC/B,IAAA,IAAA,CAAK,UAAU,OAAY,KAAAC,YAAA,CAAQ,KACnC,IAAA,KAAA,CAAM,WAAW,CACjB,IAAA,EAAE,KAAK,WACP,IAAA,IAAA,CAAK,UAAU,OACf,IAAA,CAAC,IAAK,CAAA,SAAA,CAAU,UAChB,IAAK,CAAA,SAAA,CAAU,KAAS,IAAA,IAAA,IACxB,KAAK,SAAU,CAAA,KAAA,GAAQ,IAAK,CAAA,GAAA,CAAI,KAAK,SAAU,CAAA,SAAA,EAAW,IAAI,IAAK,CAAA,SAAA,CAAU,SAAS,CAAK,IAAA,KAAA,CAAA,CAAA;AAElG,QAAK,IAAA,CAAA,SAAA,GAAY,UAAU,MAAO,CAAA,MAAA,CAAA;AAElC,QAAA,IAAI,MAAM,MACV,EAAA;AACI,UAAAD,mBAAA,CAAcE,WAAO,CAAA,IAAI,CAAE,CAAA,IAAA,CAAK,MAAM,SAAS,CAAA,CAAA;AAAA,SAGnD,MAAA;AACI,UAAQ,OAAA,CAAA,IAAA,CAAK,MAAM,SAAS,CAAA,CAAA;AAAA,SAChC;AAEA,QAAA,IAAA,CAAK,OAAU,GAAA,SAAA,CAAU,MAAO,CAAA,MAAA,GAAS,IAAK,CAAA,SAAA,CAAA;AAAA,OAClD;AACA,MAAA,IAAI,UAAU,OACd,EAAA;AACI,QAAK,IAAA,CAAA,WAAA,GAAc,UAAU,MAAO,CAAA,MAAA,CAAA;AACpC,QAAQ,OAAA,CAAA,IAAA,CAAK,MAAM,SAAS,CAAA,CAAA;AAC5B,QAAA,KAAA,IAASH,EAAI,GAAA,CAAA,EAAGA,EAAI,GAAA,KAAA,CAAM,QAAQA,EAClC,EAAA,EAAA;AACI,UAAM,MAAA,IAAA,GAAO,MAAMA,EAAC,CAAA,CAAA;AAEpB,UAAAC,mBAAA,CAAc,IAAK,CAAA,IAAI,CAAE,CAAA,IAAA,CAAK,MAAM,SAAS,CAAA,CAAA;AAAA,SACjD;AACA,QAAA,IAAA,CAAK,SAAY,GAAA,SAAA,CAAU,MAAO,CAAA,MAAA,GAAS,IAAK,CAAA,WAAA,CAAA;AAAA,OACpD;AAAA,KACJ;AACA,IAAA,IAAA,CAAK,eAAkB,GAAA,GAAA,CAAA;AAAA,GAC3B;AAAA,EAEA,cAAc,cACd,EAAA;AACI,IAAI,IAAA,CAAC,IAAK,CAAA,YAAA,CAAa,MACvB,EAAA;AACI,MAAA,IAAA,CAAK,SAAY,GAAA,IAAA,CAAA;AAEjB,MAAA,OAAA;AAAA,KACJ;AACA,IAAA,IAAA,CAAK,WAAY,EAAA,CAAA;AAEjB,IAAI,IAAA,CAAC,IAAK,CAAA,gBAAA,EACV,EAAA;AACI,MAAA,OAAA;AAAA,KACJ;AAEA,IAAM,MAAA,EAAE,SAAW,EAAA,YAAA,EAAiB,GAAA,IAAA,CAAA;AACpC,IAAA,MAAM,MAAM,YAAa,CAAA,MAAA,CAAA;AAEzB,IAAA,IAAA,CAAK,aAAa,IAAK,CAAA,KAAA,CAAA;AAEvB,IAAA,IAAI,SAAuB,GAAA,IAAA,CAAA;AAE3B,IAAA,IAAI,YAAe,GAAA,IAAA,CAAA;AAEnB,IAAI,IAAA,IAAA,CAAK,OAAQ,CAAA,MAAA,GAAS,CAC1B,EAAA;AACI,MAAA,SAAA,GAAY,IAAK,CAAA,OAAA,CAAQ,IAAK,CAAA,OAAA,CAAQ,SAAS,CAAC,CAAA,CAAA;AAChD,MAAA,YAAA,GAAe,SAAU,CAAA,KAAA,CAAA;AAAA,KAC7B;AAEA,IAAA,KAAA,IAAS,CAAI,GAAA,IAAA,CAAK,eAAiB,EAAA,CAAA,GAAI,KAAK,CAC5C,EAAA,EAAA;AACI,MAAM,MAAA,IAAA,GAAO,aAAa,CAAC,CAAA,CAAA;AAC3B,MAAA,MAAM,YAAY,IAAK,CAAA,SAAA,CAAA;AACvB,MAAA,MAAM,YAAY,IAAK,CAAA,SAAA,CAAA;AAEvB,MAAA,IAAI,KAAK,MACT,EAAA;AACI,QAAA,IAAA,CAAK,eAAgB,CAAA,IAAA,CAAK,MAAQ,EAAA,IAAA,CAAK,MAAM,CAAA,CAAA;AAAA,OACjD;AACA,MAAA,IAAI,CAAC,SAAA,CAAU,OAAW,IAAA,CAAC,UAAU,OACrC,EAAA;AACI,QAAA,SAAA;AAAA,OACJ;AACA,MAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,CAAA,EAAG,CACvB,EAAA,EAAA;AACI,QAAM,MAAA,KAAA,GAAS,CAAM,KAAA,CAAA,GAAK,SAAY,GAAA,SAAA,CAAA;AAEtC,QAAA,IAAI,CAAC,KAAM,CAAA,OAAA;AAAS,UAAA,SAAA;AAEpB,QAAM,MAAA,WAAA,GAAc,MAAM,OAAQ,CAAA,WAAA,CAAA;AAClC,QAAA,MAAM,YAAY,SAAU,CAAA,UAAA,CAAA;AAC5B,QAAA,MAAM,WAAW,SAAU,CAAA,SAAA,CAAA;AAE3B,QAAA,WAAA,CAAY,WAAWG,eAAW,CAAA,MAAA,CAAA;AAClC,QAAA,IAAI,MAAM,CACV,EAAA;AACI,UAAK,IAAA,CAAA,MAAA,CAAO,iBAAiB,IAAK,CAAA,SAAA,EAAW,KAAK,OAAS,EAAA,IAAA,CAAK,SAAU,CAAA,MAAA,EAAQ,SAAS,CAAA,CAAA;AAAA,SAG/F,MAAA;AACI,UAAK,IAAA,CAAA,MAAA,CAAO,iBAAiB,IAAK,CAAA,WAAA,EAAa,KAAK,SAAW,EAAA,IAAA,CAAK,SAAU,CAAA,MAAA,EAAQ,SAAS,CAAA,CAAA;AAAA,SACnG;AAEA,QAAA,MAAM,aAAa,SAAU,CAAA,UAAA,CAAA;AAE7B,QAAA,IAAI,UAAe,KAAA,SAAA;AAAW,UAAA,SAAA;AAE9B,QAAA,IAAI,aAAa,CAAC,IAAA,CAAK,cAAe,CAAA,YAAA,EAAc,KAAK,CACzD,EAAA;AACI,UAAU,SAAA,CAAA,GAAA,CAAI,UAAU,SAAS,CAAA,CAAA;AACjC,UAAY,SAAA,GAAA,IAAA,CAAA;AAAA,SAChB;AAEA,QAAA,IAAI,CAAC,SACL,EAAA;AACI,UAAA,SAAA,GAAY,UAAW,CAAA,GAAA,EAAS,IAAA,IAAIC,mBAAU,EAAA,CAAA;AAC9C,UAAU,SAAA,CAAA,KAAA,CAAM,KAAO,EAAA,QAAA,EAAU,SAAS,CAAA,CAAA;AAC1C,UAAK,IAAA,CAAA,OAAA,CAAQ,KAAK,SAAS,CAAA,CAAA;AAC3B,UAAe,YAAA,GAAA,KAAA,CAAA;AAAA,SACnB;AAEA,QAAA,IAAI,MAAM,CACV,EAAA;AACI,UAAU,SAAA,CAAA,QAAA,GAAW,IAAK,CAAA,SAAA,GAAY,IAAK,CAAA,OAAA,CAAA;AAAA,SAG/C,MAAA;AACI,UAAU,SAAA,CAAA,QAAA,GAAW,IAAK,CAAA,WAAA,GAAc,IAAK,CAAA,SAAA,CAAA;AAAA,SACjD;AAAA,OACJ;AAAA,KACJ;AACA,IAAA,IAAA,CAAK,eAAkB,GAAA,GAAA,CAAA;AAEvB,IAAA,IAAI,SACJ,EAAA;AACI,MAAA,SAAA,CAAU,GAAI,CAAA,SAAA,CAAU,SAAW,EAAA,SAAA,CAAU,UAAU,CAAA,CAAA;AAAA,KAC3D;AAEA,IAAI,IAAA,IAAA,CAAK,OAAQ,CAAA,MAAA,KAAW,CAC5B,EAAA;AAGI,MAAA,IAAA,CAAK,SAAY,GAAA,IAAA,CAAA;AAEjB,MAAA,OAAA;AAAA,KACJ;AAGA,IAAK,IAAA,CAAA,SAAA,GAAY,KAAK,WAAY,EAAA,CAAA;AAElC,IAAA,IAAI,KAAK,SACT,EAAA;AACI,MAAA,IAAA,CAAK,WAAY,EAAA,CAAA;AAAA,KAGrB,MAAA;AACI,MAAA,IAAA,CAAK,eAAe,cAAc,CAAA,CAAA;AAClC,MAAA,IAAA,CAAK,UAAW,EAAA,CAAA;AAAA,KACpB;AAAA,GACJ;AAAA,EAEA,UACA,GAAA;AACI,IAAA,MAAM,EAAE,UAAA,EAAY,SAAU,EAAA,GAAI,IAAK,CAAA,SAAA,CAAA;AAEvC,IAAI,IAAA,IAAA,CAAK,aAAa,UACtB,EAAA;AACI,MAAA,OAAA;AAAA,KACJ;AAEA,IAAA,MAAM,EAAE,YAAA,EAAc,MAAQ,EAAA,SAAA,EAAW,SAAY,GAAA,IAAA,CAAA;AACrD,IAAA,MAAM,SAAS,IAAK,CAAA,OAAA,CAAA;AACpB,IAAA,MAAM,QAAQ,IAAK,CAAA,YAAA,CAAA;AACnB,IAAA,MAAM,aAAa,UAAa,GAAA,YAAA,CAAA;AAEhC,IAAI,IAAA,MAAA,CAAO,IAAK,CAAA,MAAA,KAAW,UAC3B,EAAA;AACI,MAAA,MAAM,MAAS,GAAA,IAAI,WAAY,CAAA,UAAA,GAAa,CAAC,CAAA,CAAA;AAE7C,MAAK,IAAA,CAAA,aAAA,GAAgB,IAAI,YAAA,CAAa,MAAM,CAAA,CAAA;AAC5C,MAAK,IAAA,CAAA,WAAA,GAAc,IAAI,WAAA,CAAY,MAAM,CAAA,CAAA;AACzC,MAAA,MAAA,CAAO,OAAO,IAAK,CAAA,aAAA,CAAA;AAAA,KACvB;AACA,IAAI,IAAA,KAAA,CAAM,IAAK,CAAA,MAAA,KAAW,SAC1B,EAAA;AACI,MAAI,IAAA,UAAA,GAAa,KAAU,IAAA,IAAA,CAAK,WAChC,EAAA;AACI,QAAM,KAAA,CAAA,IAAA,GAAO,IAAI,WAAA,CAAY,SAAS,CAAA,CAAA;AAAA,OAG1C,MAAA;AACI,QAAM,KAAA,CAAA,IAAA,GAAO,IAAI,WAAA,CAAY,SAAS,CAAA,CAAA;AAAA,OAC1C;AAAA,KACJ;AAEA,IAAA,MAAA,CAAO,UAAU,SAAW,EAAA,IAAA,CAAK,eAAe,IAAK,CAAA,WAAA,EAAa,MAAM,IAAmB,CAAA,CAAA;AAE3F,IAAA,IAAI,CAAI,GAAA,CAAA,CAAA;AAER,IAAA,KAAA,IAAS,IAAI,CAAG,EAAA,CAAA,GAAI,IAAK,CAAA,YAAA,CAAa,QAAQ,CAC9C,EAAA,EAAA;AACI,MAAM,MAAA,IAAA,GAAO,IAAK,CAAA,YAAA,CAAa,CAAC,CAAA,CAAA;AAEhC,MAAA,IAAI,KAAK,OACT,EAAA;AACI,QAAA,OAAO,OAAQ,CAAA,CAAC,CAAE,CAAA,QAAA,IAAY,KAAK,SACnC,EAAA;AACI,UAAA,CAAA,EAAA,CAAA;AAAA,SACJ;AACA,QAAO,MAAA,CAAA,uBAAA;AAAA,UAAwB,IAAK,CAAA,SAAA;AAAA,UAAW,IAAK,CAAA,OAAA;AAAA,UAAS,IAAK,CAAA,SAAA;AAAA,UAC9D,OAAA,CAAQ,CAAC,CAAE,CAAA,OAAA;AAAA,UAAS,OAAA,CAAQ,CAAC,CAAE,CAAA,IAAA;AAAA,SAAI,CAAA;AAAA,OAC3C;AACA,MAAA,IAAI,KAAK,SACT,EAAA;AACI,QAAA,OAAO,OAAQ,CAAA,CAAC,CAAE,CAAA,QAAA,IAAY,KAAK,WACnC,EAAA;AACI,UAAA,CAAA,EAAA,CAAA;AAAA,SACJ;AACA,QAAO,MAAA,CAAA,uBAAA;AAAA,UAAwB,IAAK,CAAA,WAAA;AAAA,UAAa,IAAK,CAAA,SAAA;AAAA,UAAW,IAAK,CAAA,SAAA;AAAA,UAClE,OAAA,CAAQ,CAAC,CAAE,CAAA,OAAA;AAAA,UAAS,OAAA,CAAQ,CAAC,CAAE,CAAA,IAAA;AAAA,SAAI,CAAA;AAAA,OAC3C;AAAA,KACJ;AAEA,IAAA,MAAA,CAAO,MAAO,EAAA,CAAA;AACd,IAAA,KAAA,CAAM,MAAO,EAAA,CAAA;AACb,IAAA,IAAA,CAAK,QAAW,GAAA,UAAA,CAAA;AAAA,GACpB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQU,cAAA,CAAe,QAA+B,MACxD,EAAA;AACI,IAAI,IAAA,CAAC,MAAU,IAAA,CAAC,MAChB,EAAA;AACI,MAAO,OAAA,KAAA,CAAA;AAAA,KACX;AAEA,IAAA,IAAI,MAAO,CAAA,OAAA,CAAQ,WAAgB,KAAA,MAAA,CAAO,QAAQ,WAClD,EAAA;AACI,MAAO,OAAA,KAAA,CAAA;AAAA,KACX;AAEA,IAAA,IAAI,OAAO,KAAQ,GAAA,MAAA,CAAO,UAAU,MAAO,CAAA,KAAA,GAAQ,OAAO,KAC1D,EAAA;AACI,MAAO,OAAA,KAAA,CAAA;AAAA,KACX;AAEA,IAAI,IAAA,MAAA,CAAO,MAAW,KAAA,MAAA,CAAO,MAC7B,EAAA;AACI,MAAO,OAAA,KAAA,CAAA;AAAA,KACX;AAEA,IAAK,IAAA,MAAA,CAAqB,KAAW,KAAA,MAAA,CAAqB,KAC1D,EAAA;AACI,MAAO,OAAA,KAAA,CAAA;AAAA,KACX;AACA,IAAK,IAAA,MAAA,CAAqB,SAAe,KAAA,MAAA,CAAqB,SAC9D,EAAA;AACI,MAAO,OAAA,KAAA,CAAA;AAAA,KACX;AACA,IAAK,IAAA,MAAA,CAAqB,SAAe,KAAA,MAAA,CAAqB,SAC9D,EAAA;AACI,MAAO,OAAA,KAAA,CAAA;AAAA,KACX;AAEA,IAAM,MAAA,IAAA,GAAO,MAAO,CAAA,MAAA,IAAUC,WAAO,CAAA,QAAA,CAAA;AACrC,IAAM,MAAA,IAAA,GAAO,MAAO,CAAA,MAAA,IAAUA,WAAO,CAAA,QAAA,CAAA;AAErC,IAAO,OAAAC,0BAAA,CAAa,MAAM,IAAI,CAAA,CAAA;AAAA,GAClC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOU,gBACV,GAAA;AACI,IAAA,IAAI,KAAK,KAAU,KAAA,IAAA,CAAK,cAAc,CAAC,IAAA,CAAK,aAAa,MACzD,EAAA;AACI,MAAO,OAAA,KAAA,CAAA;AAAA,KACX;AAEA,IAAS,KAAA,IAAA,CAAA,GAAI,GAAG,CAAI,GAAA,IAAA,CAAK,aAAa,MAAQ,EAAA,CAAA,GAAI,GAAG,CACrD,EAAA,EAAA;AACI,MAAM,MAAA,IAAA,GAAO,IAAK,CAAA,YAAA,CAAa,CAAC,CAAA,CAAA;AAChC,MAAA,MAAM,OAAO,IAAK,CAAA,SAAA,CAAA;AAClB,MAAA,MAAM,OAAO,IAAK,CAAA,SAAA,CAAA;AAElB,MAAA,IAAI,IAAQ,IAAA,CAAC,IAAK,CAAA,OAAA,CAAQ,WAAY,CAAA,KAAA;AAAO,QAAO,OAAA,KAAA,CAAA;AACpD,MAAA,IAAI,IAAQ,IAAA,CAAC,IAAK,CAAA,OAAA,CAAQ,WAAY,CAAA,KAAA;AAAO,QAAO,OAAA,KAAA,CAAA;AAAA,KACxD;AAEA,IAAO,OAAA,IAAA,CAAA;AAAA,GACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOU,WACV,GAAA;AACI,IAAK,IAAA,CAAA,UAAA,EAAA,CAAA;AACL,IAAA,MAAM,UAAU,IAAK,CAAA,OAAA,CAAA;AAErB,IAAA,KAAA,IAAS,IAAI,CAAG,EAAA,CAAA,GAAI,QAAQ,MAAQ,EAAA,CAAA,GAAI,GAAG,CAC3C,EAAA,EAAA;AACI,MAAM,MAAA,KAAA,GAAQ,QAAQ,CAAC,CAAA,CAAA;AAEvB,MAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,KAAA,CAAM,MAAM,CAChC,EAAA,EAAA;AACI,QAAM,MAAA,KAAA,GAAQ,MAAM,KAAQ,GAAA,CAAA,CAAA;AAE5B,QAAA,IAAA,CAAK,cAAc,KAAK,CAAA,GAAI,KAAK,aAAc,CAAA,KAAK,IAAI,KAAM,CAAA,WAAA,CAAA;AAAA,OAClE;AAAA,KACJ;AAAA,GACJ;AAAA,EAEU,WACV,GAAA;AACI,IAAO,OAAA,KAAA,CAAA;AAAA,GAgBX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOU,eAAe,cACzB,EAAA;AACI,IAAA,KAAA,IAAS,IAAI,CAAG,EAAA,CAAA,GAAI,IAAK,CAAA,SAAA,CAAU,QAAQ,CAC3C,EAAA,EAAA;AACI,MAAK,IAAA,CAAA,SAAA,CAAU,CAAC,CAAA,CAAE,KAAM,EAAA,CAAA;AACxB,MAAA,cAAA,CAAe,IAAK,CAAA,IAAA,CAAK,SAAU,CAAA,CAAC,CAAC,CAAA,CAAA;AAAA,KACzC;AAEA,IAAA,IAAA,CAAK,UAAU,MAAS,GAAA,CAAA,CAAA;AAExB,IAAA,IAAI,YAAe,GAAA,cAAA,CAAe,GAAI,EAAA,IAAK,IAAIC,2BAAc,EAAA,CAAA;AAE7D,IAAa,YAAA,CAAA,KAAA,CAAM,gBAAgB,IAAI,CAAA,CAAA;AAEvC,IAAA,IAAI,KAAQ,GAAA,CAAA,CAAA;AAEZ,IAAK,IAAA,CAAA,SAAA,CAAU,KAAK,YAAY,CAAA,CAAA;AAEhC,IAAA,KAAA,IAAS,IAAI,CAAG,EAAA,CAAA,GAAI,IAAK,CAAA,OAAA,CAAQ,QAAQ,CACzC,EAAA,EAAA;AACI,MAAM,MAAA,SAAA,GAAY,IAAK,CAAA,OAAA,CAAQ,CAAC,CAAA,CAAA;AAChC,MAAA,MAAM,QAAQ,SAAU,CAAA,KAAA,CAAA;AAExB,MAAI,IAAA,SAAA,CAAU,eAAe,CAC7B,EAAA;AAEI,QAAA,SAAA;AAAA,OACJ;AAEA,MAAA,IAAI,OAAU,GAAA,CAAA,CAAA,CAAA;AACd,MAAM,MAAA,GAAA,GAAM,MAAM,gBAAiB,EAAA,CAAA;AAEnC,MAAA,IAAI,YAAa,CAAA,KAAA,CAAM,KAAM,CAAA,MAAM,CACnC,EAAA;AACI,QAAA,OAAA,GAAU,YAAa,CAAA,GAAA;AAAA,UAAI,KAAM,CAAA,OAAA;AAAA,UAAS,GAAA;AAAA,UACtC,KAAM,CAAA,KAAA;AAAA,UAAO,MAAM,SAAa,IAAA,CAAA;AAAA,UAAG,MAAM,aAAc,EAAA;AAAA,SAAC,CAAA;AAAA,OAChE;AACA,MAAA,IAAI,UAAU,CACd,EAAA;AACI,QAAA,YAAA,GAAe,cAAe,CAAA,GAAA,EAAS,IAAA,IAAIA,2BAAc,EAAA,CAAA;AACzD,QAAK,IAAA,CAAA,SAAA,CAAU,KAAK,YAAY,CAAA,CAAA;AAChC,QAAa,YAAA,CAAA,KAAA,CAAM,cAAgB,EAAA,KAAA,CAAM,MAAM,CAAA,CAAA;AAC/C,QAAA,YAAA,CAAa,KAAQ,GAAA,KAAA,CAAA;AACrB,QAAA,OAAA,GAAU,YAAa,CAAA,GAAA;AAAA,UAAI,KAAM,CAAA,OAAA;AAAA,UAAS,GAAA;AAAA,UACtC,KAAM,CAAA,KAAA;AAAA,UAAO,MAAM,SAAa,IAAA,CAAA;AAAA,UAAG,MAAM,aAAc,EAAA;AAAA,SAAC,CAAA;AAAA,OAChE;AACA,MAAA,YAAA,CAAa,QAAQ,SAAU,CAAA,IAAA,CAAA;AAC/B,MAAA,KAAA,IAAS,SAAU,CAAA,IAAA,CAAA;AAEnB,MAAM,MAAA,EAAE,KAAO,EAAA,KAAA,EAAU,GAAA,KAAA,CAAA;AACzB,MAAA,MAAM,MAAMC,UAAM,CAAA,MAAA,CACb,QAAS,CAAA,KAAK,EACd,oBAAqB,EAAA,CAAA;AAE1B,MAAA,SAAA,CAAU,OAAOA,UAAM,CAAA,MAAA,CAClB,SAAS,GAAG,CAAA,CACZ,gBAAgB,KAAK,CAAA,CAAA;AAC1B,MAAA,SAAA,CAAU,OAAU,GAAA,OAAA,CAAA;AAAA,KACxB;AAAA,GACJ;AAAA,EAEU,aAAa,KACvB,EAAA;AACI,IAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,KAAA,CAAM,QAAQ,CAClC,EAAA,EAAA;AACI,MAAM,MAAA,IAAA,GAAO,MAAM,CAAC,CAAA,CAAA;AACpB,MAAM,MAAA,OAAA,GAAUR,mBAAc,CAAA,IAAA,CAAK,IAAI,CAAA,CAAA;AAEvC,MAAA,IAAA,CAAK,SAAU,EAAA,CAAA;AAEf,MAAQ,OAAA,CAAA,IAAA,CAAK,IAAM,EAAA,IAAA,CAAK,SAAS,CAAA,CAAA;AAEjC,MAAA,IAAI,KAAK,MACT,EAAA;AACI,QAAA,IAAA,CAAK,eAAgB,CAAA,IAAA,CAAK,MAAQ,EAAA,IAAA,CAAK,MAAM,CAAA,CAAA;AAAA,OACjD;AAAA,KACJ;AAAA,GACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOU,eACV,GAAA;AACI,IAAA,MAAM,SAAS,IAAK,CAAA,OAAA,CAAA;AACpB,IAAA,MAAM,cAAiB,GAAA,SAAA,CAAA;AACvB,IAAA,IAAI,YAAYK,WAAO,CAAA,QAAA,CAAA;AAEvB,IAAA,IAAA,CAAK,QAAQ,KAAM,EAAA,CAAA;AACnB,IAAA,cAAA,CAAe,KAAM,EAAA,CAAA;AAErB,IAAA,KAAA,IAAS,IAAI,CAAG,EAAA,CAAA,GAAI,IAAK,CAAA,YAAA,CAAa,QAAQ,CAC9C,EAAA,EAAA;AACI,MAAM,MAAA,IAAA,GAAO,IAAK,CAAA,YAAA,CAAa,CAAC,CAAA,CAAA;AAChC,MAAA,MAAM,QAAQ,IAAK,CAAA,KAAA,CAAA;AACnB,MAAA,MAAM,OAAO,IAAK,CAAA,IAAA,CAAA;AAClB,MAAA,MAAM,YAAY,IAAK,CAAA,SAAA,CAAA;AACvB,MAAM,MAAA,UAAA,GAAa,IAAK,CAAA,MAAA,IAAUA,WAAO,CAAA,QAAA,CAAA;AACzC,MAAA,IAAI,SAAY,GAAA,CAAA,CAAA;AAEhB,MAAI,IAAA,SAAA,IAAa,UAAU,OAC3B,EAAA;AACI,QAAA,SAAA,GAAY,SAAU,CAAA,KAAA,CAAA;AAEtB,QAAA,IAAI,IAAS,KAAAH,WAAA,CAAO,IAAQ,IAAA,IAAA,CAAK,UAAU,OAC3C,EAAA;AACI,UAAA,SAAA,IAAa,IAAK,CAAA,GAAA,CAAI,CAAG,EAAA,SAAA,CAAU,SAAS,CAAA,CAAA;AAAA,SAGhD,MAAA;AACI,UAAA,SAAA,IAAa,KAAK,GAAI,CAAA,SAAA,CAAU,SAAW,EAAA,CAAA,GAAI,UAAU,SAAS,CAAA,CAAA;AAAA,SACtE;AAAA,OACJ;AAEA,MAAA,IAAI,cAAc,UAClB,EAAA;AACI,QAAI,IAAA,CAAC,cAAe,CAAA,OAAA,EACpB,EAAA;AACI,UAAO,MAAA,CAAA,eAAA,CAAgB,gBAAgB,SAAS,CAAA,CAAA;AAChD,UAAA,cAAA,CAAe,KAAM,EAAA,CAAA;AAAA,SACzB;AACA,QAAY,SAAA,GAAA,UAAA,CAAA;AAAA,OAChB;AAEA,MAAA,IAAI,IAAS,KAAAA,WAAA,CAAO,IAAQ,IAAA,IAAA,KAASA,YAAO,IAC5C,EAAA;AACI,QAAA,MAAM,IAAO,GAAA,KAAA,CAAA;AAEb,QAAe,cAAA,CAAA,WAAA;AAAA,UAAY,IAAK,CAAA,CAAA;AAAA,UAAG,IAAK,CAAA,CAAA;AAAA,UAAG,IAAA,CAAK,IAAI,IAAK,CAAA,KAAA;AAAA,UAAO,IAAA,CAAK,IAAI,IAAK,CAAA,MAAA;AAAA,UAC1E,SAAA;AAAA,UAAW,SAAA;AAAA,SAAS,CAAA;AAAA,OAC5B,MAAA,IACS,IAAS,KAAAA,WAAA,CAAO,IACzB,EAAA;AACI,QAAA,MAAM,MAAS,GAAA,KAAA,CAAA;AAEf,QAAe,cAAA,CAAA,WAAA;AAAA,UAAY,MAAO,CAAA,CAAA;AAAA,UAAG,MAAO,CAAA,CAAA;AAAA,UAAG,MAAO,CAAA,CAAA;AAAA,UAAG,MAAO,CAAA,CAAA;AAAA,UAC5D,OAAO,MAAS,GAAA,SAAA;AAAA,UAAW,OAAO,MAAS,GAAA,SAAA;AAAA,SAAS,CAAA;AAAA,OAC5D,MAAA,IACS,IAAS,KAAAA,WAAA,CAAO,IACzB,EAAA;AACI,QAAA,MAAM,OAAU,GAAA,KAAA,CAAA;AAEhB,QAAe,cAAA,CAAA,WAAA;AAAA,UAAY,OAAQ,CAAA,CAAA;AAAA,UAAG,OAAQ,CAAA,CAAA;AAAA,UAAG,OAAQ,CAAA,CAAA;AAAA,UAAG,OAAQ,CAAA,CAAA;AAAA,UAChE,QAAQ,KAAQ,GAAA,SAAA;AAAA,UAAW,QAAQ,MAAS,GAAA,SAAA;AAAA,SAAS,CAAA;AAAA,OAG7D,MAAA;AACI,QAAA,MAAM,IAAO,GAAA,KAAA,CAAA;AAGb,QAAO,MAAA,CAAA,iBAAA,CAAkB,WAAY,IAAK,CAAA,MAAA,EAAgB,GAAG,IAAK,CAAA,MAAA,CAAO,MAAQ,EAAA,SAAA,EAAW,SAAS,CAAA,CAAA;AAAA,OACzG;AAAA,KACJ;AAEA,IAAI,IAAA,CAAC,cAAe,CAAA,OAAA,EACpB,EAAA;AACI,MAAO,MAAA,CAAA,eAAA,CAAgB,gBAAgB,SAAS,CAAA,CAAA;AAAA,KACpD;AAEA,IAAA,MAAA,CAAO,GAAI,CAAA,IAAA,CAAK,aAAe,EAAA,IAAA,CAAK,aAAa,CAAA,CAAA;AAAA,GACrD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASU,eAAA,CAAgB,QAAuB,MACjD,EAAA;AACI,IAAA,KAAA,IAAS,IAAI,CAAG,EAAA,CAAA,GAAI,MAAO,CAAA,MAAA,GAAS,GAAG,CACvC,EAAA,EAAA;AACI,MAAM,MAAA,CAAA,GAAI,MAAQ,CAAA,CAAA,GAAI,CAAE,CAAA,CAAA;AACxB,MAAA,MAAM,CAAI,GAAA,MAAA,CAAQ,CAAI,GAAA,CAAA,GAAK,CAAC,CAAA,CAAA;AAE5B,MAAQ,MAAA,CAAA,CAAA,GAAI,CAAE,CAAK,GAAA,MAAA,CAAO,IAAI,CAAM,GAAA,MAAA,CAAO,CAAI,GAAA,CAAA,GAAK,MAAO,CAAA,EAAA,CAAA;AAC3D,MAAQ,MAAA,CAAA,CAAA,GAAI,CAAK,GAAA,CAAC,CAAK,GAAA,MAAA,CAAO,IAAI,CAAM,GAAA,MAAA,CAAO,CAAI,GAAA,CAAA,GAAK,MAAO,CAAA,EAAA,CAAA;AAAA,KACnE;AAAA,GACJ;AACJ,CAAA;AA72Ba,sBAAA,CAEK,cAAiB,GAAA,GAAA;;;;;;"}