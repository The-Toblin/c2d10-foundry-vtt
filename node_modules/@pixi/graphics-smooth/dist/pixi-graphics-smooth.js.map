{"version":3,"file":"pixi-graphics-smooth.js","sources":["../src/core/BatchDrawCall.ts","../src/core/BatchPart.ts","../src/core/BuildData.ts","../src/core/const.ts","../src/core/FillStyle.ts","../src/core/LineStyle.ts","../src/core/SegmentPacker.ts","../src/core/SmoothGraphicsData.ts","../src/SmoothShader.ts","../src/DashLineShader.ts","../src/settings.ts","../src/shapes/CircleBuilder.ts","../src/shapes/PolyBuilder.ts","../src/shapes/RectangleBuilder.ts","../src/shapes/RoundedRectangleBuilder.ts","../src/shapes/index.ts","../src/SmoothGraphicsGeometry.ts","../src/SmoothGraphics.ts"],"sourcesContent":["import { BaseTexture, BatchTextureArray, BLEND_MODES, Matrix, Shader, Texture } from '@pixi/core';\n/**\n * @memberof PIXI.smooth\n */\nexport interface IGraphicsBatchSettings\n{\n    maxStyles: number;\n    maxTextures: number;\n    pixelLine: number;\n}\n\n/**\n * @memberof PIXI.smooth\n */\nexport function matrixEquals(th: Matrix, matrix: Matrix, eps = 1e-3)\n{\n    return th === matrix || (Math.abs(th.a - matrix.a) < eps\n        && Math.abs(th.b - matrix.b) < eps\n        && Math.abs(th.c - matrix.c) < eps\n        && Math.abs(th.d - matrix.d) < eps\n        && Math.abs(th.tx - matrix.tx) < eps\n        && Math.abs(th.ty - matrix.ty) < eps);\n}\n\n/**\n * @memberof PIXI.smooth\n */\nexport class BatchStyleArray\n{\n    public textureIds: number[];\n    public matrices: Matrix[];\n    public lines: number[];\n    public count: number;\n\n    constructor()\n    {\n        this.textureIds = [];\n        this.matrices = [];\n        this.lines = [];\n        this.count = 0;\n        // TODO: mapCoord for atlas cases\n        // TODO: gradients?\n    }\n\n    clear(): void\n    {\n        for (let i = 0; i < this.count; i++)\n        {\n            this.textureIds[i] = null;\n            this.matrices[i] = null;\n        }\n        this.count = 0;\n    }\n\n    add(textureId: number, matrix: Matrix,\n        lineWidth: number, lineAlignment: number, lineScaleMode: number,\n        settings: IGraphicsBatchSettings): number\n    {\n        const { textureIds, matrices, lines, count } = this;\n\n        textureId = (textureId * 4) + lineScaleMode;\n        for (let i = 0; i < count; i++)\n        {\n            if (lines[i * 2] === lineWidth && lines[(i * 2) + 1] === lineAlignment\n                && textureIds[i] === textureId && (matrixEquals(matrices[i], matrix)))\n            {\n                return i;\n            }\n        }\n        if (count >= settings.maxStyles)\n        {\n            return -1;\n        }\n        textureIds[count] = textureId;\n        matrices[count] = matrix;\n        lines[count * 2] = lineWidth;\n        lines[(count * 2) + 1] = lineAlignment;\n        this.count++;\n\n        return count;\n    }\n}\n\n/**\n * @memberof PIXI.smooth\n */\nexport class BatchDrawCall\n{\n    texArray: BatchTextureArray;\n    styleArray: BatchStyleArray;\n    blend: BLEND_MODES;\n    start: number;\n    size: number;\n    data: any;\n    shader: Shader;\n    TICK: number;\n    settings: IGraphicsBatchSettings;\n\n    constructor()\n    {\n        this.texArray = new BatchTextureArray();\n        this.styleArray = new BatchStyleArray();\n        this.shader = null;\n        this.blend = BLEND_MODES.NORMAL;\n\n        this.start = 0;\n        this.size = 0;\n        this.TICK = 0; // for filling textures\n        this.settings = null;\n        /**\n         * data for uniforms or custom webgl state\n         * @member {object}\n         */\n        this.data = null;\n    }\n\n    clear()\n    {\n        this.texArray.clear();\n        this.styleArray.clear();\n        this.settings = null;\n        this.data = null;\n        this.shader = null;\n    }\n\n    begin(settings: IGraphicsBatchSettings, shader: Shader)\n    {\n        this.TICK = ++BaseTexture._globalBatch;\n        this.settings = settings;\n        this.shader = shader;\n        // start and size calculated outside\n        this.start = 0;\n        this.size = 0;\n        this.data = null;\n        if (shader && (shader as any).settings)\n        {\n            this.settings = (shader as any).settings;\n        }\n    }\n\n    check(shader: Shader): boolean\n    {\n        if (this.size === 0)\n        {\n            this.shader = shader;\n\n            return true;\n        }\n\n        return (this.shader === shader);\n    }\n\n    add(texture: Texture, matrix: Matrix, lineWidth: number,\n        lineAlignment: number, lineScaleMode: number): number\n    {\n        const { texArray, TICK, styleArray, settings } = this;\n        const { baseTexture } = texture;\n        // check tex\n\n        if (baseTexture._batchEnabled !== TICK && texArray.count === settings.maxTextures)\n        {\n            return -1;\n        }\n        const loc = baseTexture._batchEnabled !== TICK ? texArray.count : baseTexture._batchLocation;\n        // check and add style\n        // add1 -> add2 only works in chain, not when there are several adds inside\n        const res = styleArray.add(loc, matrix || Matrix.IDENTITY,\n            lineWidth, lineAlignment, lineScaleMode, settings);\n\n        if (res >= 0)\n        {\n            // SUCCESS here\n            // add tex\n            if (baseTexture._batchEnabled !== TICK)\n            {\n                baseTexture._batchEnabled = TICK;\n                baseTexture._batchLocation = texArray.count;\n                texArray.elements[texArray.count++] = baseTexture;\n            }\n        }\n\n        return res;\n    }\n}\n","import { FillStyle } from './FillStyle';\nimport { LineStyle } from './LineStyle';\n\n/**\n * @memberof PIXI.smooth\n */\nexport class BatchPart\n{\n    public style: LineStyle | FillStyle;\n    public start: number;\n    public size: number;\n    public jointEnd: number;\n    public attribStart: number;\n    public attribSize: number;\n    public styleId: number;\n    public rgba: number;\n\n    constructor()\n    {\n        this.reset();\n    }\n\n    public begin(style: LineStyle | FillStyle, startIndex: number, attribStart: number): void\n    {\n        this.reset();\n        this.style = style;\n        this.start = startIndex;\n        this.attribStart = attribStart;\n        this.jointEnd = 0;\n    }\n\n    public end(endIndex: number, endAttrib: number): void\n    {\n        this.attribSize = endAttrib - this.attribStart;\n        this.size = endIndex - this.start;\n    }\n\n    public reset(): void\n    {\n        this.style = null;\n        this.size = 0;\n        this.start = 0;\n        this.attribStart = 0;\n        this.attribSize = 0;\n        this.styleId = -1;\n        this.rgba = 0;\n        this.jointEnd = 0;\n    }\n}\n","/**\n * @memberof PIXI.smooth\n */\nexport class BuildData\n{\n    verts: Array<number> = [];\n    joints: Array<number> = [];\n    vertexSize = 0;\n    indexSize = 0;\n    closePointEps = 1e-4;\n\n    clear()\n    {\n        this.verts.length = 0;\n        this.joints.length = 0;\n        this.vertexSize = 0;\n        this.indexSize = 0;\n    }\n\n    destroy()\n    {\n        this.verts.length = 0;\n        this.joints.length = 0;\n    }\n}\n","export enum JOINT_TYPE\n    {\n    NONE = 0,\n    FILL = 1,\n    JOINT_BEVEL = 4,\n    JOINT_MITER = 8,\n    JOINT_ROUND = 12,\n    JOINT_CAP_BUTT = 16,\n    JOINT_CAP_SQUARE = 18,\n    JOINT_CAP_ROUND = 20,\n    FILL_EXPAND = 24,\n    CAP_BUTT = 1 << 5,\n    CAP_SQUARE = 2 << 5,\n    CAP_ROUND = 3 << 5,\n    CAP_BUTT2 = 4 << 5,\n}\n","import { Shader, Texture } from '@pixi/core';\n\nimport type { Matrix } from '@pixi/core';\n\n/**\n * @memberof PIXI.smooth\n */\nexport class FillStyle\n{\n    constructor()\n    {\n        this.reset();\n    }\n\n    color: number;\n    alpha: number;\n    texture: Texture;\n    matrix: Matrix;\n    matrixTex: Matrix;\n    shader: Shader;\n    visible: boolean;\n    smooth: boolean;\n\n    toJSON()\n    {\n        return this.copyTo({});\n    }\n\n    clone(): FillStyle\n    {\n        return this.copyTo(new FillStyle());\n    }\n\n    copyTo(obj: any): any\n    {\n        obj.color = this.color;\n        obj.alpha = this.alpha;\n        obj.texture = this.texture;\n        obj.matrix = this.matrix;\n        obj.shader = this.shader;\n        obj.visible = this.visible;\n        obj.smooth = this.smooth;\n        obj.matrixTex = null;\n\n        return obj;\n    }\n\n    packLineScale()\n    {\n        return 0;\n    }\n\n    reset()\n    {\n        this.color = 0xFFFFFF;\n\n        this.alpha = 1;\n\n        this.texture = Texture.WHITE;\n\n        this.matrix = null;\n\n        this.shader = null;\n\n        this.visible = false;\n\n        this.smooth = false;\n\n        this.matrixTex = null;\n    }\n\n    destroy()\n    {\n        this.texture = null;\n        this.matrix = null;\n        this.matrixTex = null;\n    }\n\n    getTextureMatrix()\n    {\n        const tex = this.texture;\n\n        if (!this.matrix)\n        {\n            return null;\n        }\n\n        if (tex.frame.width === tex.baseTexture.width\n            && tex.frame.height === tex.baseTexture.height)\n        {\n            return this.matrix;\n        }\n\n        if (!this.matrixTex)\n        {\n            this.matrixTex = this.matrix.clone();\n        }\n        else\n        {\n            this.matrixTex.copyFrom(this.matrix);\n        }\n        this.matrixTex.translate(Number(tex.frame.x), Number(tex.frame.y));\n\n        return this.matrixTex;\n    }\n}\n","import { LINE_CAP, LINE_JOIN } from '@pixi/graphics';\nimport { FillStyle } from './FillStyle';\n\n/**\n * @memberof PIXI.smooth\n */\nexport enum LINE_SCALE_MODE\n    {\n    NONE = 'none',\n    NORMAL = 'normal',\n    HORIZONTAL = 'horizontal',\n    VERTICAL = 'vertical',\n}\n\n/**\n * @memberof PIXI.smooth\n */\nexport class LineStyle extends FillStyle\n{\n    width: number;\n    alignment: number;\n\n    cap: LINE_CAP;\n    join: LINE_JOIN;\n    miterLimit: number;\n    scaleMode: LINE_SCALE_MODE;\n\n    clone(): LineStyle\n    {\n        return this.copyTo(new LineStyle());\n    }\n\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    copyTo(obj: any): LineStyle\n    {\n        obj.color = this.color;\n        obj.alpha = this.alpha;\n        obj.texture = this.texture;\n        obj.matrix = this.matrix;\n        obj.shader = this.shader;\n        obj.visible = this.visible;\n        obj.width = this.width;\n        obj.alignment = this.alignment;\n        obj.cap = this.cap;\n        obj.join = this.join;\n        obj.miterLimit = this.miterLimit;\n        obj.scaleMode = this.scaleMode;\n\n        return obj;\n    }\n\n    /**\n     * returns width multiplied by scaleMode\n     */\n    packLineScale(): number\n    {\n        switch (this.scaleMode)\n        {\n            case LINE_SCALE_MODE.NORMAL: return 1;\n            case LINE_SCALE_MODE.HORIZONTAL: return 2;\n            case LINE_SCALE_MODE.VERTICAL: return 3;\n            default: return 0;\n        }\n    }\n\n    reset(): void\n    {\n        super.reset();\n\n        this.smooth = true;\n\n        this.color = 0x0;\n\n        this.width = 0;\n\n        this.alignment = 0.5;\n\n        this.cap = LINE_CAP.BUTT;\n        this.join = LINE_JOIN.MITER;\n        this.miterLimit = 10;\n        this.scaleMode = LINE_SCALE_MODE.NORMAL;\n    }\n}\n","import { BuildData } from './BuildData';\nimport { JOINT_TYPE } from './const';\n\n/**\n * @memberof PIXI.smooth\n */\nexport class SegmentPacker\n{\n    static vertsByJoint: Array<number> = [];\n\n    strideFloats = 12;\n\n    updateBufferSize(jointStart: number, jointLen: number, triangles: number, target: BuildData): void\n    {\n        const { joints } = target;\n        let foundTriangle = false;\n\n        let vertexSize = 0;\n        let indexSize = 0;\n\n        for (let i = jointStart; i < jointStart + jointLen; i++)\n        {\n            const prevCap = joints[i] & ~31;\n            const joint = joints[i] & 31;\n\n            if (joint === JOINT_TYPE.FILL)\n            {\n                foundTriangle = true;\n                vertexSize++;\n                continue;\n            }\n\n            if (joint >= JOINT_TYPE.FILL_EXPAND)\n            {\n                vertexSize += 3;\n                indexSize += 3;\n                continue;\n            }\n\n            const vs = SegmentPacker.vertsByJoint[joint] + SegmentPacker.vertsByJoint[prevCap];\n\n            if (vs >= 4)\n            {\n                vertexSize += vs;\n                indexSize += 6 + (3 * Math.max(vs - 6, 0));\n            }\n        }\n        if (foundTriangle)\n        {\n            indexSize += triangles;\n        }\n\n        target.vertexSize += vertexSize;\n        target.indexSize += indexSize;\n    }\n\n    bufferPos = 0;\n    indexPos = 0;\n    bufFloat: Float32Array;\n    bufUint: Uint32Array;\n    indices: Uint16Array;\n    buildData: BuildData;\n\n    beginPack(buildData: BuildData, bufFloat: Float32Array, bufUint: Uint32Array,\n        indices: Uint16Array, bufferPos = 0, indexPos = 0): void\n    {\n        this.buildData = buildData;\n        this.bufFloat = bufFloat;\n        this.bufUint = bufUint;\n        this.indices = indices;\n        this.bufferPos = bufferPos;\n        this.indexPos = indexPos;\n    }\n\n    endPack(): void\n    {\n        this.buildData = null;\n        this.bufFloat = null;\n        this.bufUint = null;\n        this.indices = null;\n    }\n\n    packInterleavedGeometry(jointStart: number, jointLen: number, triangles: number[],\n        lineStyle: number, color: number): void\n    {\n        const { bufFloat, bufUint, indices, buildData, strideFloats } = this;\n        const { joints, verts } = buildData;\n\n        let bufPos = this.bufferPos;\n        let indPos = this.indexPos;\n        let index = this.bufferPos / this.strideFloats;\n\n        // eslint-disable-next-line max-len\n        let x1: number; let y1: number;\n        let x2: number; let y2: number;\n        let prevX: number; let prevY: number;\n        let nextX: number; let nextY: number;\n        // let type: number;\n        let hasTriangle = false;\n\n        let travel = 0;\n\n        for (let j = jointStart; j < jointStart + jointLen; j++)\n        {\n            const fullJoint = joints[j];\n            const prevCap = joints[j] & ~31;\n            const joint = joints[j] & 31;\n\n            if (joint === JOINT_TYPE.FILL)\n            {\n                // just one vertex\n                hasTriangle = true;\n                x1 = verts[(j * 2)];\n                y1 = verts[(j * 2) + 1];\n                bufFloat[bufPos] = x1;\n                bufFloat[bufPos + 1] = y1;\n                bufFloat[bufPos + 2] = x1;\n                bufFloat[bufPos + 3] = y1;\n                bufFloat[bufPos + 4] = x1;\n                bufFloat[bufPos + 5] = y1;\n                bufFloat[bufPos + 6] = x1;\n                bufFloat[bufPos + 7] = y1;\n                bufFloat[bufPos + 8] = travel;\n                bufFloat[bufPos + 9] = 16 * joint;\n                bufFloat[bufPos + 10] = lineStyle;\n                bufUint[bufPos + 11] = color;\n                bufPos += strideFloats;\n                continue;\n            }\n\n            if (joint >= JOINT_TYPE.FILL_EXPAND)\n            {\n                prevX = verts[j * 2];\n                prevY = verts[(j * 2) + 1];\n                x1 = verts[(j * 2) + 2];\n                y1 = verts[(j * 2) + 3];\n                x2 = verts[(j * 2) + 4];\n                y2 = verts[(j * 2) + 5];\n\n                const bis = j + 3;\n\n                for (let i = 0; i < 3; i++)\n                {\n                    bufFloat[bufPos] = prevX;\n                    bufFloat[bufPos + 1] = prevY;\n                    bufFloat[bufPos + 2] = x1;\n                    bufFloat[bufPos + 3] = y1;\n                    bufFloat[bufPos + 4] = x2;\n                    bufFloat[bufPos + 5] = y2;\n                    bufFloat[bufPos + 6] = verts[(bis + i) * 2];\n                    bufFloat[bufPos + 7] = verts[((bis + i) * 2) + 1];\n\n                    bufFloat[bufPos + 8] = travel;\n                    bufFloat[bufPos + 9] = (16 * fullJoint) + i;\n                    bufFloat[bufPos + 10] = lineStyle;\n                    bufUint[bufPos + 11] = color;\n                    bufPos += strideFloats;\n                }\n\n                indices[indPos] = index;\n                indices[indPos + 1] = index + 1;\n                indices[indPos + 2] = index + 2;\n                indPos += 3;\n                index += 3;\n                continue;\n            }\n\n            const vs = SegmentPacker.vertsByJoint[joint] + SegmentPacker.vertsByJoint[prevCap];\n\n            if (vs === 0)\n            {\n                continue;\n            }\n            x1 = verts[j * 2];\n            y1 = verts[(j * 2) + 1];\n            x2 = verts[(j * 2) + 2];\n            y2 = verts[(j * 2) + 3];\n            // TODO: caps here\n            prevX = verts[(j * 2) - 2];\n            prevY = verts[(j * 2) - 1];\n\n            const dist = Math.sqrt(((x2 - x1) * (x2 - x1)) + ((y2 - y1) * (y2 - y1)));\n\n            if (SegmentPacker.vertsByJoint[joint] === 0)\n            {\n                travel -= dist;\n            }\n\n            if ((joint & ~2) !== JOINT_TYPE.JOINT_CAP_BUTT)\n            {\n                nextX = verts[(j * 2) + 4];\n                nextY = verts[(j * 2) + 5];\n            }\n            else\n            {\n                nextX = x1;\n                nextY = y1;\n            }\n            // type = joint;\n\n            for (let i = 0; i < vs; i++)\n            {\n                bufFloat[bufPos] = prevX;\n                bufFloat[bufPos + 1] = prevY;\n                bufFloat[bufPos + 2] = x1;\n                bufFloat[bufPos + 3] = y1;\n                bufFloat[bufPos + 4] = x2;\n                bufFloat[bufPos + 5] = y2;\n                bufFloat[bufPos + 6] = nextX;\n                bufFloat[bufPos + 7] = nextY;\n                bufFloat[bufPos + 8] = travel;\n                bufFloat[bufPos + 9] = (16 * fullJoint) + i;\n                bufFloat[bufPos + 10] = lineStyle;\n                bufUint[bufPos + 11] = color;\n                bufPos += strideFloats;\n            }\n\n            travel += dist;\n\n            indices[indPos] = index;\n            indices[indPos + 1] = index + 1;\n            indices[indPos + 2] = index + 2;\n            indices[indPos + 3] = index;\n            indices[indPos + 4] = index + 2;\n            indices[indPos + 5] = index + 3;\n            indPos += 6;\n            for (let j = 5; j + 1 < vs; j++)\n            {\n                indices[indPos] = index + 4;\n                indices[indPos + 1] = index + j;\n                indices[indPos + 2] = index + j + 1;\n                indPos += 3;\n            }\n            index += vs;\n        }\n\n        if (hasTriangle)\n        {\n            for (let i = 0; i < triangles.length; i++)\n            {\n                indices[indPos + i] = triangles[i] + index;\n            }\n            indPos += triangles.length;\n        }\n\n        this.bufferPos = bufPos;\n        this.indexPos = indPos;\n    }\n}\n\nconst verts = SegmentPacker.vertsByJoint;\n\nfor (let i = 0; i < 256; i++)\n{ verts.push(0); }\n// simple fill\nverts[JOINT_TYPE.FILL] = 1;\n\nfor (let i = 0; i < 8; i++)\n{\n    verts[JOINT_TYPE.FILL_EXPAND + i] = 3;\n}\n\n// no caps for now\nverts[JOINT_TYPE.JOINT_BEVEL] = 4 + 5;\nverts[JOINT_TYPE.JOINT_BEVEL + 1] = 4 + 5;\nverts[JOINT_TYPE.JOINT_BEVEL + 2] = 4 + 5;\nverts[JOINT_TYPE.JOINT_BEVEL + 3] = 4 + 5;\nverts[JOINT_TYPE.JOINT_ROUND] = 4 + 5;\nverts[JOINT_TYPE.JOINT_ROUND + 1] = 4 + 5;\nverts[JOINT_TYPE.JOINT_ROUND + 2] = 4 + 5;\nverts[JOINT_TYPE.JOINT_ROUND + 3] = 4 + 5;\nverts[JOINT_TYPE.JOINT_MITER] = 4 + 5;\nverts[JOINT_TYPE.JOINT_MITER + 1] = 4 + 5;\nverts[JOINT_TYPE.JOINT_MITER + 2] = 4;\nverts[JOINT_TYPE.JOINT_MITER + 3] = 4;\nverts[JOINT_TYPE.JOINT_CAP_BUTT] = 4;\nverts[JOINT_TYPE.JOINT_CAP_BUTT + 1] = 4;\nverts[JOINT_TYPE.JOINT_CAP_SQUARE] = 4;\nverts[JOINT_TYPE.JOINT_CAP_SQUARE + 1] = 4;\nverts[JOINT_TYPE.JOINT_CAP_ROUND] = 4 + 5;\nverts[JOINT_TYPE.JOINT_CAP_ROUND + 1] = 4 + 5;\n\nverts[JOINT_TYPE.CAP_ROUND] = 4;\n","import { LINE_CAP, LINE_JOIN } from '@pixi/graphics';\nimport { JOINT_TYPE } from './const';\nimport { FillStyle } from './FillStyle';\nimport { LineStyle } from './LineStyle';\n\nimport type { IShape, Matrix, SHAPES } from '@pixi/core';\n\n/**\n * A class to contain data useful for Graphics objects\n *\n * @memberof PIXI.smooth\n */\nexport class SmoothGraphicsData\n{\n    shape: IShape;\n    lineStyle: LineStyle;\n    fillStyle: FillStyle;\n    matrix: Matrix;\n    type: SHAPES;\n    holes: Array<SmoothGraphicsData>;\n\n    // result of simplification\n    closeStroke: boolean;\n    points: number[];\n    triangles: number[];\n    // indices in build\n    attribStart: number;\n    fillStart: number;\n    fillLen: number;\n    strokeStart: number;\n    strokeLen: number;\n    fillAA: boolean;\n\n    constructor(shape: IShape, fillStyle: FillStyle = null, lineStyle: LineStyle = null, matrix: Matrix = null)\n    {\n        this.shape = shape;\n\n        this.lineStyle = lineStyle;\n\n        this.fillStyle = fillStyle;\n\n        this.matrix = matrix;\n\n        this.type = shape.type;\n\n        this.points = [];\n\n        this.holes = [];\n\n        this.triangles = [];\n\n        this.closeStroke = false;\n\n        this.clearBuild();\n    }\n\n    public clearPath()\n    {\n        this.points.length = 0;\n        this.closeStroke = true;\n    }\n\n    public clearBuild()\n    {\n        this.triangles.length = 0;\n        this.fillStart = 0;\n        this.fillLen = 0;\n        this.strokeStart = 0;\n        this.strokeLen = 0;\n        this.fillAA = false;\n    }\n\n    public clone(): SmoothGraphicsData\n    {\n        return new SmoothGraphicsData(\n            this.shape,\n            this.fillStyle,\n            this.lineStyle,\n            this.matrix\n        );\n    }\n\n    public capType()\n    {\n        let cap: number;\n\n        switch (this.lineStyle.cap)\n        {\n            case LINE_CAP.SQUARE:\n                cap = JOINT_TYPE.CAP_SQUARE;\n                break;\n            case LINE_CAP.ROUND:\n                cap = JOINT_TYPE.CAP_ROUND;\n                break;\n            default:\n                cap = JOINT_TYPE.CAP_BUTT;\n                break;\n        }\n\n        return cap;\n    }\n\n    public goodJointType()\n    {\n        let joint: number;\n\n        switch (this.lineStyle.join)\n        {\n            case LINE_JOIN.BEVEL:\n                joint = JOINT_TYPE.JOINT_BEVEL;\n                break;\n            case LINE_JOIN.ROUND:\n                joint = JOINT_TYPE.JOINT_ROUND;\n                break;\n            default:\n                joint = JOINT_TYPE.JOINT_MITER + 3;\n                break;\n        }\n\n        return joint;\n    }\n\n    public jointType()\n    {\n        let joint: number;\n\n        switch (this.lineStyle.join)\n        {\n            case LINE_JOIN.BEVEL:\n                joint = JOINT_TYPE.JOINT_BEVEL;\n                break;\n            case LINE_JOIN.ROUND:\n                joint = JOINT_TYPE.JOINT_ROUND;\n                break;\n            default:\n                joint = JOINT_TYPE.JOINT_MITER;\n                break;\n        }\n\n        return joint;\n    }\n\n    public destroy(): void\n    {\n        this.shape = null;\n        this.holes.length = 0;\n        this.holes = null;\n        this.points.length = 0;\n        this.points = null;\n        this.lineStyle = null;\n        this.fillStyle = null;\n        this.triangles = null;\n    }\n}\n","import { Program, Shader } from '@pixi/core';\nimport { IGraphicsBatchSettings } from './core/BatchDrawCall';\n\nconst smoothVert = `#version 100\nprecision highp float;\nconst float FILL = 1.0;\nconst float BEVEL = 4.0;\nconst float MITER = 8.0;\nconst float ROUND = 12.0;\nconst float JOINT_CAP_BUTT = 16.0;\nconst float JOINT_CAP_SQUARE = 18.0;\nconst float JOINT_CAP_ROUND = 20.0;\n\nconst float FILL_EXPAND = 24.0;\n\nconst float CAP_BUTT = 1.0;\nconst float CAP_SQUARE = 2.0;\nconst float CAP_ROUND = 3.0;\nconst float CAP_BUTT2 = 4.0;\n\nconst float MITER_LIMIT = 10.0;\n\n// === geom ===\nattribute vec2 aPrev;\nattribute vec2 aPoint1;\nattribute vec2 aPoint2;\nattribute vec2 aNext;\nattribute float aVertexJoint;\nattribute float aTravel;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec4 vLine1;\nvarying vec4 vLine2;\nvarying vec4 vArc;\nvarying float vType;\n\nuniform float resolution;\nuniform float expand;\n\n// === style ===\nattribute float aStyleId;\nattribute vec4 aColor;\n\nvarying float vTextureId;\nvarying vec4 vColor;\nvarying vec2 vTextureCoord;\nvarying vec2 vTravel;\n\nuniform vec2 styleLine[%MAX_STYLES%];\nuniform vec3 styleMatrix[2 * %MAX_STYLES%];\nuniform float styleTextureId[%MAX_STYLES%];\nuniform vec2 samplerSize[%MAX_TEXTURES%];\n\nvec2 doBisect(vec2 norm, float len, vec2 norm2, float len2,\n    float dy, float inner) {\n    vec2 bisect = (norm + norm2) / 2.0;\n    bisect /= dot(norm, bisect);\n    vec2 shift = dy * bisect;\n    if (inner > 0.5) {\n        if (len < len2) {\n            if (abs(dy * (bisect.x * norm.y - bisect.y * norm.x)) > len) {\n                return dy * norm;\n            }\n        } else {\n            if (abs(dy * (bisect.x * norm2.y - bisect.y * norm2.x)) > len2) {\n                return dy * norm;\n            }\n        }\n    }\n    return dy * bisect;\n}\n\nvoid main(void){\n    vec2 pointA = (translationMatrix * vec3(aPoint1, 1.0)).xy;\n    vec2 pointB = (translationMatrix * vec3(aPoint2, 1.0)).xy;\n\n    vec2 xBasis = pointB - pointA;\n    float len = length(xBasis);\n    vec2 forward = xBasis / len;\n    vec2 norm = vec2(forward.y, -forward.x);\n\n    float type = floor(aVertexJoint / 16.0);\n    float vertexNum = aVertexJoint - type * 16.0;\n    float dx = 0.0, dy = 1.0;\n\n    float capType = floor(type / 32.0);\n    type -= capType * 32.0;\n\n    int styleId = int(aStyleId + 0.5);\n    float lineWidth = styleLine[styleId].x;\n    vTextureId = floor(styleTextureId[styleId] / 4.0);\n    float scaleMode = styleTextureId[styleId] - vTextureId * 4.0;\n    float avgScale = 1.0;\n    if (scaleMode > 2.5) {\n        avgScale = length(translationMatrix * vec3(1.0, 0.0, 0.0));\n    } else if (scaleMode > 1.5) {\n        avgScale = length(translationMatrix * vec3(0.0, 1.0, 0.0));\n    } else if (scaleMode > 0.5) {\n        vec2 avgDiag = (translationMatrix * vec3(1.0, 1.0, 0.0)).xy;\n        avgScale = sqrt(dot(avgDiag, avgDiag) * 0.5);\n    }\n    lineWidth *= 0.5 * avgScale;\n    float lineAlignment = 2.0 * styleLine[styleId].y - 1.0;\n    vTextureCoord = vec2(0.0);\n\n    vec2 pos;\n\n    if (capType == CAP_ROUND) {\n        vertexNum += 4.0;\n        type = JOINT_CAP_ROUND;\n        capType = 0.0;\n        lineAlignment = -lineAlignment;\n    }\n\n    vLine1 = vec4(0.0, 10.0, 1.0, 0.0);\n    vLine2 = vec4(0.0, 10.0, 1.0, 0.0);\n    vArc = vec4(0.0);\n    if (type == FILL) {\n        pos = pointA;\n        vType = 0.0;\n        vLine2 = vec4(-2.0, -2.0, -2.0, 0.0);\n        vec2 vTexturePixel;\n        vTexturePixel.x = dot(vec3(aPoint1, 1.0), styleMatrix[styleId * 2]);\n        vTexturePixel.y = dot(vec3(aPoint1, 1.0), styleMatrix[styleId * 2 + 1]);\n        vTextureCoord = vTexturePixel / samplerSize[int(vTextureId)];\n    } else if (type >= FILL_EXPAND && type < FILL_EXPAND + 7.5) {\n        // expand vertices\n        float flags = type - FILL_EXPAND;\n        float flag3 = floor(flags / 4.0);\n        float flag2 = floor((flags - flag3 * 4.0) / 2.0);\n        float flag1 = flags - flag3 * 4.0 - flag2 * 2.0;\n\n        vec2 prev = (translationMatrix * vec3(aPrev, 1.0)).xy;\n\n        if (vertexNum < 0.5) {\n            pos = prev;\n        } else if (vertexNum < 1.5) {\n            pos = pointA;\n        } else {\n            pos = pointB;\n        }\n        float len2 = length(aNext);\n        vec2 bisect = (translationMatrix * vec3(aNext, 0.0)).xy;\n        if (len2 > 0.01) {\n            bisect = normalize(bisect) * len2;\n        }\n\n        vec2 n1 = normalize(vec2(pointA.y - prev.y, -(pointA.x - prev.x)));\n        vec2 n2 = normalize(vec2(pointB.y - pointA.y, -(pointB.x - pointA.x)));\n        vec2 n3 = normalize(vec2(prev.y - pointB.y, -(prev.x - pointB.x)));\n\n        if (n1.x * n2.y - n1.y * n2.x < 0.0) {\n            n1 = -n1;\n            n2 = -n2;\n            n3 = -n3;\n        }\n        pos += bisect * expand;\n\n        vLine1 = vec4(16.0, 16.0, 16.0, -1.0);\n        if (flag1 > 0.5) {\n            vLine1.x = -dot(pos - prev, n1);\n        }\n        if (flag2 > 0.5) {\n            vLine1.y = -dot(pos - pointA, n2);\n        }\n        if (flag3 > 0.5) {\n            vLine1.z = -dot(pos - pointB, n3);\n        }\n        vLine1.xyz *= resolution;\n        vType = 2.0;\n    } else if (type >= BEVEL) {\n        float dy = lineWidth + expand;\n        float shift = lineWidth * lineAlignment;\n        float inner = 0.0;\n        if (vertexNum >= 1.5) {\n            dy = -dy;\n            inner = 1.0;\n        }\n\n        vec2 base, next, xBasis2, bisect;\n        float flag = 0.0;\n        float side2 = 1.0;\n        if (vertexNum < 0.5 || vertexNum > 2.5 && vertexNum < 3.5) {\n            next = (translationMatrix * vec3(aPrev, 1.0)).xy;\n            base = pointA;\n            flag = type - floor(type / 2.0) * 2.0;\n            side2 = -1.0;\n        } else {\n            next = (translationMatrix * vec3(aNext, 1.0)).xy;\n            base = pointB;\n            if (type >= MITER && type < MITER + 3.5) {\n                flag = step(MITER + 1.5, type);\n                // check miter limit here?\n            }\n        }\n        xBasis2 = next - base;\n        float len2 = length(xBasis2);\n        vec2 norm2 = vec2(xBasis2.y, -xBasis2.x) / len2;\n        float D = norm.x * norm2.y - norm.y * norm2.x;\n        if (D < 0.0) {\n            inner = 1.0 - inner;\n        }\n\n        norm2 *= side2;\n\n        float collinear = step(0.0, dot(norm, norm2));\n\n        vType = 0.0;\n        float dy2 = -1000.0;\n\n        if (abs(D) < 0.01 && collinear < 0.5) {\n            if (type >= ROUND && type < ROUND + 1.5) {\n                type = JOINT_CAP_ROUND;\n            }\n            //TODO: BUTT here too\n        }\n\n        vLine1 = vec4(0.0, lineWidth, max(abs(norm.x), abs(norm.y)), min(abs(norm.x), abs(norm.y)));\n        vLine2 = vec4(0.0, lineWidth, max(abs(norm2.x), abs(norm2.y)), min(abs(norm2.x), abs(norm2.y)));\n\n        if (vertexNum < 3.5) {\n            if (abs(D) < 0.01 && collinear < 0.5) {\n                pos = (shift + dy) * norm;\n            } else {\n                if (flag < 0.5 && inner < 0.5) {\n                    pos = (shift + dy) * norm;\n                } else {\n                    pos = doBisect(norm, len, norm2, len2, shift + dy, inner);\n                }\n            }\n            vLine2.y = -1000.0;\n            if (capType >= CAP_BUTT && capType < CAP_ROUND) {\n                float extra = step(CAP_SQUARE, capType) * lineWidth;\n                vec2 back = -forward;\n                if (vertexNum < 0.5 || vertexNum > 2.5) {\n                    pos += back * (expand + extra);\n                    dy2 = expand;\n                } else {\n                    dy2 = dot(pos + base - pointA, back) - extra;\n                }\n            }\n            if (type >= JOINT_CAP_BUTT && type < JOINT_CAP_SQUARE + 0.5) {\n                float extra = step(JOINT_CAP_SQUARE, type) * lineWidth;\n                if (vertexNum < 0.5 || vertexNum > 2.5) {\n                    vLine2.y = dot(pos + base - pointB, forward) - extra;\n                } else {\n                    pos += forward * (expand + extra);\n                    vLine2.y = expand;\n                    if (capType >= CAP_BUTT) {\n                        dy2 -= expand + extra;\n                    }\n                }\n            }\n        } else if (type >= JOINT_CAP_ROUND && type < JOINT_CAP_ROUND + 1.5) {\n            base += shift * norm;\n            if (inner > 0.5) {\n                dy = -dy;\n                inner = 0.0;\n            }\n            vec2 d2 = abs(dy) * forward;\n            if (vertexNum < 4.5) {\n                dy = -dy;\n                pos = dy * norm;\n            } else if (vertexNum < 5.5) {\n                pos = dy * norm;\n            } else if (vertexNum < 6.5) {\n                pos = dy * norm + d2;\n                vArc.x = abs(dy);\n            } else {\n                dy = -dy;\n                pos = dy * norm + d2;\n                vArc.x = abs(dy);\n            }\n            vLine2 = vec4(0.0, lineWidth * 2.0 + 10.0, 1.0  , 0.0); // forget about line2 with type=3\n            vArc.y = dy;\n            vArc.z = 0.0;\n            vArc.w = lineWidth;\n            vType = 3.0;\n        } else if (abs(D) < 0.01 && collinear < 0.5) {\n            pos = dy * norm;\n        } else {\n            if (inner > 0.5) {\n                dy = -dy;\n                inner = 0.0;\n            }\n            float side = sign(dy);\n            vec2 norm3 = normalize(norm + norm2);\n\n            if (type >= MITER && type < MITER + 3.5) {\n                vec2 farVertex = doBisect(norm, len, norm2, len2, shift + dy, 0.0);\n                if (length(farVertex) > abs(shift + dy) * MITER_LIMIT) {\n                    type = BEVEL;\n                }\n            }\n\n            if (vertexNum < 4.5) {\n                pos = doBisect(norm, len, norm2, len2, shift - dy, 1.0);\n            } else if (vertexNum < 5.5) {\n                pos = (shift + dy) * norm;\n            } else if (vertexNum > 7.5) {\n                pos = (shift + dy) * norm2;\n            } else {\n                if (type >= ROUND && type < ROUND + 1.5) {\n                    pos = doBisect(norm, len, norm2, len2, shift + dy, 0.0);\n                    float d2 = abs(shift + dy);\n                    if (length(pos) > abs(shift + dy) * 1.5) {\n                        if (vertexNum < 6.5) {\n                            pos.x = (shift + dy) * norm.x - d2 * norm.y;\n                            pos.y = (shift + dy) * norm.y + d2 * norm.x;\n                        } else {\n                            pos.x = (shift + dy) * norm2.x + d2 * norm2.y;\n                            pos.y = (shift + dy) * norm2.y - d2 * norm2.x;\n                        }\n                    }\n                } else if (type >= MITER && type < MITER + 3.5) {\n                    pos = doBisect(norm, len, norm2, len2, shift + dy, 0.0); //farVertex\n                } else if (type >= BEVEL && type < BEVEL + 1.5) {\n                    float d2 = side / resolution;\n                    if (vertexNum < 6.5) {\n                        pos = (shift + dy) * norm + d2 * norm3;\n                    } else {\n                        pos = (shift + dy) * norm2 + d2 * norm3;\n                    }\n                }\n            }\n\n            if (type >= ROUND && type < ROUND + 1.5) {\n                vArc.x = side * dot(pos, norm3);\n                vArc.y = pos.x * norm3.y - pos.y * norm3.x;\n                vArc.z = dot(norm, norm3) * (lineWidth + side * shift);\n                vArc.w = lineWidth + side * shift;\n                vType = 3.0;\n            } else if (type >= MITER && type < MITER + 3.5) {\n                vType = 1.0;\n            } else if (type >= BEVEL && type < BEVEL + 1.5) {\n                vType = 4.0;\n                vArc.z = dot(norm, norm3) * (lineWidth + side * shift) - side * dot(pos, norm3);\n            }\n\n            dy = side * (dot(pos, norm) - shift);\n            dy2 = side * (dot(pos, norm2) - shift);\n        }\n\n        pos += base;\n        vLine1.xy = vec2(dy, vLine1.y) * resolution;\n        vLine2.xy = vec2(dy2, vLine2.y) * resolution;\n        vArc = vArc * resolution;\n        vTravel = vec2(aTravel * avgScale + dot(pos - pointA, vec2(-norm.y, norm.x)), avgScale);\n    }\n\n    gl_Position = vec4((projectionMatrix * vec3(pos, 1.0)).xy, 0.0, 1.0);\n\n    vColor = aColor * tint;\n}`;\n\nconst precision = `#version 100\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n`;\n\nconst smoothFrag = `%PRECISION%\nvarying vec4 vColor;\nvarying vec4 vLine1;\nvarying vec4 vLine2;\nvarying vec4 vArc;\nvarying float vType;\nvarying float vTextureId;\nvarying vec2 vTextureCoord;\nvarying vec2 vTravel;\nuniform sampler2D uSamplers[%MAX_TEXTURES%];\n\n%PIXEL_LINE%\n\nvoid main(void){\n    %PIXEL_COVERAGE%\n\n    vec4 texColor;\n    float textureId = floor(vTextureId+0.5);\n    %FOR_LOOP%\n\n    gl_FragColor = vColor * texColor * alpha;\n}\n`;\n\nconst pixelLineFunc = [`\nfloat pixelLine(float x, float A, float B) {\n    return clamp(x + 0.5, 0.0, 1.0);\n}\n`, `\nfloat pixelLine(float x, float A, float B) {\n    float y = abs(x), s = sign(x);\n    if (y * 2.0 < A - B) {\n        return 0.5 + s * y / A;\n    }\n    y -= (A - B) * 0.5;\n    y = max(1.0 - y / B, 0.0);\n    return (1.0 + s * (1.0 - y * y)) * 0.5;\n    //return clamp(x + 0.5, 0.0, 1.0);\n}\n`];\n\nconst pixelCoverage = `float alpha = 1.0;\nif (vType < 0.5) {\n    float left = pixelLine(-vLine1.y - vLine1.x, vLine1.z, vLine1.w);\n    float right = pixelLine(vLine1.y - vLine1.x, vLine1.z, vLine1.w);\n    float near = vLine2.x - 0.5;\n    float far = min(vLine2.x + 0.5, 0.0);\n    float top = vLine2.y - 0.5;\n    float bottom = min(vLine2.y + 0.5, 0.0);\n    alpha = (right - left) * max(bottom - top, 0.0) * max(far - near, 0.0);\n} else if (vType < 1.5) {\n    float a1 = pixelLine(- vLine1.y - vLine1.x, vLine1.z, vLine1.w);\n    float a2 = pixelLine(vLine1.y - vLine1.x, vLine1.z, vLine1.w);\n    float b1 = pixelLine(- vLine2.y - vLine2.x, vLine2.z, vLine2.w);\n    float b2 = pixelLine(vLine2.y - vLine2.x, vLine2.z, vLine2.w);\n    alpha = a2 * b2 - a1 * b1;\n} else if (vType < 2.5) {\n    alpha *= max(min(vLine1.x + 0.5, 1.0), 0.0);\n    alpha *= max(min(vLine1.y + 0.5, 1.0), 0.0);\n    alpha *= max(min(vLine1.z + 0.5, 1.0), 0.0);\n} else if (vType < 3.5) {\n    float a1 = pixelLine(- vLine1.y - vLine1.x, vLine1.z, vLine1.w);\n    float a2 = pixelLine(vLine1.y - vLine1.x, vLine1.z, vLine1.w);\n    float b1 = pixelLine(- vLine2.y - vLine2.x, vLine2.z, vLine2.w);\n    float b2 = pixelLine(vLine2.y - vLine2.x, vLine2.z, vLine2.w);\n    float alpha_miter = a2 * b2 - a1 * b1;\n    float alpha_plane = clamp(vArc.z - vArc.x + 0.5, 0.0, 1.0);\n    float d = length(vArc.xy);\n    float circle_hor = max(min(vArc.w, d + 0.5) - max(-vArc.w, d - 0.5), 0.0);\n    float circle_vert = min(vArc.w * 2.0, 1.0);\n    float alpha_circle = circle_hor * circle_vert;\n    alpha = min(alpha_miter, max(alpha_circle, alpha_plane));\n} else {\n    float a1 = pixelLine(- vLine1.y - vLine1.x, vLine1.z, vLine1.w);\n    float a2 = pixelLine(vLine1.y - vLine1.x, vLine1.z, vLine1.w);\n    float b1 = pixelLine(- vLine2.y - vLine2.x, vLine2.z, vLine2.w);\n    float b2 = pixelLine(vLine2.y - vLine2.x, vLine2.z, vLine2.w);\n    alpha = a2 * b2 - a1 * b1;\n    alpha *= clamp(vArc.z + 0.5, 0.0, 1.0);\n}\n`;\n\n/**\n * @memberof PIXI.smooth\n */\nexport class SmoothGraphicsShader extends Shader\n{\n    settings: IGraphicsBatchSettings;\n\n    constructor(settings: IGraphicsBatchSettings,\n        vert = smoothVert,\n        frag = smoothFrag,\n        uniforms = {})\n    {\n        vert = SmoothGraphicsShader.generateVertexSrc(settings, vert);\n        frag = SmoothGraphicsShader.generateFragmentSrc(settings, frag);\n\n        const { maxStyles, maxTextures } = settings;\n        const sampleValues = new Int32Array(maxTextures);\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            sampleValues[i] = i;\n        }\n        super(Program.from(vert, frag), (Object as any).assign(uniforms, {\n            styleMatrix: new Float32Array(6 * maxStyles),\n            styleTextureId: new Float32Array(maxStyles),\n            styleLine: new Float32Array(2 * maxStyles),\n            samplerSize: new Float32Array(2 * maxTextures),\n            uSamplers: sampleValues,\n            tint: new Float32Array([1, 1, 1, 1]),\n            resolution: 1,\n            expand: 1,\n        }));\n        this.settings = settings;\n    }\n\n    static generateVertexSrc(settings: IGraphicsBatchSettings, vertexSrc = smoothVert): string\n    {\n        const { maxStyles, maxTextures } = settings;\n\n        vertexSrc = vertexSrc.replace(/%MAX_TEXTURES%/gi, `${maxTextures}`)\n            .replace(/%MAX_STYLES%/gi, `${maxStyles}`);\n\n        return vertexSrc;\n    }\n\n    static generateFragmentSrc(settings: IGraphicsBatchSettings, fragmentSrc = smoothFrag): string\n    {\n        const { maxTextures, pixelLine } = settings;\n\n        fragmentSrc = fragmentSrc.replace(/%PRECISION%/gi, precision)\n            .replace(/%PIXEL_LINE%/gi, pixelLineFunc[pixelLine])\n            .replace(/%PIXEL_COVERAGE%/gi, pixelCoverage)\n            .replace(/%MAX_TEXTURES%/gi, `${maxTextures}`)\n            .replace(/%FOR_LOOP%/gi, this.generateSampleSrc(maxTextures));\n\n        return fragmentSrc;\n    }\n\n    static generateSampleSrc(maxTextures: number): string\n    {\n        let src = '';\n\n        src += '\\n';\n        src += '\\n';\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            if (i > 0)\n            {\n                src += '\\nelse ';\n            }\n\n            if (i < maxTextures - 1)\n            {\n                src += `if(textureId < ${i}.5)`;\n            }\n\n            src += '\\n{';\n            src += `\\n\\ttexColor = texture2D(uSamplers[${i}], vTextureCoord);`;\n            src += '\\n}';\n        }\n\n        src += '\\n';\n        src += '\\n';\n\n        return src;\n    }\n}\n","import { SmoothGraphicsShader } from './SmoothShader';\n\nconst dashFrag = `%PRECISION%\nvarying vec4 vColor;\nvarying vec4 vLine1;\nvarying vec4 vLine2;\nvarying vec4 vArc;\nvarying float vType;\nvarying float vTextureId;\nvarying vec2 vTextureCoord;\nvarying vec2 vTravel;\nuniform sampler2D uSamplers[%MAX_TEXTURES%];\nuniform float dash;\nuniform float gap;\n\n%PIXEL_LINE%\n\nvoid main(void){\n    %PIXEL_COVERAGE%\n\n    float d = dash * vTravel.y;\n    if (d > 0.0) {\n        float g = gap * vTravel.y;\n        if (g > 0.0) {\n            float t = mod(vTravel.x, d + g);\n            alpha *= mix(\n                min(0.5 * d + 0.5 - abs(t - 0.5 * d), 1.0),\n                max(abs(t - 0.5 * g - d) - 0.5 * g + 0.5, 0.0),\n                step(d, t)\n            );\n        }\n    } else {\n        alpha = 0.0;\n    }\n\n    vec4 texColor;\n    float textureId = floor(vTextureId+0.5);\n    %FOR_LOOP%\n\n    gl_FragColor = vColor * texColor * alpha;\n}\n`;\n\n/**\n * @memberof PIXI.smooth\n */\nexport interface IDashParams\n{\n    dash: number;\n    gap: number;\n}\n\n/**\n * @memberof PIXI.smooth\n */\nexport class DashLineShader extends SmoothGraphicsShader\n{\n    constructor(dashParams?: IDashParams)\n    {\n        const settings = { maxStyles: 16, maxTextures: 1, pixelLine: 1 };\n\n        super(settings, undefined, dashFrag,\n            dashParams || {\n                dash: 8.0,\n                gap: 5.0\n            });\n    }\n}\n","import { LINE_SCALE_MODE } from './core/LineStyle';\n\nexport interface ISettings\n{\n    LINE_SCALE_MODE: string;\n    SHADER_MAX_STYLES: number;\n    SHADER_MAX_TEXTURES: number;\n    PIXEL_LINE: number;\n}\n\nexport const settings: ISettings = {\n    LINE_SCALE_MODE: LINE_SCALE_MODE.NORMAL,\n    SHADER_MAX_STYLES: 24,\n    SHADER_MAX_TEXTURES: 4,\n    PIXEL_LINE: 0,\n};\n","// for type only\nimport { SHAPES } from '@pixi/core';\nimport { BuildData } from '../core/BuildData';\nimport { JOINT_TYPE } from '../core/const';\nimport { SmoothGraphicsData } from '../core/SmoothGraphicsData';\n\nimport type { Circle, Ellipse, RoundedRectangle } from '@pixi/core';\nimport type { IShapeBuilder } from '../core/IShapeBuilder';\n\n/**\n * @memberof PIXI.smooth\n */\nexport class CircleBuilder implements IShapeBuilder\n{\n    path(graphicsData: SmoothGraphicsData, _target: BuildData)\n    {\n        // need to convert points to a nice regular data\n        const points = graphicsData.points;\n\n        let x;\n        let y;\n        let dx;\n        let dy;\n        let rx;\n        let ry;\n\n        if (graphicsData.type === SHAPES.CIRC)\n        {\n            const circle = graphicsData.shape as Circle;\n\n            x = circle.x;\n            y = circle.y;\n            rx = ry = circle.radius;\n            dx = dy = 0;\n        }\n        else if (graphicsData.type === SHAPES.ELIP)\n        {\n            const ellipse = graphicsData.shape as Ellipse;\n\n            x = ellipse.x;\n            y = ellipse.y;\n            rx = ellipse.width;\n            ry = ellipse.height;\n            dx = dy = 0;\n        }\n        else\n        {\n            const roundedRect = graphicsData.shape as RoundedRectangle;\n            const halfWidth = roundedRect.width / 2;\n            const halfHeight = roundedRect.height / 2;\n\n            x = roundedRect.x + halfWidth;\n            y = roundedRect.y + halfHeight;\n            rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n            dx = halfWidth - rx;\n            dy = halfHeight - ry;\n        }\n\n        if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0))\n        {\n            points.length = 0;\n\n            return;\n        }\n\n        // Choose a number of segments such that the maximum absolute deviation from the circle is approximately 0.029\n        const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n        const m = (n * 8) + (dx ? 4 : 0) + (dy ? 4 : 0);\n\n        points.length = m;\n\n        if (m === 0)\n        {\n            return;\n        }\n\n        if (n === 0)\n        {\n            points.length = 8;\n            points[0] = points[6] = x + dx;\n            points[1] = points[3] = y + dy;\n            points[2] = points[4] = x - dx;\n            points[5] = points[7] = y - dy;\n\n            return;\n        }\n\n        let j1 = 0;\n        let j2 = (n * 4) + (dx ? 2 : 0) + 2;\n        let j3 = j2;\n        let j4 = m;\n\n        {\n            const x0 = dx + rx;\n            const y0 = dy;\n            const x1 = x + x0;\n            const x2 = x - x0;\n            const y1 = y + y0;\n\n            points[j1++] = x1;\n            points[j1++] = y1;\n            points[--j2] = y1;\n            points[--j2] = x2;\n\n            if (dy)\n            {\n                const y2 = y - y0;\n\n                points[j3++] = x2;\n                points[j3++] = y2;\n                points[--j4] = y2;\n                points[--j4] = x1;\n            }\n        }\n\n        for (let i = 1; i < n; i++)\n        {\n            const a = Math.PI / 2 * (i / n);\n            const x0 = dx + (Math.cos(a) * rx);\n            const y0 = dy + (Math.sin(a) * ry);\n            const x1 = x + x0;\n            const x2 = x - x0;\n            const y1 = y + y0;\n            const y2 = y - y0;\n\n            points[j1++] = x1;\n            points[j1++] = y1;\n            points[--j2] = y1;\n            points[--j2] = x2;\n            points[j3++] = x2;\n            points[j3++] = y2;\n            points[--j4] = y2;\n            points[--j4] = x1;\n        }\n\n        {\n            const x0 = dx;\n            const y0 = dy + ry;\n            const x1 = x + x0;\n            const x2 = x - x0;\n            const y1 = y + y0;\n            const y2 = y - y0;\n\n            points[j1++] = x1;\n            points[j1++] = y1;\n            points[--j4] = y2;\n            points[--j4] = x1;\n\n            if (dx)\n            {\n                points[j1++] = x2;\n                points[j1++] = y1;\n                points[--j4] = y2;\n                points[--j4] = x2;\n            }\n        }\n    }\n\n    fill(graphicsData: SmoothGraphicsData, target: BuildData)\n    {\n        const { verts, joints } = target;\n        const { points, triangles } = graphicsData;\n\n        if (points.length === 0)\n        {\n            return;\n        }\n\n        let x;\n        let y;\n\n        if (graphicsData.type !== SHAPES.RREC)\n        {\n            const circle = graphicsData.shape as Circle;\n\n            x = circle.x;\n            y = circle.y;\n        }\n        else\n        {\n            const roundedRect = graphicsData.shape as RoundedRectangle;\n\n            x = roundedRect.x + (roundedRect.width / 2);\n            y = roundedRect.y + (roundedRect.height / 2);\n        }\n\n        const matrix = graphicsData.matrix;\n        const cx = matrix ? (matrix.a * x) + (matrix.c * y) + matrix.tx : x;\n        const cy = matrix ? (matrix.b * x) + (matrix.d * y) + matrix.ty : y;\n\n        let vertPos = 1;\n        const center = 0;\n\n        if (!graphicsData.fillAA)\n        {\n            verts.push(cx, cy);\n            joints.push(JOINT_TYPE.FILL);\n            verts.push(points[0], points[1]);\n            joints.push(JOINT_TYPE.FILL);\n\n            for (let i = 2; i < points.length; i += 2)\n            {\n                verts.push(points[i], points[i + 1]);\n                joints.push(JOINT_TYPE.FILL);\n\n                triangles.push(vertPos++, center, vertPos);\n            }\n\n            triangles.push(center + 1, center, vertPos);\n\n            return;\n        }\n\n        const len = points.length;\n\n        let x1 = points[len - 2];\n        let y1 = points[len - 1];\n\n        let nx1 = y1 - points[len - 3];\n        let ny1 = points[len - 4] - x1;\n        const n1 = Math.sqrt((nx1 * nx1) + (ny1 * ny1));\n\n        nx1 /= n1;\n        ny1 /= n1;\n\n        let bx1;\n        let by1;\n\n        for (let i = 0; i < len; i += 2)\n        {\n            const x2 = points[i];\n            const y2 = points[i + 1];\n\n            let nx2 = y2 - y1;\n            let ny2 = x1 - x2;\n            const n2 = Math.sqrt((nx2 * nx2) + (ny2 * ny2));\n\n            nx2 /= n2;\n            ny2 /= n2;\n\n            let bx2 = nx1 + nx2;\n            let by2 = ny1 + ny2;\n            const b2 = (nx2 * bx2) + (ny2 * by2);\n\n            bx2 /= b2;\n            by2 /= b2;\n\n            if (i > 0)\n            {\n                verts.push(bx2);\n                verts.push(by2);\n            }\n            else\n            {\n                bx1 = bx2;\n                by1 = by2;\n            }\n\n            verts.push(cx);\n            verts.push(cy);\n            verts.push(x1);\n            verts.push(y1);\n            verts.push(x2);\n            verts.push(y2);\n\n            verts.push(0);\n            verts.push(0);\n            verts.push(bx2);\n            verts.push(by2);\n\n            joints.push(JOINT_TYPE.FILL_EXPAND + 2);\n            joints.push(JOINT_TYPE.NONE);\n            joints.push(JOINT_TYPE.NONE);\n            joints.push(JOINT_TYPE.NONE);\n            joints.push(JOINT_TYPE.NONE);\n            joints.push(JOINT_TYPE.NONE);\n\n            x1 = x2;\n            y1 = y2;\n            nx1 = nx2;\n            ny1 = ny2;\n        }\n\n        verts.push(bx1);\n        verts.push(by1);\n    }\n\n    line(graphicsData: SmoothGraphicsData, target: BuildData): void\n    {\n        const { verts, joints } = target;\n        const { points } = graphicsData;\n        const joint = points.length === 8 // we dont need joints for arcs\n            ? graphicsData.goodJointType() : JOINT_TYPE.JOINT_MITER + 3;\n        const len = points.length;\n\n        if (len === 0)\n        {\n            return;\n        }\n\n        verts.push(points[len - 2], points[len - 1]);\n        joints.push(JOINT_TYPE.NONE);\n        for (let i = 0; i < len; i += 2)\n        {\n            verts.push(points[i], points[i + 1]);\n            joints.push(joint);\n        }\n        verts.push(points[0], points[1]);\n        joints.push(JOINT_TYPE.NONE);\n        verts.push(points[2], points[3]);\n        joints.push(JOINT_TYPE.NONE);\n    }\n}\n","import { Point, Polygon, utils } from '@pixi/core';\nimport { BuildData } from '../core/BuildData';\nimport { JOINT_TYPE } from '../core/const';\nimport { SmoothGraphicsData } from '../core/SmoothGraphicsData';\n\nimport type { IShapeBuilder } from '../core/IShapeBuilder';\n\nconst tempArr: Array<number> = [];\n\nfunction fixOrientation(points: number[], hole = false)\n{\n    const m = points.length;\n\n    if (m < 6)\n    {\n        return;\n    }\n\n    let area = 0;\n\n    for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2)\n    {\n        const x2 = points[i];\n        const y2 = points[i + 1];\n\n        area += (x2 - x1) * (y2 + y1);\n\n        x1 = x2;\n        y1 = y2;\n    }\n\n    if ((!hole && area > 0) || (hole && area <= 0))\n    {\n        const n = m / 2;\n\n        for (let i = n + (n % 2); i < m; i += 2)\n        {\n            const i1 = m - i - 2;\n            const i2 = m - i - 1;\n            const i3 = i;\n            const i4 = i + 1;\n\n            [points[i1], points[i3]] = [points[i3], points[i1]];\n            [points[i2], points[i4]] = [points[i4], points[i2]];\n        }\n    }\n}\n\n/**\n * @memberof PIXI.smooth\n */\nexport class PolyBuilder implements IShapeBuilder\n{\n    path(graphicsData: SmoothGraphicsData, buildData: BuildData)\n    {\n        const shape = graphicsData.shape as Polygon;\n        const points = graphicsData.points = shape.points.slice();\n        const eps = buildData.closePointEps;\n        const eps2 = eps * eps;\n\n        if (points.length === 0)\n        {\n            return;\n        }\n\n        const firstPoint = new Point(points[0], points[1]);\n        const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n        const closedShape = graphicsData.closeStroke = shape.closeStroke;\n\n        let len = points.length;\n        let newLen = 2;\n\n        // 1. remove equal points\n        for (let i = 2; i < len; i += 2)\n        {\n            const x1 = points[i - 2];\n            const y1 = points[i - 1];\n            const x2 = points[i];\n            const y2 = points[i + 1];\n            let flag = true;\n\n            if (Math.abs(x1 - x2) < eps\n                && Math.abs(y1 - y2) < eps)\n            {\n                flag = false;\n            }\n\n            if (flag)\n            {\n                points[newLen] = points[i];\n                points[newLen + 1] = points[i + 1];\n                newLen += 2;\n            }\n        }\n        points.length = len = newLen;\n\n        newLen = 2;\n        // 2. remove middle points\n        for (let i = 2; i + 2 < len; i += 2)\n        {\n            let x1 = points[i - 2];\n            let y1 = points[i - 1];\n            const x2 = points[i];\n            const y2 = points[i + 1];\n            let x3 = points[i + 2];\n            let y3 = points[i + 3];\n\n            x1 -= x2;\n            y1 -= y2;\n            x3 -= x2;\n            y3 -= y2;\n            let flag = true;\n\n            if (Math.abs((x3 * y1) - (y3 * x1)) < eps2)\n            {\n                if ((x1 * x3) + (y1 * y3) < -eps2)\n                {\n                    flag = false;\n                }\n            }\n\n            if (flag)\n            {\n                points[newLen] = points[i];\n                points[newLen + 1] = points[i + 1];\n                newLen += 2;\n            }\n        }\n        points[newLen] = points[len - 2];\n        points[newLen + 1] = points[len - 1];\n        newLen += 2;\n\n        points.length = len = newLen;\n\n        if (len <= 2)\n        {\n            // suddenly, nothing\n            return;\n        }\n\n        if (closedShape)\n        {\n            // first point should be last point in closed line!\n            const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps\n                && Math.abs(firstPoint.y - lastPoint.y) < eps;\n\n            if (closedPath)\n            {\n                points.pop();\n                points.pop();\n            }\n        }\n    }\n\n    line(graphicsData: SmoothGraphicsData, buildData: BuildData)\n    {\n        const { closeStroke, points } = graphicsData;\n        // const eps = buildData.closePointEps;\n        // const eps2 = eps * eps;\n        const len = points.length;\n        // const style = graphicsData.lineStyle;\n\n        if (len <= 2)\n        {\n            return;\n        }\n        const { verts, joints } = buildData;\n\n        // TODO: alignment\n\n        const joint = graphicsData.jointType();\n        const cap = graphicsData.capType();\n        let prevCap = 0;\n\n        let prevX: number; let\n            prevY: number;\n\n        if (closeStroke)\n        {\n            prevX = points[len - 2];\n            prevY = points[len - 1];\n            joints.push(JOINT_TYPE.NONE);\n        }\n        else\n        {\n            prevX = points[2];\n            prevY = points[3];\n            if (cap === JOINT_TYPE.CAP_ROUND)\n            {\n                verts.push(points[0], points[1]);\n                joints.push(JOINT_TYPE.NONE);\n                joints.push(JOINT_TYPE.CAP_ROUND);\n                prevCap = 0;\n            }\n            else\n            {\n                prevCap = cap;\n                joints.push(JOINT_TYPE.NONE);\n            }\n        }\n        verts.push(prevX, prevY);\n\n        /* Line segments of interest where (x1,y1) forms the corner. */\n        for (let i = 0; i < len; i += 2)\n        {\n            const x1 = points[i]; const\n                y1 = points[i + 1];\n\n            // let x2: number; let\n            //     y2: number;\n\n            // if (i + 2 < len)\n            // {\n            //     x2 = points[i + 2];\n            //     y2 = points[i + 3];\n            // }\n            // else\n            // {\n            //     x2 = points[0];\n            //     y2 = points[1];\n            // }\n\n            // const dx = x2 - x1;\n            // const dy = y2 - y1;\n            // let nextX: number; let\n            //     nextY: number;\n\n            let endJoint = joint;\n\n            if (i + 2 >= len)\n            {\n                // nextX = points[2];\n                // nextY = points[3];\n                if (!closeStroke)\n                {\n                    endJoint = JOINT_TYPE.NONE;\n                }\n            }\n            else if (i + 4 >= len)\n            {\n                // nextX = points[0];\n                // nextY = points[1];\n                if (!closeStroke)\n                {\n                    if (cap === JOINT_TYPE.CAP_ROUND)\n                    {\n                        endJoint = JOINT_TYPE.JOINT_CAP_ROUND;\n                    }\n                    if (cap === JOINT_TYPE.CAP_BUTT)\n                    {\n                        endJoint = JOINT_TYPE.JOINT_CAP_BUTT;\n                    }\n                    if (cap === JOINT_TYPE.CAP_SQUARE)\n                    {\n                        endJoint = JOINT_TYPE.JOINT_CAP_SQUARE;\n                    }\n                }\n            }\n            // else\n            // {\n            //     nextX = points[i + 4];\n            //     nextY = points[i + 5];\n            // }\n\n            // const dx3 = x1 - prevX;\n            // const dy3 = y1 - prevY;\n\n            endJoint += prevCap;\n            prevCap = 0;\n\n            verts.push(x1, y1);\n            joints.push(endJoint);\n\n            prevX = x1;\n            prevY = y1;\n        }\n\n        if (closeStroke)\n        {\n            verts.push(points[0], points[1]);\n            joints.push(JOINT_TYPE.NONE);\n            verts.push(points[2], points[3]);\n            joints.push(JOINT_TYPE.NONE);\n        }\n        else\n        {\n            verts.push(points[len - 4], points[len - 3]);\n            joints.push(JOINT_TYPE.NONE);\n        }\n    }\n\n    fill(graphicsData: SmoothGraphicsData, buildData: BuildData)\n    {\n        let points = graphicsData.points;\n        // TODO: simplify holes too!\n        const holes = graphicsData.holes;\n        const eps = buildData.closePointEps;\n\n        const { verts, joints } = buildData;\n\n        if (points.length < 6)\n        {\n            return;\n        }\n        const holeArray = [];\n        let len = points.length;\n\n        fixOrientation(points, false);\n\n        // Process holes..\n        for (let i = 0; i < holes.length; i++)\n        {\n            const hole = holes[i];\n\n            fixOrientation(hole.points, true);\n\n            holeArray.push(points.length / 2);\n            points = points.concat(hole.points);\n        }\n\n        // TODO: reduce size later?\n        const pn = tempArr;\n\n        if (pn.length < points.length)\n        {\n            pn.length = points.length;\n        }\n        let start = 0;\n\n        for (let i = 0; i <= holeArray.length; i++)\n        {\n            let finish = len / 2;\n\n            if (i > 0)\n            {\n                if (i < holeArray.length)\n                {\n                    finish = holeArray[i];\n                }\n                else\n                {\n                    finish = (points.length >> 1);\n                }\n            }\n            pn[start * 2] = finish - 1;\n            pn[((finish - 1) * 2) + 1] = start;\n            for (let j = start; j + 1 < finish; j++)\n            {\n                pn[(j * 2) + 1] = j + 1;\n                pn[(j * 2) + 2] = j;\n            }\n            start = finish;\n        }\n\n        // sort color\n        graphicsData.triangles = utils.earcut(points, holeArray, 2);\n\n        if (!graphicsData.triangles)\n        {\n            return;\n        }\n\n        if (!graphicsData.fillAA)\n        {\n            for (let i = 0; i < points.length; i += 2)\n            {\n                verts.push(points[i], points[i + 1]);\n                joints.push(JOINT_TYPE.FILL);\n            }\n\n            return;\n        }\n\n        const { triangles } = graphicsData;\n\n        len = points.length;\n\n        for (let i = 0; i < triangles.length; i += 3)\n        {\n            // TODO: holes prev/next!!!\n            let flag = 0;\n\n            for (let j = 0; j < 3; j++)\n            {\n                const ind1 = triangles[i + j];\n                const ind2 = triangles[i + ((j + 1) % 3)];\n\n                if (pn[ind1 * 2] === ind2 || pn[(ind1 * 2) + 1] === ind2)\n                {\n                    flag |= (1 << j);\n                }\n            }\n            joints.push(JOINT_TYPE.FILL_EXPAND + flag);\n            joints.push(JOINT_TYPE.NONE);\n            joints.push(JOINT_TYPE.NONE);\n            joints.push(JOINT_TYPE.NONE);\n            joints.push(JOINT_TYPE.NONE);\n            joints.push(JOINT_TYPE.NONE);\n        }\n\n        // bisect, re-using pn\n        for (let ind = 0; ind < len / 2; ind++)\n        {\n            const prev = pn[ind * 2];\n            const next = pn[(ind * 2) + 1];\n            let nx1 = (points[(next * 2) + 1] - points[(ind * 2) + 1]); let\n                ny1 = -(points[next * 2] - points[ind * 2]);\n            let nx2 = (points[(ind * 2) + 1] - points[(prev * 2) + 1]); let\n                ny2 = -(points[ind * 2] - points[prev * 2]);\n            const D1 = Math.sqrt((nx1 * nx1) + (ny1 * ny1));\n\n            nx1 /= D1;\n            ny1 /= D1;\n            const D2 = Math.sqrt((nx2 * nx2) + (ny2 * ny2));\n\n            nx2 /= D2;\n            ny2 /= D2;\n\n            let bx = (nx1 + nx2);\n            let by = (ny1 + ny2);\n            const D = (bx * nx1) + (by * ny1);\n\n            if (Math.abs(D) < eps)\n            {\n                bx = nx1;\n                by = ny1;\n            }\n            else\n            {\n                bx /= D;\n                by /= D;\n            }\n            pn[ind * 2] = bx;\n            pn[(ind * 2) + 1] = by;\n        }\n\n        for (let i = 0; i < triangles.length; i += 3)\n        {\n            const prev = triangles[i];\n            const ind = triangles[i + 1];\n            const next = triangles[i + 2];\n            const nx1 = (points[(next * 2) + 1] - points[(ind * 2) + 1]); const\n                ny1 = -(points[next * 2] - points[ind * 2]);\n            const nx2 = (points[(ind * 2) + 1] - points[(prev * 2) + 1]); const\n                ny2 = -(points[ind * 2] - points[prev * 2]);\n\n            let j1 = 1;\n\n            if ((nx1 * ny2) - (nx2 * ny1) > 0.0)\n            {\n                j1 = 2;\n            }\n\n            for (let j = 0; j < 3; j++)\n            {\n                const ind = triangles[i + ((j * j1) % 3)];\n\n                verts.push(points[ind * 2], points[(ind * 2) + 1]);\n            }\n            for (let j = 0; j < 3; j++)\n            {\n                const ind = triangles[i + ((j * j1) % 3)];\n\n                verts.push(pn[ind * 2], pn[(ind * 2) + 1]);\n            }\n        }\n    }\n}\n","import { BuildData } from '../core/BuildData';\nimport { JOINT_TYPE } from '../core/const';\nimport { SmoothGraphicsData } from '../core/SmoothGraphicsData';\nimport { PolyBuilder } from './PolyBuilder';\n\nimport type { Rectangle } from '@pixi/core';\nimport type { IShapeBuilder } from '../core/IShapeBuilder';\n\n/**\n * @memberof PIXI.smooth\n */\nexport class RectangleBuilder implements IShapeBuilder\n{\n    _polyBuilder = new PolyBuilder();\n\n    path(graphicsData: SmoothGraphicsData, _target: BuildData)\n    {\n        // --- //\n        // need to convert points to a nice regular data\n        //\n        const rectData = graphicsData.shape as Rectangle;\n        const x = rectData.x;\n        const y = rectData.y;\n        const width = rectData.width;\n        const height = rectData.height;\n        const points = graphicsData.points;\n\n        points.length = 0;\n\n        points.push(x, y,\n            x + width, y,\n            x + width, y + height,\n            x, y + height);\n    }\n\n    line(graphicsData: SmoothGraphicsData, target: BuildData): void\n    {\n        const { verts, joints } = target;\n        const { points } = graphicsData;\n\n        const joint = graphicsData.goodJointType();\n        const len = points.length;\n\n        verts.push(points[len - 2], points[len - 1]);\n        joints.push(JOINT_TYPE.NONE);\n        for (let i = 0; i < len; i += 2)\n        {\n            verts.push(points[i], points[i + 1]);\n            joints.push(joint);\n        }\n        verts.push(points[0], points[1]);\n        joints.push(JOINT_TYPE.NONE);\n        verts.push(points[2], points[3]);\n        joints.push(JOINT_TYPE.NONE);\n    }\n\n    fill(graphicsData: SmoothGraphicsData, target: BuildData): void\n    {\n        const { verts, joints } = target;\n        const { points, triangles } = graphicsData;\n\n        triangles.length = 0;\n\n        if (!graphicsData.fillAA)\n        {\n            verts.push(points[0], points[1],\n                points[2], points[3],\n                points[4], points[5],\n                points[6], points[7]);\n\n            joints.push(JOINT_TYPE.FILL, JOINT_TYPE.FILL, JOINT_TYPE.FILL, JOINT_TYPE.FILL);\n            triangles.push(0, 1, 2, 0, 2, 3);\n\n            return;\n        }\n\n        this._polyBuilder.fill(graphicsData, target);\n    }\n}\n","import { CircleBuilder } from './CircleBuilder';\n\nimport type { BuildData } from '../core/BuildData';\nimport type { IShapeBuilder } from '../core/IShapeBuilder';\nimport type { SmoothGraphicsData } from '../core/SmoothGraphicsData';\n\n/**\n * @memberof PIXI.smooth\n */\nexport class RoundedRectangleBuilder implements IShapeBuilder\n{\n    _circleBuilder = new CircleBuilder();\n\n    path(graphicsData: SmoothGraphicsData, target: BuildData)\n    {\n        this._circleBuilder.path(graphicsData, target);\n    }\n\n    line(graphicsData: SmoothGraphicsData, target: BuildData): void\n    {\n        this._circleBuilder.line(graphicsData, target);\n    }\n\n    fill(graphicsData: SmoothGraphicsData, target: BuildData): void\n    {\n        this._circleBuilder.fill(graphicsData, target);\n    }\n}\n","import { SHAPES } from '@pixi/core';\nimport { IShapeBuilder } from '../core/IShapeBuilder';\nimport { CircleBuilder } from './CircleBuilder';\nimport { PolyBuilder } from './PolyBuilder';\nimport { RectangleBuilder } from './RectangleBuilder';\nimport { RoundedRectangleBuilder } from './RoundedRectangleBuilder';\n\nexport const FILL_COMMANDS: Record<SHAPES, IShapeBuilder> = {\n    [SHAPES.POLY]: new PolyBuilder(),\n    [SHAPES.CIRC]: new CircleBuilder(),\n    [SHAPES.ELIP]: new CircleBuilder(),\n    [SHAPES.RECT]: new RectangleBuilder(),\n    [SHAPES.RREC]: new RoundedRectangleBuilder()\n};\n\nexport { CircleBuilder, PolyBuilder, RectangleBuilder, RoundedRectangleBuilder };\n","import {\n    Buffer,\n    Color,\n    Geometry,\n    Matrix,\n    Point,\n    SHAPES,\n    Texture,\n    TYPES,\n    WRAP_MODES,\n} from '@pixi/core';\nimport { Bounds } from '@pixi/display';\nimport { BatchDrawCall, IGraphicsBatchSettings, matrixEquals } from './core/BatchDrawCall';\nimport { BatchPart } from './core/BatchPart';\nimport { BuildData } from './core/BuildData';\nimport { FillStyle } from './core/FillStyle';\nimport { LineStyle } from './core/LineStyle';\nimport { SegmentPacker } from './core/SegmentPacker';\nimport { SmoothGraphicsData } from './core/SmoothGraphicsData';\nimport { FILL_COMMANDS } from './shapes';\n\nimport type { Circle, Ellipse, IPointData, Polygon, Rectangle, RoundedRectangle } from '@pixi/core';\n\n/*\n * Complex shape type\n * @todo Move to Math shapes\n */\nexport type IShape = Circle | Ellipse | Polygon | Rectangle | RoundedRectangle;\n\nexport const BATCH_POOL: Array<BatchPart> = [];\nexport const DRAW_CALL_POOL: Array<BatchDrawCall> = [];\n\nconst tmpPoint = new Point();\nconst tmpBounds = new Bounds();\n\n/**\n * @memberof PIXI.smooth\n */\nexport class SmoothGraphicsGeometry extends Geometry\n{\n    public static BATCHABLE_SIZE = 100;\n\n    public boundsPadding: number;\n\n    indicesUint16: Uint16Array | Uint32Array = null;\n    batchable: boolean;\n\n    buildData: BuildData;\n\n    get points()\n    {\n        return this.buildData.verts;\n    }\n\n    get closePointEps()\n    {\n        return this.buildData.closePointEps;\n    }\n\n    graphicsData: Array<SmoothGraphicsData>;\n    drawCalls: Array<BatchDrawCall>;\n    batchDirty: number;\n    batches: Array<BatchPart>;\n    packer: SegmentPacker;\n    packSize: number;\n    pack32index: boolean;\n    strideFloats: number;\n\n    protected dirty: number;\n    protected cacheDirty: number;\n    protected clearDirty: number;\n    protected shapeBuildIndex: number;\n    protected shapeBatchIndex: number;\n    protected _bounds: Bounds;\n    protected boundsDirty: number;\n\n    _buffer: Buffer;\n    _indexBuffer: Buffer;\n    _bufferFloats: Float32Array;\n    _bufferUint: Uint32Array;\n\n    initAttributes(_static: boolean)\n    {\n        this._buffer = new Buffer(null, _static, false);\n        this._bufferFloats = new Float32Array();\n        this._bufferUint = new Uint32Array();\n\n        this._indexBuffer = new Buffer(null, _static, true);\n        this.addAttribute('aPrev', this._buffer, 2, false, TYPES.FLOAT)\n            .addAttribute('aPoint1', this._buffer, 2, false, TYPES.FLOAT)\n            .addAttribute('aPoint2', this._buffer, 2, false, TYPES.FLOAT)\n            .addAttribute('aNext', this._buffer, 2, false, TYPES.FLOAT)\n            .addAttribute('aTravel', this._buffer, 1, false, TYPES.FLOAT)\n            // number of vertex\n            .addAttribute('aVertexJoint', this._buffer, 1, false, TYPES.FLOAT)\n            // line width, alignment\n            .addAttribute('aStyleId', this._buffer, 1, false, TYPES.FLOAT)\n            // the usual\n            .addAttribute('aColor', this._buffer, 4, true, TYPES.UNSIGNED_BYTE)\n            .addIndex(this._indexBuffer);\n\n        this.strideFloats = 12;\n    }\n\n    constructor()\n    {\n        super();\n\n        this.initAttributes(false);\n\n        this.buildData = new BuildData();\n\n        this.graphicsData = [];\n\n        this.dirty = 0;\n\n        this.batchDirty = -1;\n\n        this.cacheDirty = -1;\n\n        this.clearDirty = 0;\n\n        this.drawCalls = [];\n\n        this.batches = [];\n\n        this.shapeBuildIndex = 0;\n\n        this.shapeBatchIndex = 0;\n\n        this._bounds = new Bounds();\n\n        this.boundsDirty = -1;\n\n        this.boundsPadding = 0;\n\n        this.batchable = false;\n\n        this.indicesUint16 = null;\n\n        this.packer = null;\n        this.packSize = 0;\n        this.pack32index = null;\n    }\n\n    public checkInstancing(instanced: boolean, allow32Indices: boolean)\n    {\n        if (this.packer)\n        {\n            return;\n        }\n        this.packer = new SegmentPacker();\n        this.pack32index = allow32Indices;\n    }\n\n    /**\n     * Get the current bounds of the graphic geometry.\n     *\n     * @member {PIXI.Bounds}\n     * @readonly\n     */\n    public get bounds(): Bounds\n    {\n        if (this.boundsDirty !== this.dirty)\n        {\n            this.boundsDirty = this.dirty;\n            this.calculateBounds();\n        }\n\n        return this._bounds;\n    }\n\n    /**\n     * Call if you changed graphicsData manually.\n     * Empties all batch buffers.\n     */\n    protected invalidate(): void\n    {\n        this.boundsDirty = -1;\n        this.dirty++;\n        this.batchDirty++;\n        this.shapeBuildIndex = 0;\n        this.shapeBatchIndex = 0;\n        this.packSize = 0;\n\n        this.buildData.clear();\n\n        for (let i = 0; i < this.drawCalls.length; i++)\n        {\n            this.drawCalls[i].clear();\n            DRAW_CALL_POOL.push(this.drawCalls[i]);\n        }\n\n        this.drawCalls.length = 0;\n\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            const batchPart = this.batches[i];\n\n            batchPart.reset();\n            BATCH_POOL.push(batchPart);\n        }\n\n        this.batches.length = 0;\n    }\n\n    public clear(): SmoothGraphicsGeometry\n    {\n        if (this.graphicsData.length > 0)\n        {\n            this.invalidate();\n            this.clearDirty++;\n            this.graphicsData.length = 0;\n        }\n\n        return this;\n    }\n\n    public drawShape(\n        shape: IShape,\n        fillStyle: FillStyle = null,\n        lineStyle: LineStyle = null,\n        matrix: Matrix = null): SmoothGraphicsGeometry\n    {\n        const data = new SmoothGraphicsData(shape, fillStyle, lineStyle, matrix);\n\n        this.graphicsData.push(data);\n        this.dirty++;\n\n        return this;\n    }\n\n    public drawHole(shape: IShape, matrix: Matrix = null): SmoothGraphicsGeometry\n    {\n        if (!this.graphicsData.length)\n        {\n            return null;\n        }\n\n        const data = new SmoothGraphicsData(shape, null, null, matrix);\n\n        const lastShape = this.graphicsData[this.graphicsData.length - 1];\n\n        data.lineStyle = lastShape.lineStyle;\n\n        lastShape.holes.push(data);\n\n        this.dirty++;\n\n        return this;\n    }\n\n    public destroy(): void\n    {\n        super.destroy();\n\n        // destroy each of the SmoothGraphicsData objects\n        for (let i = 0; i < this.graphicsData.length; ++i)\n        {\n            this.graphicsData[i].destroy();\n        }\n\n        this.buildData.destroy();\n        this.buildData = null;\n        this.indexBuffer.destroy();\n        this.indexBuffer = null;\n        this.graphicsData.length = 0;\n        this.graphicsData = null;\n        this.drawCalls.length = 0;\n        this.drawCalls = null;\n        this.batches.length = 0;\n        this.batches = null;\n        this._bounds = null;\n    }\n\n    /**\n     * Check to see if a point is contained within this geometry.\n     *\n     * @param {PIXI.IPointData} point - Point to check if it's contained.\n     * @return {Boolean} `true` if the point is contained within geometry.\n     */\n    public containsPoint(point: IPointData): boolean\n    {\n        const graphicsData = this.graphicsData;\n\n        for (let i = 0; i < graphicsData.length; ++i)\n        {\n            const data = graphicsData[i];\n\n            if (!data.fillStyle.visible)\n            {\n                continue;\n            }\n\n            // only deal with fills..\n            if (data.shape)\n            {\n                if (data.matrix)\n                {\n                    data.matrix.applyInverse(point, tmpPoint);\n                }\n                else\n                {\n                    tmpPoint.copyFrom(point);\n                }\n\n                if (data.shape.contains(tmpPoint.x, tmpPoint.y))\n                {\n                    let hitHole = false;\n\n                    if (data.holes)\n                    {\n                        for (let i = 0; i < data.holes.length; i++)\n                        {\n                            const hole = data.holes[i];\n\n                            if (hole.shape.contains(tmpPoint.x, tmpPoint.y))\n                            {\n                                hitHole = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (!hitHole)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    updatePoints(): void\n    {\n        // do nothing\n    }\n\n    updateBufferSize(): void\n    {\n        this._buffer.update(new Float32Array());\n    }\n\n    updateBuild(): void\n    {\n        const { graphicsData, buildData } = this;\n        const len = graphicsData.length;\n\n        for (let i = this.shapeBuildIndex; i < len; i++)\n        {\n            const data = graphicsData[i];\n\n            data.strokeStart = 0;\n            data.strokeLen = 0;\n            data.fillStart = 0;\n            data.fillLen = 0;\n            const { fillStyle, lineStyle, holes } = data;\n\n            if (!fillStyle.visible && !lineStyle.visible)\n            {\n                continue;\n            }\n\n            const command = FILL_COMMANDS[data.type];\n\n            data.clearPath();\n\n            command.path(data, buildData);\n            if (data.matrix)\n            {\n                this.transformPoints(data.points, data.matrix);\n            }\n\n            data.clearBuild();\n            if (data.points.length <= 2)\n            {\n                continue;\n            }\n            if (fillStyle.visible || lineStyle.visible)\n            {\n                this.processHoles(holes);\n            }\n            if (fillStyle.visible)\n            {\n                data.fillAA = (data.fillStyle as any).smooth\n                    && data.fillStyle.texture === Texture.WHITE\n                    && holes.length === 0\n                    && !(data.closeStroke\n                    && data.lineStyle.visible\n                    && !data.lineStyle.shader\n                    && data.lineStyle.alpha >= 0.99\n                    && data.lineStyle.width * Math.min(data.lineStyle.alignment, 1 - data.lineStyle.alignment) >= 0.495);\n\n                data.fillStart = buildData.joints.length;\n\n                if (holes.length)\n                {\n                    FILL_COMMANDS[SHAPES.POLY].fill(data, buildData);\n                }\n                else\n                {\n                    command.fill(data, buildData);\n                }\n\n                data.fillLen = buildData.joints.length - data.fillStart;\n            }\n            if (lineStyle.visible)\n            {\n                data.strokeStart = buildData.joints.length;\n                command.line(data, buildData);\n                for (let i = 0; i < holes.length; i++)\n                {\n                    const hole = holes[i];\n\n                    FILL_COMMANDS[hole.type].line(hole, buildData);\n                }\n                data.strokeLen = buildData.joints.length - data.strokeStart;\n            }\n        }\n        this.shapeBuildIndex = len;\n    }\n\n    updateBatches(shaderSettings?: IGraphicsBatchSettings): void\n    {\n        if (!this.graphicsData.length)\n        {\n            this.batchable = true;\n\n            return;\n        }\n        this.updateBuild();\n\n        if (!this.validateBatching())\n        {\n            return;\n        }\n\n        const { buildData, graphicsData } = this;\n        const len = graphicsData.length;\n\n        this.cacheDirty = this.dirty;\n\n        let batchPart: BatchPart = null;\n\n        let currentStyle = null;\n\n        if (this.batches.length > 0)\n        {\n            batchPart = this.batches[this.batches.length - 1];\n            currentStyle = batchPart.style;\n        }\n\n        for (let i = this.shapeBatchIndex; i < len; i++)\n        {\n            const data = graphicsData[i];\n            const fillStyle = data.fillStyle;\n            const lineStyle = data.lineStyle;\n\n            if (data.matrix)\n            {\n                this.transformPoints(data.points, data.matrix);\n            }\n            if (!fillStyle.visible && !lineStyle.visible)\n            {\n                continue;\n            }\n            for (let j = 0; j < 2; j++)\n            {\n                const style = (j === 0) ? fillStyle : lineStyle;\n\n                if (!style.visible) continue;\n\n                const nextTexture = style.texture.baseTexture;\n                const attribOld = buildData.vertexSize;\n                const indexOld = buildData.indexSize;\n\n                nextTexture.wrapMode = WRAP_MODES.REPEAT;\n                if (j === 0)\n                {\n                    this.packer.updateBufferSize(data.fillStart, data.fillLen, data.triangles.length, buildData);\n                }\n                else\n                {\n                    this.packer.updateBufferSize(data.strokeStart, data.strokeLen, data.triangles.length, buildData);\n                }\n\n                const attribSize = buildData.vertexSize;\n\n                if (attribSize === attribOld) continue;\n                // close batch if style is different\n                if (batchPart && !this._compareStyles(currentStyle, style))\n                {\n                    batchPart.end(indexOld, attribOld);\n                    batchPart = null;\n                }\n                // spawn new batch if its first batch or previous was closed\n                if (!batchPart)\n                {\n                    batchPart = BATCH_POOL.pop() || new BatchPart();\n                    batchPart.begin(style, indexOld, attribOld);\n                    this.batches.push(batchPart);\n                    currentStyle = style;\n                }\n\n                if (j === 0)\n                {\n                    batchPart.jointEnd = data.fillStart + data.fillLen;\n                }\n                else\n                {\n                    batchPart.jointEnd = data.strokeStart + data.strokeLen;\n                }\n            }\n        }\n        this.shapeBatchIndex = len;\n\n        if (batchPart)\n        {\n            batchPart.end(buildData.indexSize, buildData.vertexSize);\n        }\n\n        if (this.batches.length === 0)\n        {\n            // there are no visible styles in SmoothGraphicsData\n            // its possible that someone wants Graphics just for the bounds\n            this.batchable = true;\n\n            return;\n        }\n\n        // TODO make this a const..\n        this.batchable = this.isBatchable();\n\n        if (this.batchable)\n        {\n            this.packBatches();\n        }\n        else\n        {\n            this.buildDrawCalls(shaderSettings);\n            this.updatePack();\n        }\n    }\n\n    updatePack()\n    {\n        const { vertexSize, indexSize } = this.buildData;\n\n        if (this.packSize === vertexSize)\n        {\n            return;\n        }\n\n        const { strideFloats, packer, buildData, batches } = this;\n        const buffer = this._buffer;\n        const index = this._indexBuffer;\n        const floatsSize = vertexSize * strideFloats;\n\n        if (buffer.data.length !== floatsSize)\n        {\n            const arrBuf = new ArrayBuffer(floatsSize * 4);\n\n            this._bufferFloats = new Float32Array(arrBuf);\n            this._bufferUint = new Uint32Array(arrBuf);\n            buffer.data = this._bufferFloats;\n        }\n        if (index.data.length !== indexSize)\n        {\n            if (vertexSize > 0xffff && this.pack32index)\n            {\n                index.data = new Uint32Array(indexSize);\n            }\n            else\n            {\n                index.data = new Uint16Array(indexSize);\n            }\n        }\n\n        packer.beginPack(buildData, this._bufferFloats, this._bufferUint, index.data as Uint16Array);\n\n        let j = 0;\n\n        for (let i = 0; i < this.graphicsData.length; i++)\n        {\n            const data = this.graphicsData[i];\n\n            if (data.fillLen)\n            {\n                while (batches[j].jointEnd <= data.fillStart)\n                {\n                    j++;\n                }\n                packer.packInterleavedGeometry(data.fillStart, data.fillLen, data.triangles,\n                    batches[j].styleId, batches[j].rgba);\n            }\n            if (data.strokeLen)\n            {\n                while (batches[j].jointEnd <= data.strokeStart)\n                {\n                    j++;\n                }\n                packer.packInterleavedGeometry(data.strokeStart, data.strokeLen, data.triangles,\n                    batches[j].styleId, batches[j].rgba);\n            }\n        }\n\n        buffer.update();\n        index.update();\n        this.packSize = vertexSize;\n    }\n\n    /**\n     * Affinity check\n     *\n     * @param {PIXI.FillStyle | PIXI.LineStyle} styleA\n     * @param {PIXI.FillStyle | PIXI.LineStyle} styleB\n     */\n    protected _compareStyles(styleA: FillStyle | LineStyle, styleB: FillStyle | LineStyle): boolean\n    {\n        if (!styleA || !styleB)\n        {\n            return false;\n        }\n\n        if (styleA.texture.baseTexture !== styleB.texture.baseTexture)\n        {\n            return false;\n        }\n\n        if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha)\n        {\n            return false;\n        }\n\n        if (styleA.shader !== styleB.shader)\n        {\n            return false;\n        }\n        // TODO: propagate width for FillStyle\n        if ((styleA as LineStyle).width !== (styleB as LineStyle).width)\n        {\n            return false;\n        }\n        if ((styleA as LineStyle).scaleMode !== (styleB as LineStyle).scaleMode)\n        {\n            return false;\n        }\n        if ((styleA as LineStyle).alignment !== (styleB as LineStyle).alignment)\n        {\n            return false;\n        }\n\n        const mat1 = styleA.matrix || Matrix.IDENTITY;\n        const mat2 = styleB.matrix || Matrix.IDENTITY;\n\n        return matrixEquals(mat1, mat2);\n    }\n\n    /**\n     * Test geometry for batching process.\n     *\n     * @protected\n     */\n    protected validateBatching(): boolean\n    {\n        if (this.dirty === this.cacheDirty || !this.graphicsData.length)\n        {\n            return false;\n        }\n\n        for (let i = 0, l = this.graphicsData.length; i < l; i++)\n        {\n            const data = this.graphicsData[i];\n            const fill = data.fillStyle;\n            const line = data.lineStyle;\n\n            if (fill && !fill.texture.baseTexture.valid) return false;\n            if (line && !line.texture.baseTexture.valid) return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Offset the indices so that it works with the batcher.\n     *\n     * @protected\n     */\n    protected packBatches(): void\n    {\n        this.batchDirty++;\n        const batches = this.batches;\n\n        for (let i = 0, l = batches.length; i < l; i++)\n        {\n            const batch = batches[i];\n\n            for (let j = 0; j < batch.size; j++)\n            {\n                const index = batch.start + j;\n\n                this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;\n            }\n        }\n    }\n\n    protected isBatchable(): boolean\n    {\n        return false;\n\n        // prevent heavy mesh batching\n        // if (this.points.length > 0xffff * 2) {\n        //     return false;\n        // }\n        //\n        // const batches = this.batches;\n        //\n        // for (let i = 0; i < batches.length; i++) {\n        //     if ((batches[i].style as LineStyle).native) {\n        //         return false;\n        //     }\n        // }\n        //\n        // return (this.points.length < SmoothGraphicsGeometry.BATCHABLE_SIZE * 2);\n    }\n\n    /**\n     * Converts intermediate batches data to drawCalls.\n     *\n     * @protected\n     */\n    protected buildDrawCalls(shaderSettings?: IGraphicsBatchSettings)\n    {\n        for (let i = 0; i < this.drawCalls.length; i++)\n        {\n            this.drawCalls[i].clear();\n            DRAW_CALL_POOL.push(this.drawCalls[i]);\n        }\n\n        this.drawCalls.length = 0;\n\n        let currentGroup = DRAW_CALL_POOL.pop() || new BatchDrawCall();\n\n        currentGroup.begin(shaderSettings, null);\n\n        let index = 0;\n\n        this.drawCalls.push(currentGroup);\n\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            const batchData = this.batches[i];\n            const style = batchData.style as LineStyle;\n\n            if (batchData.attribSize === 0)\n            {\n                // I don't know how why do we have size=0 sometimes\n                continue;\n            }\n\n            let styleId = -1;\n            const mat = style.getTextureMatrix();\n\n            if (currentGroup.check(style.shader))\n            {\n                styleId = currentGroup.add(style.texture, mat,\n                    style.width, style.alignment || 0, style.packLineScale());\n            }\n            if (styleId < 0)\n            {\n                currentGroup = DRAW_CALL_POOL.pop() || new BatchDrawCall();\n                this.drawCalls.push(currentGroup);\n                currentGroup.begin(shaderSettings, style.shader);\n                currentGroup.start = index;\n                styleId = currentGroup.add(style.texture, mat,\n                    style.width, style.alignment || 0, style.packLineScale());\n            }\n            currentGroup.size += batchData.size;\n            index += batchData.size;\n\n            const { color, alpha } = style;\n            const bgr = Color.shared\n                .setValue(color)\n                .toLittleEndianNumber();\n\n            batchData.rgba = Color.shared\n                .setValue(bgr)\n                .toPremultiplied(alpha);\n            batchData.styleId = styleId;\n        }\n    }\n\n    protected processHoles(holes: Array<SmoothGraphicsData>): void\n    {\n        for (let i = 0; i < holes.length; i++)\n        {\n            const hole = holes[i];\n            const command = FILL_COMMANDS[hole.type];\n\n            hole.clearPath();\n\n            command.path(hole, this.buildData);\n\n            if (hole.matrix)\n            {\n                this.transformPoints(hole.points, hole.matrix);\n            }\n        }\n    }\n\n    /**\n     * Update the local bounds of the object. Expensive to use performance-wise.\n     *\n     * @protected\n     */\n    protected calculateBounds(): void\n    {\n        const bounds = this._bounds;\n        const sequenceBounds = tmpBounds;\n        let curMatrix = Matrix.IDENTITY;\n\n        this._bounds.clear();\n        sequenceBounds.clear();\n\n        for (let i = 0; i < this.graphicsData.length; i++)\n        {\n            const data = this.graphicsData[i];\n            const shape = data.shape;\n            const type = data.type;\n            const lineStyle = data.lineStyle;\n            const nextMatrix = data.matrix || Matrix.IDENTITY;\n            let lineWidth = 0.0;\n\n            if (lineStyle && lineStyle.visible)\n            {\n                lineWidth = lineStyle.width;\n\n                if (type !== SHAPES.POLY || data.fillStyle.visible)\n                {\n                    lineWidth *= Math.max(0, lineStyle.alignment);\n                }\n                else\n                {\n                    lineWidth *= Math.max(lineStyle.alignment, 1 - lineStyle.alignment);\n                }\n            }\n\n            if (curMatrix !== nextMatrix)\n            {\n                if (!sequenceBounds.isEmpty())\n                {\n                    bounds.addBoundsMatrix(sequenceBounds, curMatrix);\n                    sequenceBounds.clear();\n                }\n                curMatrix = nextMatrix;\n            }\n\n            if (type === SHAPES.RECT || type === SHAPES.RREC)\n            {\n                const rect = shape as Rectangle | RoundedRectangle;\n\n                sequenceBounds.addFramePad(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height,\n                    lineWidth, lineWidth);\n            }\n            else if (type === SHAPES.CIRC)\n            {\n                const circle = shape as Circle;\n\n                sequenceBounds.addFramePad(circle.x, circle.y, circle.x, circle.y,\n                    circle.radius + lineWidth, circle.radius + lineWidth);\n            }\n            else if (type === SHAPES.ELIP)\n            {\n                const ellipse = shape as Ellipse;\n\n                sequenceBounds.addFramePad(ellipse.x, ellipse.y, ellipse.x, ellipse.y,\n                    ellipse.width + lineWidth, ellipse.height + lineWidth);\n            }\n            else\n            {\n                const poly = shape as Polygon;\n                // adding directly to the bounds\n\n                bounds.addVerticesMatrix(curMatrix, (poly.points as any), 0, poly.points.length, lineWidth, lineWidth);\n            }\n        }\n\n        if (!sequenceBounds.isEmpty())\n        {\n            bounds.addBoundsMatrix(sequenceBounds, curMatrix);\n        }\n\n        bounds.pad(this.boundsPadding, this.boundsPadding);\n    }\n\n    /**\n     * Transform points using matrix.\n     *\n     * @protected\n     * @param {number[]} points - Points to transform\n     * @param {PIXI.Matrix} matrix - Transform matrix\n     */\n    protected transformPoints(points: Array<number>, matrix: Matrix): void\n    {\n        for (let i = 0; i < points.length / 2; i++)\n        {\n            const x = points[(i * 2)];\n            const y = points[(i * 2) + 1];\n\n            points[(i * 2)] = (matrix.a * x) + (matrix.c * y) + matrix.tx;\n            points[(i * 2) + 1] = (matrix.b * x) + (matrix.d * y) + matrix.ty;\n        }\n    }\n}\n","import {\n    BLEND_MODES,\n    Circle,\n    Color,\n    DRAW_MODES,\n    Ellipse,\n    Matrix,\n    MSAA_QUALITY,\n    PI_2,\n    Point,\n    Polygon,\n    Rectangle,\n    Renderer,\n    RoundedRectangle,\n    Shader,\n    SHAPES,\n    State,\n    Texture,\n    utils,\n} from '@pixi/core';\nimport { Container } from '@pixi/display';\nimport { curves, Graphics, graphicsUtils, LINE_CAP, LINE_JOIN } from '@pixi/graphics';\nimport { IGraphicsBatchSettings } from './core/BatchDrawCall';\nimport { FillStyle } from './core/FillStyle';\nimport { LINE_SCALE_MODE, LineStyle } from './core/LineStyle';\nimport { settings } from './settings';\nimport { SmoothGraphicsGeometry } from './SmoothGraphicsGeometry';\nimport { SmoothGraphicsShader } from './SmoothShader';\n\nimport type { ColorSource, IPointData, IShape } from '@pixi/core';\nimport type { IDestroyOptions } from '@pixi/display';\n\nconst UnsmoothGraphics = Graphics;\nconst { BezierUtils, QuadraticUtils, ArcUtils } = graphicsUtils;\n\n// a default shaders map used by graphics..\nconst DEFAULT_SHADERS: { [key: string]: Shader } = {};\n\nexport interface IFillStyleOptions\n{\n    color?: ColorSource;\n    alpha?: number;\n    texture?: Texture;\n    matrix?: Matrix;\n    smooth?: boolean;\n    shader?: Shader;\n}\n\nexport interface ILineStyleOptions extends IFillStyleOptions\n{\n    width?: number;\n    alignment?: number;\n    scaleMode?: LINE_SCALE_MODE;\n    cap?: LINE_CAP;\n    join?: LINE_JOIN;\n    miterLimit?: number;\n}\n\n/**\n * @memberof PIXI.smooth\n */\nexport class SmoothGraphics extends Container\n{\n    public static readonly curves = curves;\n\n    static _TEMP_POINT = new Point();\n\n    public shader: Shader;\n    public shaderSettings: IGraphicsBatchSettings;\n    public pluginName: string;\n    public currentPath: Polygon;\n\n    protected batches: Array<any>;\n    protected batchTint: number;\n    protected batchDirty: number;\n    protected vertexData: Float32Array;\n\n    protected _fillStyle: FillStyle;\n    protected _lineStyle: LineStyle;\n    protected _matrix: Matrix;\n    protected _holeMode: boolean;\n    protected _transformID: number;\n    protected _tintColor: Color;\n\n    private state: State;\n    private _geometry: SmoothGraphicsGeometry;\n\n    public get geometry(): SmoothGraphicsGeometry\n    {\n        return this._geometry;\n    }\n\n    constructor(geometry: SmoothGraphicsGeometry = null)\n    {\n        super();\n\n        this._geometry = geometry || new SmoothGraphicsGeometry();\n        this._geometry.refCount++;\n\n        this.shader = null;\n\n        this.shaderSettings = {\n            maxStyles: settings.SHADER_MAX_STYLES,\n            maxTextures: settings.SHADER_MAX_TEXTURES,\n            pixelLine: settings.PIXEL_LINE,\n        };\n\n        this.state = State.for2d();\n\n        this._fillStyle = new FillStyle();\n\n        this._lineStyle = new LineStyle();\n\n        this._matrix = null;\n\n        this._holeMode = false;\n\n        this.currentPath = null;\n\n        this.batches = [];\n\n        this.batchTint = -1;\n\n        this.batchDirty = -1;\n\n        this.vertexData = null;\n\n        this.pluginName = 'smooth';\n\n        this._transformID = -1;\n\n        // Set default\n        this._tintColor = new Color(0xFFFFFF);\n        this.blendMode = BLEND_MODES.NORMAL;\n    }\n\n    public clone(): SmoothGraphics\n    {\n        this.finishPoly();\n\n        return new SmoothGraphics(this._geometry);\n    }\n\n    public set blendMode(value: BLEND_MODES)\n    {\n        this.state.blendMode = value;\n    }\n\n    public get blendMode(): BLEND_MODES\n    {\n        return this.state.blendMode;\n    }\n\n    public get tint(): ColorSource\n    {\n        return this._tintColor.value;\n    }\n\n    public set tint(value: ColorSource)\n    {\n        this._tintColor.setValue(value);\n    }\n\n    public get fill(): FillStyle\n    {\n        return this._fillStyle;\n    }\n\n    public get line(): LineStyle\n    {\n        return this._lineStyle;\n    }\n\n    public lineStyle(\n        width: number,\n        color?: ColorSource,\n        alpha?: number,\n        alignment?: number,\n        scaleMode?: LINE_SCALE_MODE): this;\n\n    public lineStyle(options?: ILineStyleOptions): this;\n\n    public lineStyle(options: ILineStyleOptions | number = null,\n        color: ColorSource = 0x0, alpha = 1, alignment = 0.5, scaleMode = settings.LINE_SCALE_MODE): this\n    {\n        // Support non-object params: (width, color, alpha, alignment, native)\n        if (typeof options === 'number')\n        {\n            if (typeof scaleMode === 'boolean')\n            {\n                scaleMode = scaleMode ? LINE_SCALE_MODE.NONE : LINE_SCALE_MODE.NORMAL;\n            }\n            options = { width: options, color, alpha, alignment, scaleMode } as ILineStyleOptions;\n        }\n        else\n        {\n            const native: boolean = (options as any).native;\n\n            if (native !== undefined)\n            {\n                options.scaleMode = native ? LINE_SCALE_MODE.NONE : LINE_SCALE_MODE.NORMAL;\n            }\n        }\n\n        return this.lineTextureStyle(options);\n    }\n\n    public lineTextureStyle(options: ILineStyleOptions): this\n    {\n        // Apply defaults\n        options = Object.assign({\n            width: 0,\n            texture: Texture.WHITE,\n            color: (options && options.texture) ? 0xFFFFFF : 0x0,\n            alpha: 1,\n            matrix: null,\n            alignment: 0.5,\n            native: false,\n            cap: LINE_CAP.BUTT,\n            join: LINE_JOIN.MITER,\n            miterLimit: 10,\n            shader: null,\n            scaleMode: settings.LINE_SCALE_MODE,\n        }, options);\n\n        this.normalizeColor(options);\n\n        if (this.currentPath)\n        {\n            this.startPoly();\n        }\n\n        const visible = options.width > 0 && options.alpha > 0;\n\n        if (!visible)\n        {\n            this._lineStyle.reset();\n        }\n        else\n        {\n            if (options.matrix)\n            {\n                options.matrix = options.matrix.clone();\n                options.matrix.invert();\n            }\n\n            Object.assign(this._lineStyle, { visible }, options);\n        }\n\n        return this;\n    }\n\n    protected startPoly(): void\n    {\n        if (this.currentPath)\n        {\n            const points = this.currentPath.points;\n            const len = this.currentPath.points.length;\n\n            if (len > 2)\n            {\n                this.drawShape(this.currentPath);\n                this.currentPath = new Polygon();\n                this.currentPath.closeStroke = false;\n                this.currentPath.points.push(points[len - 2], points[len - 1]);\n            }\n        }\n        else\n        {\n            this.currentPath = new Polygon();\n            this.currentPath.closeStroke = false;\n        }\n    }\n\n    finishPoly(): void\n    {\n        if (this.currentPath)\n        {\n            if (this.currentPath.points.length > 2)\n            {\n                this.drawShape(this.currentPath);\n                this.currentPath = null;\n            }\n            else\n            {\n                this.currentPath.points.length = 0;\n            }\n        }\n    }\n\n    public moveTo(x: number, y: number): this\n    {\n        this.startPoly();\n        this.currentPath.points[0] = x;\n        this.currentPath.points[1] = y;\n\n        return this;\n    }\n\n    public lineTo(x: number, y: number): this\n    {\n        if (!this.currentPath)\n        {\n            this.moveTo(0, 0);\n        }\n\n        // remove duplicates..\n        const points = this.currentPath.points;\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        if (fromX !== x || fromY !== y)\n        {\n            points.push(x, y);\n        }\n\n        return this;\n    }\n\n    protected _initCurve(x = 0, y = 0): void\n    {\n        if (this.currentPath)\n        {\n            if (this.currentPath.points.length === 0)\n            {\n                this.currentPath.points = [x, y];\n            }\n        }\n        else\n        {\n            this.moveTo(x, y);\n        }\n    }\n\n    public quadraticCurveTo(cpX: number, cpY: number, toX: number, toY: number): this\n    {\n        this._initCurve();\n\n        const points = this.currentPath.points;\n\n        if (points.length === 0)\n        {\n            this.moveTo(0, 0);\n        }\n\n        QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);\n\n        return this;\n    }\n\n    public bezierCurveTo(cpX: number, cpY: number, cpX2: number, cpY2: number, toX: number, toY: number): this\n    {\n        this._initCurve();\n\n        BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);\n\n        return this;\n    }\n\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this\n    {\n        this._initCurve(x1, y1);\n\n        const points = this.currentPath.points;\n\n        const result = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);\n\n        if (result)\n        {\n            const { cx, cy, radius, startAngle, endAngle, anticlockwise } = result;\n\n            this.arc(cx, cy, radius, startAngle, endAngle, anticlockwise);\n        }\n\n        return this;\n    }\n\n    public arc(cx: number, cy: number, radius: number, startAngle: number, endAngle: number, anticlockwise = false): this\n    {\n        if (startAngle === endAngle)\n        {\n            return this;\n        }\n\n        if (!anticlockwise && endAngle <= startAngle)\n        {\n            endAngle += PI_2;\n        }\n        else if (anticlockwise && startAngle <= endAngle)\n        {\n            startAngle += PI_2;\n        }\n\n        const sweep = endAngle - startAngle;\n\n        if (sweep === 0)\n        {\n            return this;\n        }\n\n        const startX = cx + (Math.cos(startAngle) * radius);\n        const startY = cy + (Math.sin(startAngle) * radius);\n        const eps = this._geometry.closePointEps;\n\n        // If the currentPath exists, take its points. Otherwise call `moveTo` to start a path.\n        let points = this.currentPath ? this.currentPath.points : null;\n\n        if (points)\n        {\n            // TODO: make a better fix.\n\n            // We check how far our start is from the last existing point\n            const xDiff = Math.abs(points[points.length - 2] - startX);\n            const yDiff = Math.abs(points[points.length - 1] - startY);\n\n            if (xDiff < eps && yDiff < eps)\n            {\n                // If the point is very close, we don't add it, since this would lead to artifacts\n                // during tessellation due to floating point imprecision.\n            }\n            else\n            {\n                points.push(startX, startY);\n            }\n        }\n        else\n        {\n            this.moveTo(startX, startY);\n            points = this.currentPath.points;\n        }\n\n        ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);\n\n        return this;\n    }\n\n    public beginFill(color: ColorSource = 0, alpha = 1, smooth = false): this\n    {\n        return this.beginTextureFill({ texture: Texture.WHITE, color, alpha, smooth });\n    }\n\n    private normalizeColor(options: Pick<IFillStyleOptions, 'color' | 'alpha'>): void\n    {\n        const temp = Color.shared.setValue(options.color ?? 0);\n\n        options.color = temp.toNumber();\n        options.alpha ??= temp.alpha;\n    }\n\n    beginTextureFill(options?: IFillStyleOptions): this\n    {\n        // Apply defaults\n        options = Object.assign({\n            texture: Texture.WHITE,\n            color: 0xFFFFFF,\n            alpha: 1,\n            matrix: null,\n            smooth: false,\n        }, options) as IFillStyleOptions;\n\n        this.normalizeColor(options);\n\n        if (this.currentPath)\n        {\n            this.startPoly();\n        }\n\n        const visible = options.alpha > 0;\n\n        if (!visible)\n        {\n            this._fillStyle.reset();\n        }\n        else\n        {\n            if (options.matrix)\n            {\n                options.matrix = options.matrix.clone();\n                options.matrix.invert();\n            }\n\n            Object.assign(this._fillStyle, { visible }, options);\n        }\n\n        return this;\n    }\n\n    public endFill(): this\n    {\n        this.finishPoly();\n\n        this._fillStyle.reset();\n\n        return this;\n    }\n\n    public drawRect(x: number, y: number, width: number, height: number): this\n    {\n        return this.drawShape(new Rectangle(x, y, width, height));\n    }\n\n    public drawRoundedRect(x: number, y: number, width: number, height: number, radius: number): this\n    {\n        return this.drawShape(new RoundedRectangle(x, y, width, height, radius));\n    }\n\n    public drawCircle(x: number, y: number, radius: number): this\n    {\n        return this.drawShape(new Circle(x, y, radius));\n    }\n\n    public drawEllipse(x: number, y: number, width: number, height: number): this\n    {\n        return this.drawShape(new Ellipse(x, y, width, height));\n    }\n\n    public drawPolygon(...path: Array<number> | Array<IPointData>): this;\n    public drawPolygon(path: Array<number> | Array<IPointData> | Polygon): this;\n\n    public drawPolygon(...path: any[]): this\n    {\n        let points: Array<number> | Array<IPointData>;\n        let closeStroke = true;// !!this._fillStyle;\n\n        const poly = path[0] as Polygon;\n\n        // check if data has points..\n        if (poly.points)\n        {\n            closeStroke = poly.closeStroke;\n            points = poly.points;\n        }\n        else if (Array.isArray(path[0]))\n        {\n            points = path[0];\n        }\n        else\n        {\n            points = path;\n        }\n\n        const shape = new Polygon(points);\n\n        shape.closeStroke = closeStroke;\n\n        this.drawShape(shape);\n\n        return this;\n    }\n\n    public drawShape(shape: IShape): this\n    {\n        if (!this._holeMode)\n        {\n            this._geometry.drawShape(\n                shape,\n                this._fillStyle.clone(),\n                this._lineStyle.clone(),\n                this._matrix\n            );\n        }\n        else\n        {\n            this._geometry.drawHole(shape, this._matrix);\n        }\n\n        return this;\n    }\n\n    public clear(): this\n    {\n        this._geometry.clear();\n        this._lineStyle.reset();\n        this._fillStyle.reset();\n\n        this._boundsID++;\n        this._matrix = null;\n        this._holeMode = false;\n        this.currentPath = null;\n\n        return this;\n    }\n\n    public isFastRect(): boolean\n    {\n        const data = this._geometry.graphicsData;\n\n        return data.length === 1\n            && data[0].shape.type === SHAPES.RECT\n            && !data[0].matrix\n            && !data[0].holes.length\n            && !(data[0].lineStyle.visible && data[0].lineStyle.width);\n    }\n\n    protected _renderCanvas(renderer: any): void\n    {\n        (UnsmoothGraphics.prototype as any)._renderCanvas.call(this, renderer);\n    }\n\n    protected _render(renderer: Renderer): void\n    {\n        this.finishPoly();\n\n        const geometry = this._geometry;\n        const hasuint32 = renderer.context.supports.uint32Indices;\n        // batch part..\n        // batch it!\n\n        geometry.checkInstancing(renderer.geometry.hasInstance, hasuint32);\n\n        geometry.updateBatches(this.shaderSettings);\n\n        if (geometry.batchable)\n        {\n            if (this.batchDirty !== geometry.batchDirty)\n            {\n                this._populateBatches();\n            }\n\n            this._renderBatched(renderer);\n        }\n        else\n        {\n            // no batching...\n            renderer.batch.flush();\n\n            this._renderDirect(renderer);\n        }\n    }\n\n    protected _populateBatches(): void\n    {\n        const geometry = this._geometry;\n        const blendMode = this.blendMode;\n        const len = geometry.batches.length;\n\n        this.batchTint = -1;\n        this._transformID = -1;\n        this.batchDirty = geometry.batchDirty;\n        this.batches.length = len;\n\n        this.vertexData = new Float32Array(geometry.points);\n\n        for (let i = 0; i < len; i++)\n        {\n            const gI = geometry.batches[i];\n            const color = gI.style.color;\n            const vertexData = new Float32Array(this.vertexData.buffer,\n                gI.attribStart * 4 * 2,\n                gI.attribSize * 2);\n\n            // const uvs = new Float32Array(geometry.uvsFloat32.buffer,\n            //     gI.attribStart * 4 * 2,\n            //     gI.attribSize * 2);\n\n            // const indices = new Uint16Array(geometry.indicesUint16.buffer,\n            //     gI.start * 2,\n            //     gI.size);\n\n            const batch = {\n                vertexData,\n                blendMode,\n                // indices,\n                // uvs,\n                _batchRGB: utils.hex2rgb(color) as Array<number>,\n                _tintRGB: color,\n                _texture: gI.style.texture,\n                alpha: gI.style.alpha,\n                worldAlpha: 1\n            };\n\n            this.batches[i] = batch;\n        }\n    }\n\n    protected _renderBatched(renderer: Renderer): void\n    {\n        if (!this.batches.length)\n        {\n            return;\n        }\n\n        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n\n        this.calculateVertices();\n        this.calculateTints();\n\n        for (let i = 0, l = this.batches.length; i < l; i++)\n        {\n            const batch = this.batches[i];\n\n            batch.worldAlpha = this.worldAlpha * batch.alpha;\n\n            renderer.plugins[this.pluginName].render(batch);\n        }\n    }\n\n    protected _renderDirect(renderer: Renderer): void\n    {\n        const directShader = this._resolveDirectShader(renderer);\n        let shader: Shader = directShader;\n\n        const geometry = this._geometry;\n        const worldAlpha = this.worldAlpha;\n        const uniforms = shader.uniforms;\n        const drawCalls = geometry.drawCalls;\n\n        // lets set the transfomr\n        uniforms.translationMatrix = this.transform.worldTransform;\n\n        // and then lets set the tint..\n        Color.shared.setValue(this._tintColor)\n            .premultiply(worldAlpha)\n            .toArray(uniforms.tint);\n\n        uniforms.resolution = renderer.renderTexture.current\n            ? renderer.renderTexture.current.resolution : renderer.resolution;\n\n        const projTrans = renderer.projection.transform;\n\n        if (projTrans)\n        {\n            // only uniform scale is supported!\n            const scale = Math.sqrt((projTrans.a * projTrans.a) + (projTrans.b * projTrans.b));\n\n            uniforms.resolution *= scale;\n        }\n\n        const multisample = renderer.renderTexture.current\n            ? renderer.renderTexture.current.multisample : renderer.multisample;\n\n        uniforms.expand = (multisample !== MSAA_QUALITY.NONE ? 2 : 1) / uniforms.resolution;\n\n        // the first draw call, we can set the uniforms of the shader directly here.\n\n        // this means that we can tack advantage of the sync function of pixi!\n        // bind and sync uniforms..\n        // there is a way to optimise this..\n        renderer.shader.bind(shader);\n        renderer.geometry.bind(geometry, shader);\n\n        // set state..\n        renderer.state.set(this.state);\n\n        shader = null;\n        // then render the rest of them...\n        for (let i = 0, l = drawCalls.length; i < l; i++)\n        {\n            // TODO: refactor it to another class, that fills uniforms of this shader\n            const drawCall = geometry.drawCalls[i];\n\n            const shaderChange = shader !== drawCall.shader;\n\n            if (shaderChange)\n            {\n                shader = drawCall.shader;\n                if (shader)\n                {\n                    shader.uniforms.translationMatrix = this.transform.worldTransform;\n                    if (shader.uniforms.tint)\n                    {\n                        shader.uniforms.tint[0] = uniforms.tint[0];\n                        shader.uniforms.tint[1] = uniforms.tint[1];\n                        shader.uniforms.tint[2] = uniforms.tint[2];\n                        shader.uniforms.tint[3] = uniforms.tint[3];\n                    }\n                }\n            }\n\n            const { texArray, styleArray, size, start } = drawCall;\n            const groupTextureCount = texArray.count;\n            const shaderHere = shader || directShader;\n\n            const texs = shaderHere.uniforms.styleTextureId;\n            const mats = shaderHere.uniforms.styleMatrix;\n            const lines = shaderHere.uniforms.styleLine;\n\n            for (let i = 0; i < styleArray.count; i++)\n            {\n                texs[i] = styleArray.textureIds[i];\n                lines[i * 2] = styleArray.lines[i * 2];\n                lines[(i * 2) + 1] = styleArray.lines[(i * 2) + 1];\n                const m = styleArray.matrices[i];\n\n                mats[i * 6] = m.a;\n                mats[(i * 6) + 1] = m.c;\n                mats[(i * 6) + 2] = m.tx;\n                mats[(i * 6) + 3] = m.b;\n                mats[(i * 6) + 4] = m.d;\n                mats[(i * 6) + 5] = m.ty;\n            }\n            const sizes = shaderHere.uniforms.samplerSize;\n\n            for (let i = 0; i < groupTextureCount; i++)\n            {\n                sizes[i * 2] = texArray.elements[i].width;\n                sizes[(i * 2) + 1] = texArray.elements[i].height;\n            }\n\n            renderer.shader.bind(shaderHere);\n            if (shaderChange)\n            {\n                renderer.geometry.bind(geometry);\n            }\n\n            // TODO: bind styles!\n            for (let j = 0; j < groupTextureCount; j++)\n            {\n                renderer.texture.bind(texArray.elements[j], j);\n            }\n\n            // bind the geometry...\n            renderer.geometry.draw(DRAW_MODES.TRIANGLES, size, start);\n        }\n    }\n\n    protected _resolveDirectShader(_renderer: Renderer): Shader\n    {\n        let shader = this.shader;\n\n        const pluginName = this.pluginName;\n\n        if (!shader)\n        {\n            if (!DEFAULT_SHADERS[pluginName])\n            {\n                DEFAULT_SHADERS[pluginName] = new SmoothGraphicsShader(this.shaderSettings);\n            }\n            shader = DEFAULT_SHADERS[pluginName];\n        }\n\n        return shader;\n    }\n\n    protected _calculateBounds(): void\n    {\n        this.finishPoly();\n\n        const geometry = this._geometry;\n\n        // skipping when graphics is empty, like a container\n        if (!geometry.graphicsData.length)\n        {\n            return;\n        }\n\n        const { minX, minY, maxX, maxY } = geometry.bounds;\n\n        this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n    }\n\n    public containsPoint(point: IPointData): boolean\n    {\n        this.worldTransform.applyInverse(point, SmoothGraphics._TEMP_POINT);\n\n        return this._geometry.containsPoint(SmoothGraphics._TEMP_POINT);\n    }\n\n    protected calculateTints(): void\n    {\n        if (this.batchTint !== this.tint)\n        {\n            this.batchTint = this._tintColor.toNumber();\n\n            for (let i = 0; i < this.batches.length; i++)\n            {\n                const batch = this.batches[i];\n\n                batch._tintRGB = Color.shared\n                    .setValue(this._tintColor)\n                    .multiply(batch._batchRGB)\n                    .toLittleEndianNumber();\n            }\n        }\n    }\n\n    protected calculateVertices(): void\n    {\n        const wtID = this.transform._worldID;\n\n        if (this._transformID === wtID)\n        {\n            return;\n        }\n\n        this._transformID = wtID;\n\n        const wt = this.transform.worldTransform;\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const data = this._geometry.points;// batch.vertexDataOriginal;\n        const vertexData = this.vertexData;\n\n        let count = 0;\n\n        for (let i = 0; i < data.length; i += 2)\n        {\n            const x = data[i];\n            const y = data[i + 1];\n\n            vertexData[count++] = (a * x) + (c * y) + tx;\n            vertexData[count++] = (d * y) + (b * x) + ty;\n        }\n    }\n\n    public closePath(): this\n    {\n        const currentPath = this.currentPath;\n\n        if (currentPath)\n        {\n            // we don't need to add extra point in the end because buildLine will take care of that\n            currentPath.closeStroke = true;\n        }\n\n        return this;\n    }\n\n    public setMatrix(matrix: Matrix): this\n    {\n        this._matrix = matrix;\n\n        return this;\n    }\n\n    public beginHole(): this\n    {\n        this.finishPoly();\n        this._holeMode = true;\n\n        return this;\n    }\n\n    public endHole(): this\n    {\n        this.finishPoly();\n        this._holeMode = false;\n\n        return this;\n    }\n\n    public destroy(options?: IDestroyOptions | boolean): void\n    {\n        this._geometry.refCount--;\n        if (this._geometry.refCount === 0)\n        {\n            this._geometry.dispose();\n        }\n\n        this._matrix = null;\n        this.currentPath = null;\n        this._lineStyle.destroy();\n        this._lineStyle = null;\n        this._fillStyle.destroy();\n        this._fillStyle = null;\n        this._geometry = null;\n        this.shader = null;\n        this.vertexData = null;\n        this.batches.length = 0;\n        this.batches = null;\n\n        super.destroy(options);\n    }\n}\n"],"names":["matrixEquals","th","matrix","eps","BatchStyleArray","i","textureId","lineWidth","lineAlignment","lineScaleMode","settings","textureIds","matrices","lines","count","BatchDrawCall","BatchTextureArray","BLEND_MODES","shader","BaseTexture","texture","texArray","TICK","styleArray","baseTexture","loc","res","Matrix","BatchPart","style","startIndex","attribStart","endIndex","endAttrib","BuildData","JOINT_TYPE","A","FillStyle","obj","Texture","tex","LINE_SCALE_MODE","LineStyle","LINE_CAP","LINE_JOIN","_SegmentPacker","jointStart","jointLen","triangles","target","joints","foundTriangle","vertexSize","indexSize","prevCap","joint","vs","buildData","bufFloat","bufUint","indices","bufferPos","indexPos","lineStyle","color","strideFloats","verts","bufPos","indPos","index","x1","y1","x2","y2","prevX","prevY","nextX","nextY","hasTriangle","travel","j","fullJoint","bis","dist","SegmentPacker","SmoothGraphicsData","shape","fillStyle","cap","smoothVert","precision","smoothFrag","pixelLineFunc","pixelCoverage","SmoothGraphicsShader","Shader","vert","frag","uniforms","maxStyles","maxTextures","sampleValues","Program","vertexSrc","fragmentSrc","pixelLine","src","dashFrag","DashLineShader","dashParams","CircleBuilder","graphicsData","_target","points","x","y","dx","dy","rx","ry","SHAPES","circle","ellipse","roundedRect","halfWidth","halfHeight","n","m","j1","j2","j3","j4","x0","y0","a","cx","cy","vertPos","center","len","nx1","ny1","n1","bx1","by1","nx2","ny2","n2","bx2","by2","b2","tempArr","fixOrientation","hole","area","i1","i2","i3","i4","PolyBuilder","eps2","firstPoint","Point","lastPoint","closedShape","newLen","flag","x3","y3","closeStroke","endJoint","holes","holeArray","pn","start","finish","utils","ind1","ind2","ind","prev","next","D1","D2","bx","by","D","RectangleBuilder","rectData","width","height","RoundedRectangleBuilder","FILL_COMMANDS","BATCH_POOL","DRAW_CALL_POOL","tmpPoint","tmpBounds","Bounds","SmoothGraphicsGeometry","Geometry","_static","Buffer","TYPES","instanced","allow32Indices","batchPart","data","lastShape","point","hitHole","command","shaderSettings","currentStyle","nextTexture","attribOld","indexOld","WRAP_MODES","packer","batches","buffer","floatsSize","arrBuf","styleA","styleB","mat1","mat2","l","fill","line","batch","currentGroup","batchData","styleId","mat","alpha","bgr","Color","bounds","sequenceBounds","curMatrix","type","nextMatrix","rect","poly","UnsmoothGraphics","Graphics","BezierUtils","QuadraticUtils","ArcUtils","graphicsUtils","DEFAULT_SHADERS","_SmoothGraphics","Container","geometry","State","value","options","alignment","scaleMode","native","visible","Polygon","fromX","fromY","cpX","cpY","toX","toY","cpX2","cpY2","radius","result","startAngle","endAngle","anticlockwise","PI_2","startX","startY","xDiff","yDiff","smooth","_a","_b","temp","Rectangle","RoundedRectangle","Circle","Ellipse","path","renderer","hasuint32","blendMode","gI","directShader","worldAlpha","drawCalls","projTrans","scale","multisample","MSAA_QUALITY","drawCall","shaderChange","size","groupTextureCount","shaderHere","texs","mats","sizes","DRAW_MODES","_renderer","pluginName","minX","minY","maxX","maxY","wtID","wt","b","c","d","tx","ty","vertexData","currentPath","SmoothGraphics","curves"],"mappings":"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"}