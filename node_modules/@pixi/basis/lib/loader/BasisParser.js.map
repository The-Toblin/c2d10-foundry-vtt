{"version":3,"file":"BasisParser.js","sources":["../../src/loader/BasisParser.ts"],"sourcesContent":["import { CompressedTextureResource } from '@pixi/compressed-textures';\nimport { BufferResource, settings, TYPES } from '@pixi/core';\nimport {\n    BASIS_FORMAT_TO_INTERNAL_FORMAT,\n    BASIS_FORMATS,\n    BASIS_FORMATS_ALPHA,\n    INTERNAL_FORMAT_TO_BASIS_FORMAT,\n} from '../Basis';\nimport { TranscoderWorker } from '../TranscoderWorker';\n\nimport type { CompressedLevelBuffer, INTERNAL_FORMATS } from '@pixi/compressed-textures';\nimport type { BasisBinding, BasisTextureExtensions } from '../Basis';\n\nexport type TranscodedResourcesArray = (Array<CompressedTextureResource> | Array<BufferResource>) & {\n    basisFormat: BASIS_FORMATS\n};\n\n/**\n * Loader plugin for handling BASIS supercompressed texture files.\n *\n * To use this loader, you must bind the basis_universal WebAssembly transcoder. There are two ways of\n * doing this:\n *\n * 1. Adding a &lt;script&gt; tag to your HTML page to the transcoder bundle in this package, and serving\n * the WASM binary from the same location.\n *\n * ```html\n * <!-- Copy ./node_modules/@pixi/basis/assets/basis_.wasm into your assets directory\n *     as well, so it is served from the same folder as the JavaScript! -->\n * <script src=\"./node_modules/@pixi/basis/assets/basis_transcoder.js\"></script>\n * ```\n *\n * NOTE: `basis_transcoder.js` expects the WebAssembly binary to be named `basis_transcoder.wasm`.\n * NOTE-2: This method supports transcoding on the main-thread. Only use this if you have 1 or 2 *.basis\n * files.\n *\n * 2. Loading the transcoder source from a URL.\n *\n * ```js\n * // Use this if you to use the default CDN url for @pixi/basis\n * BasisParser.loadTranscoder();\n *\n * // Use this if you want to serve the transcoder on your own\n * BasisParser.loadTranscoder('./basis_transcoder.js', './basis_transcoder.wasm');\n * ```\n *\n * NOTE: This can only be used with web-workers.\n * @class\n * @memberof PIXI\n * @implements {PIXI.ILoaderPlugin}\n */\nexport class BasisParser\n{\n    public static basisBinding: BasisBinding;\n    private static defaultRGBFormat: { basisFormat: BASIS_FORMATS, textureFormat: INTERNAL_FORMATS | TYPES };\n    private static defaultRGBAFormat: { basisFormat: BASIS_FORMATS, textureFormat: INTERNAL_FORMATS | TYPES };\n    private static fallbackMode = false;\n    private static workerPool: TranscoderWorker[] = [];\n\n    /**\n     * Runs transcoding and populates imageArray. It will run the transcoding in a web worker\n     * if they are available.\n     * @private\n     */\n    public static async transcode(arrayBuffer: ArrayBuffer): Promise<TranscodedResourcesArray>\n    {\n        let resources: TranscodedResourcesArray;\n\n        if (typeof Worker !== 'undefined' && BasisParser.TranscoderWorker.wasmSource)\n        {\n            resources = await BasisParser.transcodeAsync(arrayBuffer);\n        }\n        else\n        {\n            resources = BasisParser.transcodeSync(arrayBuffer);\n        }\n\n        return resources;\n    }\n\n    /**\n     * Finds a suitable worker for transcoding and sends a transcoding request\n     * @private\n     * @async\n     */\n    public static async transcodeAsync(arrayBuffer: ArrayBuffer): Promise<TranscodedResourcesArray>\n    {\n        if (!BasisParser.defaultRGBAFormat && !BasisParser.defaultRGBFormat)\n        {\n            BasisParser.autoDetectFormats();\n        }\n\n        const workerPool = BasisParser.workerPool;\n\n        let leastLoad = 0x10000000;\n        let worker = null;\n\n        for (let i = 0, j = workerPool.length; i < j; i++)\n        {\n            if (workerPool[i].load < leastLoad)\n            {\n                worker = workerPool[i];\n                leastLoad = worker.load;\n            }\n        }\n\n        if (!worker)\n        {\n            /* eslint-disable-next-line no-use-before-define */\n            worker = new TranscoderWorker();\n\n            workerPool.push(worker);\n        }\n\n        // Wait until worker is ready\n        await worker.initAsync();\n\n        const response = await worker.transcodeAsync(\n            new Uint8Array(arrayBuffer),\n            BasisParser.defaultRGBAFormat.basisFormat,\n            BasisParser.defaultRGBFormat.basisFormat,\n        );\n\n        const basisFormat = response.basisFormat;\n        const imageArray = response.imageArray;\n\n        // whether it is an uncompressed format\n        const fallbackMode = basisFormat > 12;\n        let imageResources: TranscodedResourcesArray;\n\n        if (!fallbackMode)\n        {\n            const format = BASIS_FORMAT_TO_INTERNAL_FORMAT[response.basisFormat];\n\n            // HINT: this.imageArray is CompressedTextureResource[]\n            imageResources = new Array<CompressedTextureResource>(imageArray.length) as TranscodedResourcesArray;\n\n            for (let i = 0, j = imageArray.length; i < j; i++)\n            {\n                imageResources[i] = new CompressedTextureResource(null, {\n                    format,\n                    width: imageArray[i].width,\n                    height: imageArray[i].height,\n                    levelBuffers: imageArray[i].levelArray,\n                    levels: imageArray[i].levelArray.length,\n                });\n            }\n        }\n        else\n        {\n            // TODO: BufferResource does not support manual mipmapping.\n            imageResources = imageArray.map((image) => new BufferResource(\n                new Uint16Array(image.levelArray[0].levelBuffer.buffer), {\n                    width: image.width,\n                    height: image.height,\n                }),\n            ) as TranscodedResourcesArray;\n        }\n\n        imageResources.basisFormat = basisFormat;\n\n        return imageResources;\n    }\n\n    /**\n     * Runs transcoding on the main thread.\n     * @private\n     */\n    public static transcodeSync(arrayBuffer: ArrayBuffer): TranscodedResourcesArray\n    {\n        if (!BasisParser.defaultRGBAFormat && !BasisParser.defaultRGBFormat)\n        {\n            BasisParser.autoDetectFormats();\n        }\n\n        const BASIS = BasisParser.basisBinding;\n\n        const data = new Uint8Array(arrayBuffer);\n        const basisFile = new BASIS.BasisFile(data);\n        const imageCount = basisFile.getNumImages();\n        const hasAlpha = basisFile.getHasAlpha();\n\n        const basisFormat = hasAlpha\n            ? BasisParser.defaultRGBAFormat.basisFormat\n            : BasisParser.defaultRGBFormat.basisFormat;\n        const basisFallbackFormat = BASIS_FORMATS.cTFRGB565;\n        const imageResources = new Array<CompressedTextureResource | BufferResource>(imageCount);\n\n        let fallbackMode = BasisParser.fallbackMode;\n\n        if (!basisFile.startTranscoding())\n        {\n            if (process.env.DEBUG)\n            {\n                console.error(`Basis failed to start transcoding!`);\n            }\n\n            basisFile.close();\n            basisFile.delete();\n\n            return null;\n        }\n\n        for (let i = 0; i < imageCount; i++)\n        {\n            // Don't transcode all mipmap levels in fallback mode!\n            const levels = !fallbackMode ? basisFile.getNumLevels(i) : 1;\n            const width = basisFile.getImageWidth(i, 0);\n            const height = basisFile.getImageHeight(i, 0);\n            const alignedWidth = (width + 3) & ~3;\n            const alignedHeight = (height + 3) & ~3;\n\n            const imageLevels = new Array<CompressedLevelBuffer>(levels);\n\n            // Transcode mipmap levels into \"imageLevels\"\n            for (let j = 0; j < levels; j++)\n            {\n                const levelWidth = basisFile.getImageWidth(i, j);\n                const levelHeight = basisFile.getImageHeight(i, j);\n                const byteSize = basisFile.getImageTranscodedSizeInBytes(\n                    i, 0, !fallbackMode ? basisFormat : basisFallbackFormat);\n\n                imageLevels[j] = {\n                    levelID: j,\n                    levelBuffer: new Uint8Array(byteSize),\n                    levelWidth,\n                    levelHeight,\n                };\n\n                if (!basisFile.transcodeImage(\n                    imageLevels[j].levelBuffer, i, 0, !fallbackMode ? basisFormat : basisFallbackFormat, false, false))\n                {\n                    if (fallbackMode)\n                    {\n                        if (process.env.DEBUG)\n                        {\n                            console.error(`Basis failed to transcode image ${i}, level ${0}!`);\n                        }\n                        break;\n                    }\n                    else\n                    {\n                        // Try transcoding to an uncompressed format before giving up!\n                        // NOTE: We must start all over again as all Resources must be in compressed OR uncompressed.\n                        i = -1;\n                        fallbackMode = true;\n\n                        if (process.env.DEBUG)\n                        {\n                        /* eslint-disable-next-line max-len */\n                            console.warn(`Basis failed to transcode image ${i}, level ${0} to a compressed texture format. Retrying to an uncompressed fallback format!`);\n                        }\n                        continue;\n                    }\n                }\n            }\n\n            let imageResource;\n\n            if (!fallbackMode)\n            {\n                imageResource = new CompressedTextureResource(null, {\n                    format: BASIS_FORMAT_TO_INTERNAL_FORMAT[basisFormat],\n                    width: alignedWidth,\n                    height: alignedHeight,\n                    levelBuffers: imageLevels,\n                    levels,\n                });\n            }\n            else\n            {\n                // TODO: BufferResource doesn't support manual mipmap levels\n                imageResource = new BufferResource(\n                    new Uint16Array(imageLevels[0].levelBuffer.buffer), { width, height });\n            }\n\n            imageResources[i] = imageResource;\n        }\n\n        basisFile.close();\n        basisFile.delete();\n\n        const transcodedResources = imageResources as TranscodedResourcesArray;\n\n        transcodedResources.basisFormat = !fallbackMode ? basisFormat : basisFallbackFormat;\n\n        return transcodedResources;\n    }\n\n    /**\n     * Detects the available compressed texture formats on the device.\n     * @param extensions - extensions provided by a WebGL context\n     * @ignore\n     */\n    static autoDetectFormats(extensions?: Partial<BasisTextureExtensions>): void\n    {\n        // Auto-detect WebGL compressed-texture extensions\n        if (!extensions)\n        {\n            const canvas = settings.ADAPTER.createCanvas();\n            const gl = canvas.getContext('webgl');\n\n            if (!gl)\n            {\n                console.error('WebGL not available for BASIS transcoding. Silently failing.');\n\n                return;\n            }\n\n            extensions = {\n                bptc: gl.getExtension('EXT_texture_compression_bptc'),\n                astc: gl.getExtension('WEBGL_compressed_texture_astc'),\n                etc: gl.getExtension('WEBGL_compressed_texture_etc'),\n                s3tc: gl.getExtension('WEBGL_compressed_texture_s3tc'),\n                s3tc_sRGB: gl.getExtension('WEBGL_compressed_texture_s3tc_srgb'), /* eslint-disable-line camelcase */\n                pvrtc: gl.getExtension('WEBGL_compressed_texture_pvrtc')\n                    || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc'),\n                etc1: gl.getExtension('WEBGL_compressed_texture_etc1'),\n                atc: gl.getExtension('WEBGL_compressed_texture_atc'),\n            };\n        }\n\n        // Discover the available texture formats\n        const supportedFormats: { [id: string]: INTERNAL_FORMATS } = {};\n\n        for (const key in extensions)\n        {\n            const extension = (extensions as any)[key];\n\n            if (!extension)\n            {\n                continue;\n            }\n\n            Object.assign(supportedFormats, Object.getPrototypeOf(extension));\n        }\n\n        // Set the default alpha/non-alpha output formats for basisu transcoding\n        for (let i = 0; i < 2; i++)\n        {\n            const detectWithAlpha = !!i;\n            let internalFormat: number;\n            let basisFormat: number;\n\n            for (const id in supportedFormats)\n            {\n                internalFormat = supportedFormats[id];\n                basisFormat = INTERNAL_FORMAT_TO_BASIS_FORMAT[internalFormat];\n\n                if (basisFormat !== undefined)\n                {\n                    if ((detectWithAlpha && BASIS_FORMATS_ALPHA[basisFormat])\n                        || (!detectWithAlpha && !BASIS_FORMATS_ALPHA[basisFormat]))\n                    {\n                        break;\n                    }\n                }\n            }\n\n            if (internalFormat)\n            {\n                BasisParser[detectWithAlpha ? 'defaultRGBAFormat' : 'defaultRGBFormat'] = {\n                    textureFormat: internalFormat,\n                    basisFormat,\n                };\n            }\n            else\n            {\n                BasisParser[detectWithAlpha ? 'defaultRGBAFormat' : 'defaultRGBFormat'] = {\n                    textureFormat: TYPES.UNSIGNED_SHORT_5_6_5,\n                    basisFormat: BASIS_FORMATS.cTFRGB565,\n                };\n\n                BasisParser.fallbackMode = true;\n            }\n        }\n    }\n\n    /**\n     * Binds the basis_universal transcoder to decompress *.basis files. You must initialize the transcoder library yourself.\n     * @example\n     * import { BasisParser } from '@pixi/basis';\n     *\n     * // BASIS() returns a Promise-like object\n     * globalThis.BASIS().then((basisLibrary) =>\n     * {\n     *     // Initialize basis-library; otherwise, transcoded results maybe corrupt!\n     *     basisLibrary.initializeBasis();\n     *\n     *     // Bind BasisParser to the transcoder\n     *     BasisParser.bindTranscoder(basisLibrary);\n     * });\n     * @param basisLibrary - the initialized transcoder library\n     * @private\n     */\n    static bindTranscoder(basisLibrary: BasisBinding): void\n    {\n        BasisParser.basisBinding = basisLibrary;\n    }\n\n    /**\n     * Loads the transcoder source code for use in {@link PIXI.BasisParser.TranscoderWorker}.\n     * @private\n     * @param jsURL - URL to the javascript basis transcoder\n     * @param wasmURL - URL to the wasm basis transcoder\n     */\n    static loadTranscoder(jsURL: string, wasmURL: string): Promise<[void, void]>\n    {\n        return BasisParser.TranscoderWorker.loadTranscoder(jsURL, wasmURL);\n    }\n\n    /**\n     * Set the transcoder source code directly\n     * @private\n     * @param jsSource - source for the javascript basis transcoder\n     * @param wasmSource - source for the wasm basis transcoder\n     */\n    static setTranscoder(jsSource: string, wasmSource: ArrayBuffer): void\n    {\n        BasisParser.TranscoderWorker.setTranscoder(jsSource, wasmSource);\n    }\n\n    static TranscoderWorker: typeof TranscoderWorker = TranscoderWorker;\n\n    static get TRANSCODER_WORKER_POOL_LIMIT(): number\n    {\n        return this.workerPool.length || 1;\n    }\n\n    static set TRANSCODER_WORKER_POOL_LIMIT(limit: number)\n    {\n        // TODO: Destroy workers?\n        for (let i = this.workerPool.length; i < limit; i++)\n        {\n            this.workerPool[i] = new TranscoderWorker();\n            this.workerPool[i].initAsync();\n        }\n    }\n}\n"],"names":["_BasisParser","TranscoderWorker","BufferResource","BASIS_FORMAT_TO_INTERNAL_FORMAT","CompressedTextureResource","BASIS_FORMATS","settings","INTERNAL_FORMAT_TO_BASIS_FORMAT","BASIS_FORMATS_ALPHA","TYPES"],"mappings":"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"}