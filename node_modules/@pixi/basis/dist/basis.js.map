{"version":3,"file":"basis.js","sources":["../src/Basis.ts","../src/TranscoderWorkerWrapper.ts","../src/TranscoderWorker.ts","../src/loader/BasisParser.ts","../src/loader/detectBasis.ts","../src/loader/loadBasis.ts"],"sourcesContent":["import { INTERNAL_FORMATS } from '@pixi/compressed-textures';\nimport { TYPES } from '@pixi/core';\n\n/**\n * The transcoding formats provided by basis_universal.\n *\n * NOTE: Not all of these formats are supported on WebGL!\n * @ignore\n */\n/* eslint-disable camelcase, @typescript-eslint/indent */\nexport enum BASIS_FORMATS\n{\n    cTFETC1 = 0,\n    cTFETC2 = 1,\n    cTFBC1 = 2,\n    cTFBC3 = 3,\n    cTFBC4 = 4,\n    cTFBC5 = 5,\n    cTFBC7 = 6,\n    cTFPVRTC1_4_RGB = 8,\n    cTFPVRTC1_4_RGBA = 9,\n    cTFASTC_4x4 = 10,\n    cTFATC_RGB = 11,\n    cTFATC_RGBA_INTERPOLATED_ALPHA = 12,\n    cTFRGBA32 = 13,\n    cTFRGB565 = 14,\n    cTFBGR565 = 15,\n    cTFRGBA4444 = 16,\n}\n/* eslint-enable camelcase, @typescript-eslint/indent */\n\n/**\n * Maps {@link BASIS_FORMATS} to {@link PIXI.INTERNAL_FORMATS}\n * @ignore\n */\nexport const BASIS_FORMAT_TO_INTERNAL_FORMAT: { [id: number]: INTERNAL_FORMATS } = {\n    [BASIS_FORMATS.cTFETC1]: INTERNAL_FORMATS.COMPRESSED_RGB_ETC1_WEBGL,\n    [BASIS_FORMATS.cTFBC1]: INTERNAL_FORMATS.COMPRESSED_RGB_S3TC_DXT1_EXT,\n    [BASIS_FORMATS.cTFBC3]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,\n    [BASIS_FORMATS.cTFPVRTC1_4_RGB]: INTERNAL_FORMATS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG,\n    [BASIS_FORMATS.cTFPVRTC1_4_RGBA]: INTERNAL_FORMATS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,\n    [BASIS_FORMATS.cTFATC_RGB]: INTERNAL_FORMATS.COMPRESSED_RGB_ATC_WEBGL,\n    [BASIS_FORMATS.cTFASTC_4x4]: INTERNAL_FORMATS.COMPRESSED_RGBA_ASTC_4x4_KHR,\n    [BASIS_FORMATS.cTFBC7]: INTERNAL_FORMATS.COMPRESSED_RGBA_BPTC_UNORM_EXT,\n};\n\n/**\n * Maps {@link BASIS_FORMATS} to {@link PIXI.TYPES}. These formats are a fallback when the basis file cannot be transcoded\n * to a valid compressed texture format.\n *\n * NOTE: {@link BASIS_FORMATS.cTFBGR565} is not supported, while {@link BASIS_FORMATS.cTFRGBA4444} is not implemented by\n *  [at]pixi/basis.\n * @ignore\n */\nexport const BASIS_FORMAT_TO_TYPE: { [id: number]: TYPES } = {\n    [BASIS_FORMATS.cTFRGBA32]: TYPES.UNSIGNED_BYTE,\n    [BASIS_FORMATS.cTFRGB565]: TYPES.UNSIGNED_SHORT_5_6_5,\n    [BASIS_FORMATS.cTFRGBA4444]: TYPES.UNSIGNED_SHORT_4_4_4_4,\n};\n\n/**\n * Maps {@link PIXI.INTERNAL_FORMATS} to {@link BASIS_FORMATS}\n * @ignore\n */\nexport const INTERNAL_FORMAT_TO_BASIS_FORMAT: { [id: number]: number }\n    = (Object.keys(BASIS_FORMAT_TO_INTERNAL_FORMAT) as string[])\n        .map((key: string) => Number(key))\n        .reduce((reverseMap: any, basisFormat: any) =>\n        {\n            reverseMap[(BASIS_FORMAT_TO_INTERNAL_FORMAT as any)[basisFormat]] = basisFormat;\n\n            return reverseMap;\n        }, {});\n\n/**\n * Enumerates the basis formats with alpha components\n * @ignore\n */\nexport const BASIS_FORMATS_ALPHA: { [id: number]: boolean } = {\n    [BASIS_FORMATS.cTFBC3]: true,\n    [BASIS_FORMATS.cTFPVRTC1_4_RGBA]: true,\n    [BASIS_FORMATS.cTFASTC_4x4]: true,\n    [BASIS_FORMATS.cTFBC7]: true,\n};\n\n/**\n * Binding to C++ {@code BasisFile} wrapper class.\n * @see https://github.com/BinomialLLC/basis_universal/blob/master/webgl/transcoder/basis_wrappers.cpp\n * @private\n */\nexport declare class BasisFile\n{\n    constructor(buffer: Uint8Array);\n    getNumImages(): number;\n    getNumLevels(imageId: number): number;\n    getImageWidth(imageId: number, level: number): number;\n    getImageHeight(imageId: number, level: number): number;\n    getHasAlpha(): boolean;\n    startTranscoding(): boolean;\n    getImageTranscodedSizeInBytes(\n        imageId: number,\n        level: number,\n        basisFormat: number): number;\n    transcodeImage(dstBuff: Uint8Array,\n        imageId: number,\n        level: number,\n        basisFormat: BASIS_FORMATS,\n        pvrtcWrapAddressing: boolean,\n        getAlphaForOpaqueFormats: boolean): number;\n    close(): void;\n    delete(): void;\n}\n\n// Missing typings? - https://github.com/microsoft/TypeScript/issues/39655\n/**\n * Compressed texture extensions relevant to the formats into which Basis can decompress into.\n * @ignore\n */\n/* eslint-disable camelcase */\nexport type BasisTextureExtensions = {\n    s3tc?: WEBGL_compressed_texture_s3tc,\n    s3tc_sRGB: WEBGL_compressed_texture_s3tc_srgb,\n    etc: any,\n    etc1: any,\n    pvrtc: any,\n    atc: any,\n    astc: WEBGL_compressed_texture_astc,\n    bptc: any\n};\n/* eslint-enable camelcase */\n\n/** API provided by basis_universal WebGL library. */\nexport type BasisBinding = {\n    BasisFile: typeof BasisFile,\n    initializeBasis: () => void\n};\n\n/**\n * Binding to basis_universal WebGL library.\n * @see https://github.com/BinomialLLC/basis_universal/blob/master/webgl/transcoder/build/basis_transcoder.js\n * @ignore\n */\nexport type BASIS = (opts?: { wasmBinary: ArrayBuffer }) => Promise<BasisBinding>;\n","import type { BASIS, BASIS_FORMATS, BasisBinding } from './Basis';\n\n/**\n * Initialization message sent by the main thread.\n * @ignore\n */\nexport interface IInitializeTranscoderMessage\n{\n    wasmSource: ArrayBuffer;\n    type: 'init';\n}\n\n/**\n * Request parameters for transcoding basis files. It only supports transcoding all of the basis file at once.\n * @ignore\n */\nexport interface ITranscodeMessage\n{\n    requestID?: number;\n    rgbFormat: number;\n    rgbaFormat?: number;\n    basisData?: Uint8Array;\n    type: 'transcode';\n}\n\n/** @ignore */\nexport interface ITranscodedImage\n{\n    imageID: number;\n    levelArray: Array<{\n        levelID: number,\n        levelWidth: number,\n        levelHeight: number,\n        levelBuffer: Uint8Array\n    }>;\n    width: number;\n    height: number;\n}\n\n/**\n * Response format for {@link PIXI.TranscoderWorker}.\n * @ignore\n */\nexport interface ITranscodeResponse\n{\n    type: 'init' | 'transcode';\n    requestID?: number;\n    success: boolean;\n    basisFormat?: BASIS_FORMATS;\n    imageArray?: Array<{\n        imageID: number,\n        levelArray: Array<{\n            levelID: number,\n            levelWidth: number,\n            levelHeight: number,\n            levelBuffer: Uint8Array\n        }>,\n        width: number,\n        height: number\n    }>;\n}\n\ndeclare global\n{\n    interface Window\n    {\n        BASIS: BASIS;\n    }\n}\n\n/**\n * This wraps the transcoder web-worker functionality; it can be converted into a string to get the source code. It expects\n * you to prepend the transcoder JavaScript code so that the `BASIS` namespace is available.\n *\n * The transcoder worker responds to two types of messages: \"init\" and \"transcode\". You must always send the first \"init\"\n * {@link IInitializeTranscoderMessage} message with the WebAssembly binary; if the transcoder is successfully initialized,\n * the web-worker will respond by sending another {@link ITranscodeResponse} message with `success: true`.\n * @ignore\n */\nexport function TranscoderWorkerWrapper(): void\n{\n    let basisBinding: BasisBinding;\n\n    const messageHandlers = {\n        init: (message: IInitializeTranscoderMessage): ITranscodeResponse =>\n        {\n            if (!self.BASIS)\n            {\n                console.warn('jsSource was not prepended?');\n\n                return {\n                    type: 'init',\n                    success: false\n                };\n            }\n\n            self.BASIS({ wasmBinary: message.wasmSource }).then((basisLibrary) =>\n            {\n                basisLibrary.initializeBasis();\n                basisBinding = basisLibrary;\n\n                (self as any).postMessage({\n                    type: 'init',\n                    success: true\n                });\n            });\n\n            return null;\n        },\n        transcode(message: ITranscodeMessage): ITranscodeResponse\n        {\n            const basisData = message.basisData;\n            const BASIS = basisBinding;\n\n            const data = basisData;\n            const basisFile = new BASIS.BasisFile(data);\n            const imageCount = basisFile.getNumImages();\n            const hasAlpha = basisFile.getHasAlpha();\n\n            const basisFormat = hasAlpha\n                ? message.rgbaFormat\n                : message.rgbFormat;\n            const basisFallbackFormat = 14;// BASIS_FORMATS.cTFRGB565 (cannot import values into web-worker!)\n            const imageArray = new Array(imageCount);\n\n            let fallbackMode = false;\n\n            if (!basisFile.startTranscoding())\n            {\n                basisFile.close();\n                basisFile.delete();\n\n                return {\n                    type: 'transcode',\n                    requestID: message.requestID,\n                    success: false,\n                    imageArray: null\n                };\n            }\n\n            for (let i = 0; i < imageCount; i++)\n            {\n                const levels = basisFile.getNumLevels(i);\n                const imageResource: ITranscodedImage = {\n                    imageID: i,\n                    levelArray: new Array<{\n                        levelID: number,\n                        levelWidth: number,\n                        levelHeight: number,\n                        levelBuffer: Uint8Array\n                    }>(),\n                    width: null,\n                    height: null\n                };\n\n                for (let j = 0; j < levels; j++)\n                {\n                    const format = !fallbackMode ? basisFormat : basisFallbackFormat;\n\n                    const width = basisFile.getImageWidth(i, j);\n                    const height = basisFile.getImageHeight(i, j);\n                    const byteSize = basisFile.getImageTranscodedSizeInBytes(i, j, format);\n\n                    const alignedWidth = (width + 3) & ~3;\n                    const alignedHeight = (height + 3) & ~3;\n\n                    // Level 0 is texture's actual width, height\n                    if (j === 0)\n                    {\n                        imageResource.width = alignedWidth;\n                        imageResource.height = alignedHeight;\n                    }\n\n                    const imageBuffer = new Uint8Array(byteSize);\n\n                    if (!basisFile.transcodeImage(imageBuffer, i, j, format, false, false))\n                    {\n                        if (fallbackMode)\n                        {\n                            // We failed in fallback mode as well!\n                            console.error(`Basis failed to transcode image ${i}, level ${j}!`);\n\n                            return { type: 'transcode', requestID: message.requestID, success: false };\n                        }\n\n                        /* eslint-disable-next-line max-len */\n                        console.warn(`Basis failed to transcode image ${i}, level ${j}! Retrying to an uncompressed texture format!`);\n                        i = -1;\n                        fallbackMode = true;\n\n                        break;\n                    }\n\n                    imageResource.levelArray.push({\n                        levelID: j,\n                        levelWidth: width,\n                        levelHeight: height,\n                        levelBuffer: imageBuffer\n                    });\n                }\n\n                imageArray[i] = imageResource;\n            }\n\n            basisFile.close();\n            basisFile.delete();\n\n            return {\n                type: 'transcode',\n                requestID: message.requestID,\n                success: true,\n                basisFormat: !fallbackMode ? basisFormat : basisFallbackFormat,\n                imageArray\n            };\n        }\n    };\n\n    self.onmessage = (e: { data: Partial<IInitializeTranscoderMessage | ITranscodeMessage> }): void =>\n    {\n        const msg = e.data;\n        const response = messageHandlers[msg.type](msg as any);\n\n        if (response)\n        {\n            (self as any).postMessage(response);\n        }\n    };\n}\n","import { TranscoderWorkerWrapper } from './TranscoderWorkerWrapper';\n\nimport type { BASIS_FORMATS } from './Basis';\nimport type { ITranscodeResponse } from './TranscoderWorkerWrapper';\n\n/**\n * Worker class for transcoding *.basis files in background threads.\n *\n * To enable asynchronous transcoding, you need to provide the URL to the basis_universal transcoding\n * library.\n * @memberof PIXI.BasisParser\n */\nexport class TranscoderWorker\n{\n    // IMPLEMENTATION NOTE: TranscoderWorker tracks transcoding requests with a requestID; the worker can be issued\n    // multiple requests (once it is initialized) and the response contains the requestID of the triggering request. Based on\n    // the response, the transcodeAsync promise is fulfilled or rejected.\n\n    // TODO: Publish our own @pixi/basis package & set default URL to jsdelivr/cdnjs\n    /** URL for the script containing the basis_universal library. */\n    static bindingURL: string;\n    static jsSource: string;\n    static wasmSource: ArrayBuffer;\n\n    private static _onTranscoderInitializedResolve: () => void;\n\n    /** a promise that when reslved means the transcoder is ready to be used */\n    public static onTranscoderInitialized = new Promise<void>((resolve) =>\n    {\n        TranscoderWorker._onTranscoderInitializedResolve = resolve;\n    });\n\n    isInit: boolean;\n    load: number;\n    requests: { [id: number]: {\n        resolve: (data: ITranscodeResponse) => void,\n        reject: () => void\n    } } = {};\n\n    private static _workerURL: string;\n    private static _tempID = 0;\n\n    /** Generated URL for the transcoder worker script. */\n    static get workerURL(): string\n    {\n        if (!TranscoderWorker._workerURL)\n        {\n            let workerSource = TranscoderWorkerWrapper.toString();\n\n            const beginIndex = workerSource.indexOf('{');\n            const endIndex = workerSource.lastIndexOf('}');\n\n            workerSource = workerSource.slice(beginIndex + 1, endIndex);\n\n            if (TranscoderWorker.jsSource)\n            {\n                workerSource = `${TranscoderWorker.jsSource}\\n${workerSource}`;\n            }\n\n            TranscoderWorker._workerURL = URL.createObjectURL(new Blob([workerSource]));\n        }\n\n        return TranscoderWorker._workerURL;\n    }\n\n    protected worker: Worker;\n    protected initPromise: Promise<void>;\n    protected onInit: () => void;\n\n    constructor()\n    {\n        this.isInit = false;\n        this.load = 0;\n        this.initPromise = new Promise((resolve) => { this.onInit = resolve; });\n\n        if (!TranscoderWorker.wasmSource)\n        {\n            console.warn('resources.BasisResource.TranscoderWorker has not been given the transcoder WASM binary!');\n        }\n\n        this.worker = new Worker(TranscoderWorker.workerURL);\n        this.worker.onmessage = this.onMessage;\n        this.worker.postMessage({\n            type: 'init',\n            jsSource: TranscoderWorker.jsSource,\n            wasmSource: TranscoderWorker.wasmSource\n        });\n    }\n\n    /** @returns a promise that is resolved when the web-worker is initialized */\n    initAsync(): Promise<void>\n    {\n        return this.initPromise;\n    }\n\n    /**\n     * Creates a promise that will resolve when the transcoding of a *.basis file is complete.\n     * @param basisData - *.basis file contents\n     * @param rgbaFormat - transcoding format for RGBA files\n     * @param rgbFormat - transcoding format for RGB files\n     * @returns a promise that is resolved with the transcoding response of the web-worker\n     */\n    async transcodeAsync(\n        basisData: Uint8Array,\n        rgbaFormat: BASIS_FORMATS,\n        rgbFormat: BASIS_FORMATS\n    ): Promise<ITranscodeResponse>\n    {\n        ++this.load;\n\n        const requestID = TranscoderWorker._tempID++;\n        const requestPromise = new Promise((resolve: (data: ITranscodeResponse) => void, reject: () => void) =>\n        {\n            this.requests[requestID] = {\n                resolve,\n                reject\n            };\n        });\n\n        this.worker.postMessage({\n            requestID,\n            basisData,\n            rgbaFormat,\n            rgbFormat,\n            type: 'transcode'\n        });\n\n        return requestPromise;\n    }\n\n    /**\n     * Handles responses from the web-worker\n     * @param e - a message event containing the transcoded response\n     */\n    protected onMessage = (e: MessageEvent): void =>\n    {\n        const data = e.data as ITranscodeResponse;\n\n        if (data.type === 'init')\n        {\n            if (!data.success)\n            {\n                throw new Error('BasisResource.TranscoderWorker failed to initialize.');\n            }\n\n            this.isInit = true;\n            this.onInit();\n        }\n        else if (data.type === 'transcode')\n        {\n            --this.load;\n\n            const requestID = data.requestID;\n\n            if (data.success)\n            {\n                this.requests[requestID].resolve(data);\n            }\n            else\n            {\n                this.requests[requestID].reject();\n            }\n\n            delete this.requests[requestID];\n        }\n    };\n\n    /**\n     * Loads the transcoder source code\n     * @param jsURL - URL to the javascript basis transcoder\n     * @param wasmURL - URL to the wasm basis transcoder\n     * @returns A promise that resolves when both the js and wasm transcoders have been loaded.\n     */\n    static loadTranscoder(jsURL: string, wasmURL: string): Promise<[void, void]>\n    {\n        const jsPromise = fetch(jsURL)\n            .then((res: Response) => res.text())\n            .then((text: string) => { TranscoderWorker.jsSource = text; });\n        const wasmPromise = fetch(wasmURL)\n            .then((res: Response) => res.arrayBuffer())\n            .then((arrayBuffer: ArrayBuffer) => { TranscoderWorker.wasmSource = arrayBuffer; });\n\n        return Promise.all([jsPromise, wasmPromise]).then((data) =>\n\n        {\n            this._onTranscoderInitializedResolve();\n\n            return data;\n        });\n    }\n\n    /**\n     * Set the transcoder source code directly\n     * @param jsSource - source for the javascript basis transcoder\n     * @param wasmSource - source for the wasm basis transcoder\n     */\n    static setTranscoder(jsSource: string, wasmSource: ArrayBuffer): void\n    {\n        TranscoderWorker.jsSource = jsSource;\n        TranscoderWorker.wasmSource = wasmSource;\n    }\n}\n","import { CompressedTextureResource } from '@pixi/compressed-textures';\nimport { BufferResource, settings, TYPES } from '@pixi/core';\nimport {\n    BASIS_FORMAT_TO_INTERNAL_FORMAT,\n    BASIS_FORMATS,\n    BASIS_FORMATS_ALPHA,\n    INTERNAL_FORMAT_TO_BASIS_FORMAT,\n} from '../Basis';\nimport { TranscoderWorker } from '../TranscoderWorker';\n\nimport type { CompressedLevelBuffer, INTERNAL_FORMATS } from '@pixi/compressed-textures';\nimport type { BasisBinding, BasisTextureExtensions } from '../Basis';\n\nexport type TranscodedResourcesArray = (Array<CompressedTextureResource> | Array<BufferResource>) & {\n    basisFormat: BASIS_FORMATS\n};\n\n/**\n * Loader plugin for handling BASIS supercompressed texture files.\n *\n * To use this loader, you must bind the basis_universal WebAssembly transcoder. There are two ways of\n * doing this:\n *\n * 1. Adding a &lt;script&gt; tag to your HTML page to the transcoder bundle in this package, and serving\n * the WASM binary from the same location.\n *\n * ```html\n * <!-- Copy ./node_modules/@pixi/basis/assets/basis_.wasm into your assets directory\n *     as well, so it is served from the same folder as the JavaScript! -->\n * <script src=\"./node_modules/@pixi/basis/assets/basis_transcoder.js\"></script>\n * ```\n *\n * NOTE: `basis_transcoder.js` expects the WebAssembly binary to be named `basis_transcoder.wasm`.\n * NOTE-2: This method supports transcoding on the main-thread. Only use this if you have 1 or 2 *.basis\n * files.\n *\n * 2. Loading the transcoder source from a URL.\n *\n * ```js\n * // Use this if you to use the default CDN url for @pixi/basis\n * BasisParser.loadTranscoder();\n *\n * // Use this if you want to serve the transcoder on your own\n * BasisParser.loadTranscoder('./basis_transcoder.js', './basis_transcoder.wasm');\n * ```\n *\n * NOTE: This can only be used with web-workers.\n * @class\n * @memberof PIXI\n * @implements {PIXI.ILoaderPlugin}\n */\nexport class BasisParser\n{\n    public static basisBinding: BasisBinding;\n    private static defaultRGBFormat: { basisFormat: BASIS_FORMATS, textureFormat: INTERNAL_FORMATS | TYPES };\n    private static defaultRGBAFormat: { basisFormat: BASIS_FORMATS, textureFormat: INTERNAL_FORMATS | TYPES };\n    private static fallbackMode = false;\n    private static workerPool: TranscoderWorker[] = [];\n\n    /**\n     * Runs transcoding and populates imageArray. It will run the transcoding in a web worker\n     * if they are available.\n     * @private\n     */\n    public static async transcode(arrayBuffer: ArrayBuffer): Promise<TranscodedResourcesArray>\n    {\n        let resources: TranscodedResourcesArray;\n\n        if (typeof Worker !== 'undefined' && BasisParser.TranscoderWorker.wasmSource)\n        {\n            resources = await BasisParser.transcodeAsync(arrayBuffer);\n        }\n        else\n        {\n            resources = BasisParser.transcodeSync(arrayBuffer);\n        }\n\n        return resources;\n    }\n\n    /**\n     * Finds a suitable worker for transcoding and sends a transcoding request\n     * @private\n     * @async\n     */\n    public static async transcodeAsync(arrayBuffer: ArrayBuffer): Promise<TranscodedResourcesArray>\n    {\n        if (!BasisParser.defaultRGBAFormat && !BasisParser.defaultRGBFormat)\n        {\n            BasisParser.autoDetectFormats();\n        }\n\n        const workerPool = BasisParser.workerPool;\n\n        let leastLoad = 0x10000000;\n        let worker = null;\n\n        for (let i = 0, j = workerPool.length; i < j; i++)\n        {\n            if (workerPool[i].load < leastLoad)\n            {\n                worker = workerPool[i];\n                leastLoad = worker.load;\n            }\n        }\n\n        if (!worker)\n        {\n            /* eslint-disable-next-line no-use-before-define */\n            worker = new TranscoderWorker();\n\n            workerPool.push(worker);\n        }\n\n        // Wait until worker is ready\n        await worker.initAsync();\n\n        const response = await worker.transcodeAsync(\n            new Uint8Array(arrayBuffer),\n            BasisParser.defaultRGBAFormat.basisFormat,\n            BasisParser.defaultRGBFormat.basisFormat,\n        );\n\n        const basisFormat = response.basisFormat;\n        const imageArray = response.imageArray;\n\n        // whether it is an uncompressed format\n        const fallbackMode = basisFormat > 12;\n        let imageResources: TranscodedResourcesArray;\n\n        if (!fallbackMode)\n        {\n            const format = BASIS_FORMAT_TO_INTERNAL_FORMAT[response.basisFormat];\n\n            // HINT: this.imageArray is CompressedTextureResource[]\n            imageResources = new Array<CompressedTextureResource>(imageArray.length) as TranscodedResourcesArray;\n\n            for (let i = 0, j = imageArray.length; i < j; i++)\n            {\n                imageResources[i] = new CompressedTextureResource(null, {\n                    format,\n                    width: imageArray[i].width,\n                    height: imageArray[i].height,\n                    levelBuffers: imageArray[i].levelArray,\n                    levels: imageArray[i].levelArray.length,\n                });\n            }\n        }\n        else\n        {\n            // TODO: BufferResource does not support manual mipmapping.\n            imageResources = imageArray.map((image) => new BufferResource(\n                new Uint16Array(image.levelArray[0].levelBuffer.buffer), {\n                    width: image.width,\n                    height: image.height,\n                }),\n            ) as TranscodedResourcesArray;\n        }\n\n        imageResources.basisFormat = basisFormat;\n\n        return imageResources;\n    }\n\n    /**\n     * Runs transcoding on the main thread.\n     * @private\n     */\n    public static transcodeSync(arrayBuffer: ArrayBuffer): TranscodedResourcesArray\n    {\n        if (!BasisParser.defaultRGBAFormat && !BasisParser.defaultRGBFormat)\n        {\n            BasisParser.autoDetectFormats();\n        }\n\n        const BASIS = BasisParser.basisBinding;\n\n        const data = new Uint8Array(arrayBuffer);\n        const basisFile = new BASIS.BasisFile(data);\n        const imageCount = basisFile.getNumImages();\n        const hasAlpha = basisFile.getHasAlpha();\n\n        const basisFormat = hasAlpha\n            ? BasisParser.defaultRGBAFormat.basisFormat\n            : BasisParser.defaultRGBFormat.basisFormat;\n        const basisFallbackFormat = BASIS_FORMATS.cTFRGB565;\n        const imageResources = new Array<CompressedTextureResource | BufferResource>(imageCount);\n\n        let fallbackMode = BasisParser.fallbackMode;\n\n        if (!basisFile.startTranscoding())\n        {\n            if (process.env.DEBUG)\n            {\n                console.error(`Basis failed to start transcoding!`);\n            }\n\n            basisFile.close();\n            basisFile.delete();\n\n            return null;\n        }\n\n        for (let i = 0; i < imageCount; i++)\n        {\n            // Don't transcode all mipmap levels in fallback mode!\n            const levels = !fallbackMode ? basisFile.getNumLevels(i) : 1;\n            const width = basisFile.getImageWidth(i, 0);\n            const height = basisFile.getImageHeight(i, 0);\n            const alignedWidth = (width + 3) & ~3;\n            const alignedHeight = (height + 3) & ~3;\n\n            const imageLevels = new Array<CompressedLevelBuffer>(levels);\n\n            // Transcode mipmap levels into \"imageLevels\"\n            for (let j = 0; j < levels; j++)\n            {\n                const levelWidth = basisFile.getImageWidth(i, j);\n                const levelHeight = basisFile.getImageHeight(i, j);\n                const byteSize = basisFile.getImageTranscodedSizeInBytes(\n                    i, 0, !fallbackMode ? basisFormat : basisFallbackFormat);\n\n                imageLevels[j] = {\n                    levelID: j,\n                    levelBuffer: new Uint8Array(byteSize),\n                    levelWidth,\n                    levelHeight,\n                };\n\n                if (!basisFile.transcodeImage(\n                    imageLevels[j].levelBuffer, i, 0, !fallbackMode ? basisFormat : basisFallbackFormat, false, false))\n                {\n                    if (fallbackMode)\n                    {\n                        if (process.env.DEBUG)\n                        {\n                            console.error(`Basis failed to transcode image ${i}, level ${0}!`);\n                        }\n                        break;\n                    }\n                    else\n                    {\n                        // Try transcoding to an uncompressed format before giving up!\n                        // NOTE: We must start all over again as all Resources must be in compressed OR uncompressed.\n                        i = -1;\n                        fallbackMode = true;\n\n                        if (process.env.DEBUG)\n                        {\n                        /* eslint-disable-next-line max-len */\n                            console.warn(`Basis failed to transcode image ${i}, level ${0} to a compressed texture format. Retrying to an uncompressed fallback format!`);\n                        }\n                        continue;\n                    }\n                }\n            }\n\n            let imageResource;\n\n            if (!fallbackMode)\n            {\n                imageResource = new CompressedTextureResource(null, {\n                    format: BASIS_FORMAT_TO_INTERNAL_FORMAT[basisFormat],\n                    width: alignedWidth,\n                    height: alignedHeight,\n                    levelBuffers: imageLevels,\n                    levels,\n                });\n            }\n            else\n            {\n                // TODO: BufferResource doesn't support manual mipmap levels\n                imageResource = new BufferResource(\n                    new Uint16Array(imageLevels[0].levelBuffer.buffer), { width, height });\n            }\n\n            imageResources[i] = imageResource;\n        }\n\n        basisFile.close();\n        basisFile.delete();\n\n        const transcodedResources = imageResources as TranscodedResourcesArray;\n\n        transcodedResources.basisFormat = !fallbackMode ? basisFormat : basisFallbackFormat;\n\n        return transcodedResources;\n    }\n\n    /**\n     * Detects the available compressed texture formats on the device.\n     * @param extensions - extensions provided by a WebGL context\n     * @ignore\n     */\n    static autoDetectFormats(extensions?: Partial<BasisTextureExtensions>): void\n    {\n        // Auto-detect WebGL compressed-texture extensions\n        if (!extensions)\n        {\n            const canvas = settings.ADAPTER.createCanvas();\n            const gl = canvas.getContext('webgl');\n\n            if (!gl)\n            {\n                console.error('WebGL not available for BASIS transcoding. Silently failing.');\n\n                return;\n            }\n\n            extensions = {\n                bptc: gl.getExtension('EXT_texture_compression_bptc'),\n                astc: gl.getExtension('WEBGL_compressed_texture_astc'),\n                etc: gl.getExtension('WEBGL_compressed_texture_etc'),\n                s3tc: gl.getExtension('WEBGL_compressed_texture_s3tc'),\n                s3tc_sRGB: gl.getExtension('WEBGL_compressed_texture_s3tc_srgb'), /* eslint-disable-line camelcase */\n                pvrtc: gl.getExtension('WEBGL_compressed_texture_pvrtc')\n                    || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc'),\n                etc1: gl.getExtension('WEBGL_compressed_texture_etc1'),\n                atc: gl.getExtension('WEBGL_compressed_texture_atc'),\n            };\n        }\n\n        // Discover the available texture formats\n        const supportedFormats: { [id: string]: INTERNAL_FORMATS } = {};\n\n        for (const key in extensions)\n        {\n            const extension = (extensions as any)[key];\n\n            if (!extension)\n            {\n                continue;\n            }\n\n            Object.assign(supportedFormats, Object.getPrototypeOf(extension));\n        }\n\n        // Set the default alpha/non-alpha output formats for basisu transcoding\n        for (let i = 0; i < 2; i++)\n        {\n            const detectWithAlpha = !!i;\n            let internalFormat: number;\n            let basisFormat: number;\n\n            for (const id in supportedFormats)\n            {\n                internalFormat = supportedFormats[id];\n                basisFormat = INTERNAL_FORMAT_TO_BASIS_FORMAT[internalFormat];\n\n                if (basisFormat !== undefined)\n                {\n                    if ((detectWithAlpha && BASIS_FORMATS_ALPHA[basisFormat])\n                        || (!detectWithAlpha && !BASIS_FORMATS_ALPHA[basisFormat]))\n                    {\n                        break;\n                    }\n                }\n            }\n\n            if (internalFormat)\n            {\n                BasisParser[detectWithAlpha ? 'defaultRGBAFormat' : 'defaultRGBFormat'] = {\n                    textureFormat: internalFormat,\n                    basisFormat,\n                };\n            }\n            else\n            {\n                BasisParser[detectWithAlpha ? 'defaultRGBAFormat' : 'defaultRGBFormat'] = {\n                    textureFormat: TYPES.UNSIGNED_SHORT_5_6_5,\n                    basisFormat: BASIS_FORMATS.cTFRGB565,\n                };\n\n                BasisParser.fallbackMode = true;\n            }\n        }\n    }\n\n    /**\n     * Binds the basis_universal transcoder to decompress *.basis files. You must initialize the transcoder library yourself.\n     * @example\n     * import { BasisParser } from '@pixi/basis';\n     *\n     * // BASIS() returns a Promise-like object\n     * globalThis.BASIS().then((basisLibrary) =>\n     * {\n     *     // Initialize basis-library; otherwise, transcoded results maybe corrupt!\n     *     basisLibrary.initializeBasis();\n     *\n     *     // Bind BasisParser to the transcoder\n     *     BasisParser.bindTranscoder(basisLibrary);\n     * });\n     * @param basisLibrary - the initialized transcoder library\n     * @private\n     */\n    static bindTranscoder(basisLibrary: BasisBinding): void\n    {\n        BasisParser.basisBinding = basisLibrary;\n    }\n\n    /**\n     * Loads the transcoder source code for use in {@link PIXI.BasisParser.TranscoderWorker}.\n     * @private\n     * @param jsURL - URL to the javascript basis transcoder\n     * @param wasmURL - URL to the wasm basis transcoder\n     */\n    static loadTranscoder(jsURL: string, wasmURL: string): Promise<[void, void]>\n    {\n        return BasisParser.TranscoderWorker.loadTranscoder(jsURL, wasmURL);\n    }\n\n    /**\n     * Set the transcoder source code directly\n     * @private\n     * @param jsSource - source for the javascript basis transcoder\n     * @param wasmSource - source for the wasm basis transcoder\n     */\n    static setTranscoder(jsSource: string, wasmSource: ArrayBuffer): void\n    {\n        BasisParser.TranscoderWorker.setTranscoder(jsSource, wasmSource);\n    }\n\n    static TranscoderWorker: typeof TranscoderWorker = TranscoderWorker;\n\n    static get TRANSCODER_WORKER_POOL_LIMIT(): number\n    {\n        return this.workerPool.length || 1;\n    }\n\n    static set TRANSCODER_WORKER_POOL_LIMIT(limit: number)\n    {\n        // TODO: Destroy workers?\n        for (let i = this.workerPool.length; i < limit; i++)\n        {\n            this.workerPool[i] = new TranscoderWorker();\n            this.workerPool[i].initAsync();\n        }\n    }\n}\n","import { extensions, ExtensionType } from '@pixi/core';\nimport { BasisParser } from './BasisParser';\n\nimport type { FormatDetectionParser } from '@pixi/assets';\n\nexport const detectBasis = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 3,\n    },\n    test: async (): Promise<boolean> => !!(BasisParser.basisBinding && BasisParser.TranscoderWorker.wasmSource),\n    add: async (formats) => [...formats, 'basis'],\n    remove: async (formats) => formats.filter((f) => f !== 'basis'),\n} as FormatDetectionParser;\n\nextensions.add(detectBasis);\n","import { checkExtension, createTexture, LoaderParserPriority } from '@pixi/assets';\nimport { CompressedTextureResource } from '@pixi/compressed-textures';\nimport { ALPHA_MODES, BaseTexture, extensions, ExtensionType, FORMATS, MIPMAP_MODES, settings } from '@pixi/core';\nimport { BASIS_FORMAT_TO_TYPE, BASIS_FORMATS } from '../Basis';\nimport { TranscoderWorker } from '../TranscoderWorker';\nimport { BasisParser } from './BasisParser';\n\nimport type { Loader, LoaderParser, ResolvedAsset } from '@pixi/assets';\nimport type { IBaseTextureOptions, Texture, TYPES } from '@pixi/core';\n\n/** Load BASIS textures! */\nexport const loadBasis = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.High,\n    },\n\n    name: 'loadBasis',\n\n    test(url: string): boolean\n    {\n        return checkExtension(url, '.basis');\n    },\n\n    async load(url: string, asset: ResolvedAsset, loader: Loader): Promise<Texture | Texture[]>\n    {\n        await TranscoderWorker.onTranscoderInitialized;\n\n        // get an array buffer...\n        const response = await settings.ADAPTER.fetch(url);\n\n        const arrayBuffer = await response.arrayBuffer();\n\n        const resources = await BasisParser.transcode(arrayBuffer);\n\n        const type: TYPES = BASIS_FORMAT_TO_TYPE[resources.basisFormat];\n        const format: FORMATS = resources.basisFormat !== BASIS_FORMATS.cTFRGBA32 ? FORMATS.RGB : FORMATS.RGBA;\n\n        const textures = resources.map((resource) =>\n        {\n            const base = new BaseTexture(resource, {\n                mipmap: resource instanceof CompressedTextureResource && resource.levels > 1\n                    ? MIPMAP_MODES.ON_MANUAL\n                    : MIPMAP_MODES.OFF,\n                alphaMode: ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,\n                type,\n                format,\n                ...asset.data,\n            });\n\n            return createTexture(base, loader, url);\n        });\n\n        return textures.length === 1 ? textures[0] : textures;\n    },\n\n    unload(texture): void\n    {\n        if (Array.isArray(texture))\n        {\n            texture.forEach((t) => t.destroy(true));\n        }\n        else\n        {\n            texture.destroy(true);\n        }\n    }\n\n} as LoaderParser<Texture | Texture[], IBaseTextureOptions>;\n\nextensions.add(loadBasis);\n"],"names":["BASIS_FORMATS","INTERNAL_FORMATS","TYPES","_TranscoderWorker","_BasisParser","BufferResource","CompressedTextureResource","settings","ExtensionType","extensions","LoaderParserPriority","checkExtension","FORMATS","BaseTexture","MIPMAP_MODES","ALPHA_MODES","createTexture"],"mappings":"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"}