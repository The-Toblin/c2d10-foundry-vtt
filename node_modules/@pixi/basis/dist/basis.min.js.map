{"version":3,"file":"basis.min.js","sources":["../src/Basis.ts","../src/TranscoderWorkerWrapper.ts","../src/TranscoderWorker.ts","../src/loader/BasisParser.ts","../src/loader/detectBasis.ts","../src/loader/loadBasis.ts"],"sourcesContent":["import { INTERNAL_FORMATS } from '@pixi/compressed-textures';\nimport { TYPES } from '@pixi/core';\n\n/**\n * The transcoding formats provided by basis_universal.\n *\n * NOTE: Not all of these formats are supported on WebGL!\n * @ignore\n */\n/* eslint-disable camelcase, @typescript-eslint/indent */\nexport enum BASIS_FORMATS\n{\n    cTFETC1 = 0,\n    cTFETC2 = 1,\n    cTFBC1 = 2,\n    cTFBC3 = 3,\n    cTFBC4 = 4,\n    cTFBC5 = 5,\n    cTFBC7 = 6,\n    cTFPVRTC1_4_RGB = 8,\n    cTFPVRTC1_4_RGBA = 9,\n    cTFASTC_4x4 = 10,\n    cTFATC_RGB = 11,\n    cTFATC_RGBA_INTERPOLATED_ALPHA = 12,\n    cTFRGBA32 = 13,\n    cTFRGB565 = 14,\n    cTFBGR565 = 15,\n    cTFRGBA4444 = 16,\n}\n/* eslint-enable camelcase, @typescript-eslint/indent */\n\n/**\n * Maps {@link BASIS_FORMATS} to {@link PIXI.INTERNAL_FORMATS}\n * @ignore\n */\nexport const BASIS_FORMAT_TO_INTERNAL_FORMAT: { [id: number]: INTERNAL_FORMATS } = {\n    [BASIS_FORMATS.cTFETC1]: INTERNAL_FORMATS.COMPRESSED_RGB_ETC1_WEBGL,\n    [BASIS_FORMATS.cTFBC1]: INTERNAL_FORMATS.COMPRESSED_RGB_S3TC_DXT1_EXT,\n    [BASIS_FORMATS.cTFBC3]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,\n    [BASIS_FORMATS.cTFPVRTC1_4_RGB]: INTERNAL_FORMATS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG,\n    [BASIS_FORMATS.cTFPVRTC1_4_RGBA]: INTERNAL_FORMATS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,\n    [BASIS_FORMATS.cTFATC_RGB]: INTERNAL_FORMATS.COMPRESSED_RGB_ATC_WEBGL,\n    [BASIS_FORMATS.cTFASTC_4x4]: INTERNAL_FORMATS.COMPRESSED_RGBA_ASTC_4x4_KHR,\n    [BASIS_FORMATS.cTFBC7]: INTERNAL_FORMATS.COMPRESSED_RGBA_BPTC_UNORM_EXT,\n};\n\n/**\n * Maps {@link BASIS_FORMATS} to {@link PIXI.TYPES}. These formats are a fallback when the basis file cannot be transcoded\n * to a valid compressed texture format.\n *\n * NOTE: {@link BASIS_FORMATS.cTFBGR565} is not supported, while {@link BASIS_FORMATS.cTFRGBA4444} is not implemented by\n *  [at]pixi/basis.\n * @ignore\n */\nexport const BASIS_FORMAT_TO_TYPE: { [id: number]: TYPES } = {\n    [BASIS_FORMATS.cTFRGBA32]: TYPES.UNSIGNED_BYTE,\n    [BASIS_FORMATS.cTFRGB565]: TYPES.UNSIGNED_SHORT_5_6_5,\n    [BASIS_FORMATS.cTFRGBA4444]: TYPES.UNSIGNED_SHORT_4_4_4_4,\n};\n\n/**\n * Maps {@link PIXI.INTERNAL_FORMATS} to {@link BASIS_FORMATS}\n * @ignore\n */\nexport const INTERNAL_FORMAT_TO_BASIS_FORMAT: { [id: number]: number }\n    = (Object.keys(BASIS_FORMAT_TO_INTERNAL_FORMAT) as string[])\n        .map((key: string) => Number(key))\n        .reduce((reverseMap: any, basisFormat: any) =>\n        {\n            reverseMap[(BASIS_FORMAT_TO_INTERNAL_FORMAT as any)[basisFormat]] = basisFormat;\n\n            return reverseMap;\n        }, {});\n\n/**\n * Enumerates the basis formats with alpha components\n * @ignore\n */\nexport const BASIS_FORMATS_ALPHA: { [id: number]: boolean } = {\n    [BASIS_FORMATS.cTFBC3]: true,\n    [BASIS_FORMATS.cTFPVRTC1_4_RGBA]: true,\n    [BASIS_FORMATS.cTFASTC_4x4]: true,\n    [BASIS_FORMATS.cTFBC7]: true,\n};\n\n/**\n * Binding to C++ {@code BasisFile} wrapper class.\n * @see https://github.com/BinomialLLC/basis_universal/blob/master/webgl/transcoder/basis_wrappers.cpp\n * @private\n */\nexport declare class BasisFile\n{\n    constructor(buffer: Uint8Array);\n    getNumImages(): number;\n    getNumLevels(imageId: number): number;\n    getImageWidth(imageId: number, level: number): number;\n    getImageHeight(imageId: number, level: number): number;\n    getHasAlpha(): boolean;\n    startTranscoding(): boolean;\n    getImageTranscodedSizeInBytes(\n        imageId: number,\n        level: number,\n        basisFormat: number): number;\n    transcodeImage(dstBuff: Uint8Array,\n        imageId: number,\n        level: number,\n        basisFormat: BASIS_FORMATS,\n        pvrtcWrapAddressing: boolean,\n        getAlphaForOpaqueFormats: boolean): number;\n    close(): void;\n    delete(): void;\n}\n\n// Missing typings? - https://github.com/microsoft/TypeScript/issues/39655\n/**\n * Compressed texture extensions relevant to the formats into which Basis can decompress into.\n * @ignore\n */\n/* eslint-disable camelcase */\nexport type BasisTextureExtensions = {\n    s3tc?: WEBGL_compressed_texture_s3tc,\n    s3tc_sRGB: WEBGL_compressed_texture_s3tc_srgb,\n    etc: any,\n    etc1: any,\n    pvrtc: any,\n    atc: any,\n    astc: WEBGL_compressed_texture_astc,\n    bptc: any\n};\n/* eslint-enable camelcase */\n\n/** API provided by basis_universal WebGL library. */\nexport type BasisBinding = {\n    BasisFile: typeof BasisFile,\n    initializeBasis: () => void\n};\n\n/**\n * Binding to basis_universal WebGL library.\n * @see https://github.com/BinomialLLC/basis_universal/blob/master/webgl/transcoder/build/basis_transcoder.js\n * @ignore\n */\nexport type BASIS = (opts?: { wasmBinary: ArrayBuffer }) => Promise<BasisBinding>;\n","import type { BASIS, BASIS_FORMATS, BasisBinding } from './Basis';\n\n/**\n * Initialization message sent by the main thread.\n * @ignore\n */\nexport interface IInitializeTranscoderMessage\n{\n    wasmSource: ArrayBuffer;\n    type: 'init';\n}\n\n/**\n * Request parameters for transcoding basis files. It only supports transcoding all of the basis file at once.\n * @ignore\n */\nexport interface ITranscodeMessage\n{\n    requestID?: number;\n    rgbFormat: number;\n    rgbaFormat?: number;\n    basisData?: Uint8Array;\n    type: 'transcode';\n}\n\n/** @ignore */\nexport interface ITranscodedImage\n{\n    imageID: number;\n    levelArray: Array<{\n        levelID: number,\n        levelWidth: number,\n        levelHeight: number,\n        levelBuffer: Uint8Array\n    }>;\n    width: number;\n    height: number;\n}\n\n/**\n * Response format for {@link PIXI.TranscoderWorker}.\n * @ignore\n */\nexport interface ITranscodeResponse\n{\n    type: 'init' | 'transcode';\n    requestID?: number;\n    success: boolean;\n    basisFormat?: BASIS_FORMATS;\n    imageArray?: Array<{\n        imageID: number,\n        levelArray: Array<{\n            levelID: number,\n            levelWidth: number,\n            levelHeight: number,\n            levelBuffer: Uint8Array\n        }>,\n        width: number,\n        height: number\n    }>;\n}\n\ndeclare global\n{\n    interface Window\n    {\n        BASIS: BASIS;\n    }\n}\n\n/**\n * This wraps the transcoder web-worker functionality; it can be converted into a string to get the source code. It expects\n * you to prepend the transcoder JavaScript code so that the `BASIS` namespace is available.\n *\n * The transcoder worker responds to two types of messages: \"init\" and \"transcode\". You must always send the first \"init\"\n * {@link IInitializeTranscoderMessage} message with the WebAssembly binary; if the transcoder is successfully initialized,\n * the web-worker will respond by sending another {@link ITranscodeResponse} message with `success: true`.\n * @ignore\n */\nexport function TranscoderWorkerWrapper(): void\n{\n    let basisBinding: BasisBinding;\n\n    const messageHandlers = {\n        init: (message: IInitializeTranscoderMessage): ITranscodeResponse =>\n        {\n            if (!self.BASIS)\n            {\n                console.warn('jsSource was not prepended?');\n\n                return {\n                    type: 'init',\n                    success: false\n                };\n            }\n\n            self.BASIS({ wasmBinary: message.wasmSource }).then((basisLibrary) =>\n            {\n                basisLibrary.initializeBasis();\n                basisBinding = basisLibrary;\n\n                (self as any).postMessage({\n                    type: 'init',\n                    success: true\n                });\n            });\n\n            return null;\n        },\n        transcode(message: ITranscodeMessage): ITranscodeResponse\n        {\n            const basisData = message.basisData;\n            const BASIS = basisBinding;\n\n            const data = basisData;\n            const basisFile = new BASIS.BasisFile(data);\n            const imageCount = basisFile.getNumImages();\n            const hasAlpha = basisFile.getHasAlpha();\n\n            const basisFormat = hasAlpha\n                ? message.rgbaFormat\n                : message.rgbFormat;\n            const basisFallbackFormat = 14;// BASIS_FORMATS.cTFRGB565 (cannot import values into web-worker!)\n            const imageArray = new Array(imageCount);\n\n            let fallbackMode = false;\n\n            if (!basisFile.startTranscoding())\n            {\n                basisFile.close();\n                basisFile.delete();\n\n                return {\n                    type: 'transcode',\n                    requestID: message.requestID,\n                    success: false,\n                    imageArray: null\n                };\n            }\n\n            for (let i = 0; i < imageCount; i++)\n            {\n                const levels = basisFile.getNumLevels(i);\n                const imageResource: ITranscodedImage = {\n                    imageID: i,\n                    levelArray: new Array<{\n                        levelID: number,\n                        levelWidth: number,\n                        levelHeight: number,\n                        levelBuffer: Uint8Array\n                    }>(),\n                    width: null,\n                    height: null\n                };\n\n                for (let j = 0; j < levels; j++)\n                {\n                    const format = !fallbackMode ? basisFormat : basisFallbackFormat;\n\n                    const width = basisFile.getImageWidth(i, j);\n                    const height = basisFile.getImageHeight(i, j);\n                    const byteSize = basisFile.getImageTranscodedSizeInBytes(i, j, format);\n\n                    const alignedWidth = (width + 3) & ~3;\n                    const alignedHeight = (height + 3) & ~3;\n\n                    // Level 0 is texture's actual width, height\n                    if (j === 0)\n                    {\n                        imageResource.width = alignedWidth;\n                        imageResource.height = alignedHeight;\n                    }\n\n                    const imageBuffer = new Uint8Array(byteSize);\n\n                    if (!basisFile.transcodeImage(imageBuffer, i, j, format, false, false))\n                    {\n                        if (fallbackMode)\n                        {\n                            // We failed in fallback mode as well!\n                            console.error(`Basis failed to transcode image ${i}, level ${j}!`);\n\n                            return { type: 'transcode', requestID: message.requestID, success: false };\n                        }\n\n                        /* eslint-disable-next-line max-len */\n                        console.warn(`Basis failed to transcode image ${i}, level ${j}! Retrying to an uncompressed texture format!`);\n                        i = -1;\n                        fallbackMode = true;\n\n                        break;\n                    }\n\n                    imageResource.levelArray.push({\n                        levelID: j,\n                        levelWidth: width,\n                        levelHeight: height,\n                        levelBuffer: imageBuffer\n                    });\n                }\n\n                imageArray[i] = imageResource;\n            }\n\n            basisFile.close();\n            basisFile.delete();\n\n            return {\n                type: 'transcode',\n                requestID: message.requestID,\n                success: true,\n                basisFormat: !fallbackMode ? basisFormat : basisFallbackFormat,\n                imageArray\n            };\n        }\n    };\n\n    self.onmessage = (e: { data: Partial<IInitializeTranscoderMessage | ITranscodeMessage> }): void =>\n    {\n        const msg = e.data;\n        const response = messageHandlers[msg.type](msg as any);\n\n        if (response)\n        {\n            (self as any).postMessage(response);\n        }\n    };\n}\n","import { TranscoderWorkerWrapper } from './TranscoderWorkerWrapper';\n\nimport type { BASIS_FORMATS } from './Basis';\nimport type { ITranscodeResponse } from './TranscoderWorkerWrapper';\n\n/**\n * Worker class for transcoding *.basis files in background threads.\n *\n * To enable asynchronous transcoding, you need to provide the URL to the basis_universal transcoding\n * library.\n * @memberof PIXI.BasisParser\n */\nexport class TranscoderWorker\n{\n    // IMPLEMENTATION NOTE: TranscoderWorker tracks transcoding requests with a requestID; the worker can be issued\n    // multiple requests (once it is initialized) and the response contains the requestID of the triggering request. Based on\n    // the response, the transcodeAsync promise is fulfilled or rejected.\n\n    // TODO: Publish our own @pixi/basis package & set default URL to jsdelivr/cdnjs\n    /** URL for the script containing the basis_universal library. */\n    static bindingURL: string;\n    static jsSource: string;\n    static wasmSource: ArrayBuffer;\n\n    private static _onTranscoderInitializedResolve: () => void;\n\n    /** a promise that when reslved means the transcoder is ready to be used */\n    public static onTranscoderInitialized = new Promise<void>((resolve) =>\n    {\n        TranscoderWorker._onTranscoderInitializedResolve = resolve;\n    });\n\n    isInit: boolean;\n    load: number;\n    requests: { [id: number]: {\n        resolve: (data: ITranscodeResponse) => void,\n        reject: () => void\n    } } = {};\n\n    private static _workerURL: string;\n    private static _tempID = 0;\n\n    /** Generated URL for the transcoder worker script. */\n    static get workerURL(): string\n    {\n        if (!TranscoderWorker._workerURL)\n        {\n            let workerSource = TranscoderWorkerWrapper.toString();\n\n            const beginIndex = workerSource.indexOf('{');\n            const endIndex = workerSource.lastIndexOf('}');\n\n            workerSource = workerSource.slice(beginIndex + 1, endIndex);\n\n            if (TranscoderWorker.jsSource)\n            {\n                workerSource = `${TranscoderWorker.jsSource}\\n${workerSource}`;\n            }\n\n            TranscoderWorker._workerURL = URL.createObjectURL(new Blob([workerSource]));\n        }\n\n        return TranscoderWorker._workerURL;\n    }\n\n    protected worker: Worker;\n    protected initPromise: Promise<void>;\n    protected onInit: () => void;\n\n    constructor()\n    {\n        this.isInit = false;\n        this.load = 0;\n        this.initPromise = new Promise((resolve) => { this.onInit = resolve; });\n\n        if (!TranscoderWorker.wasmSource)\n        {\n            console.warn('resources.BasisResource.TranscoderWorker has not been given the transcoder WASM binary!');\n        }\n\n        this.worker = new Worker(TranscoderWorker.workerURL);\n        this.worker.onmessage = this.onMessage;\n        this.worker.postMessage({\n            type: 'init',\n            jsSource: TranscoderWorker.jsSource,\n            wasmSource: TranscoderWorker.wasmSource\n        });\n    }\n\n    /** @returns a promise that is resolved when the web-worker is initialized */\n    initAsync(): Promise<void>\n    {\n        return this.initPromise;\n    }\n\n    /**\n     * Creates a promise that will resolve when the transcoding of a *.basis file is complete.\n     * @param basisData - *.basis file contents\n     * @param rgbaFormat - transcoding format for RGBA files\n     * @param rgbFormat - transcoding format for RGB files\n     * @returns a promise that is resolved with the transcoding response of the web-worker\n     */\n    async transcodeAsync(\n        basisData: Uint8Array,\n        rgbaFormat: BASIS_FORMATS,\n        rgbFormat: BASIS_FORMATS\n    ): Promise<ITranscodeResponse>\n    {\n        ++this.load;\n\n        const requestID = TranscoderWorker._tempID++;\n        const requestPromise = new Promise((resolve: (data: ITranscodeResponse) => void, reject: () => void) =>\n        {\n            this.requests[requestID] = {\n                resolve,\n                reject\n            };\n        });\n\n        this.worker.postMessage({\n            requestID,\n            basisData,\n            rgbaFormat,\n            rgbFormat,\n            type: 'transcode'\n        });\n\n        return requestPromise;\n    }\n\n    /**\n     * Handles responses from the web-worker\n     * @param e - a message event containing the transcoded response\n     */\n    protected onMessage = (e: MessageEvent): void =>\n    {\n        const data = e.data as ITranscodeResponse;\n\n        if (data.type === 'init')\n        {\n            if (!data.success)\n            {\n                throw new Error('BasisResource.TranscoderWorker failed to initialize.');\n            }\n\n            this.isInit = true;\n            this.onInit();\n        }\n        else if (data.type === 'transcode')\n        {\n            --this.load;\n\n            const requestID = data.requestID;\n\n            if (data.success)\n            {\n                this.requests[requestID].resolve(data);\n            }\n            else\n            {\n                this.requests[requestID].reject();\n            }\n\n            delete this.requests[requestID];\n        }\n    };\n\n    /**\n     * Loads the transcoder source code\n     * @param jsURL - URL to the javascript basis transcoder\n     * @param wasmURL - URL to the wasm basis transcoder\n     * @returns A promise that resolves when both the js and wasm transcoders have been loaded.\n     */\n    static loadTranscoder(jsURL: string, wasmURL: string): Promise<[void, void]>\n    {\n        const jsPromise = fetch(jsURL)\n            .then((res: Response) => res.text())\n            .then((text: string) => { TranscoderWorker.jsSource = text; });\n        const wasmPromise = fetch(wasmURL)\n            .then((res: Response) => res.arrayBuffer())\n            .then((arrayBuffer: ArrayBuffer) => { TranscoderWorker.wasmSource = arrayBuffer; });\n\n        return Promise.all([jsPromise, wasmPromise]).then((data) =>\n\n        {\n            this._onTranscoderInitializedResolve();\n\n            return data;\n        });\n    }\n\n    /**\n     * Set the transcoder source code directly\n     * @param jsSource - source for the javascript basis transcoder\n     * @param wasmSource - source for the wasm basis transcoder\n     */\n    static setTranscoder(jsSource: string, wasmSource: ArrayBuffer): void\n    {\n        TranscoderWorker.jsSource = jsSource;\n        TranscoderWorker.wasmSource = wasmSource;\n    }\n}\n","import { CompressedTextureResource } from '@pixi/compressed-textures';\nimport { BufferResource, settings, TYPES } from '@pixi/core';\nimport {\n    BASIS_FORMAT_TO_INTERNAL_FORMAT,\n    BASIS_FORMATS,\n    BASIS_FORMATS_ALPHA,\n    INTERNAL_FORMAT_TO_BASIS_FORMAT,\n} from '../Basis';\nimport { TranscoderWorker } from '../TranscoderWorker';\n\nimport type { CompressedLevelBuffer, INTERNAL_FORMATS } from '@pixi/compressed-textures';\nimport type { BasisBinding, BasisTextureExtensions } from '../Basis';\n\nexport type TranscodedResourcesArray = (Array<CompressedTextureResource> | Array<BufferResource>) & {\n    basisFormat: BASIS_FORMATS\n};\n\n/**\n * Loader plugin for handling BASIS supercompressed texture files.\n *\n * To use this loader, you must bind the basis_universal WebAssembly transcoder. There are two ways of\n * doing this:\n *\n * 1. Adding a &lt;script&gt; tag to your HTML page to the transcoder bundle in this package, and serving\n * the WASM binary from the same location.\n *\n * ```html\n * <!-- Copy ./node_modules/@pixi/basis/assets/basis_.wasm into your assets directory\n *     as well, so it is served from the same folder as the JavaScript! -->\n * <script src=\"./node_modules/@pixi/basis/assets/basis_transcoder.js\"></script>\n * ```\n *\n * NOTE: `basis_transcoder.js` expects the WebAssembly binary to be named `basis_transcoder.wasm`.\n * NOTE-2: This method supports transcoding on the main-thread. Only use this if you have 1 or 2 *.basis\n * files.\n *\n * 2. Loading the transcoder source from a URL.\n *\n * ```js\n * // Use this if you to use the default CDN url for @pixi/basis\n * BasisParser.loadTranscoder();\n *\n * // Use this if you want to serve the transcoder on your own\n * BasisParser.loadTranscoder('./basis_transcoder.js', './basis_transcoder.wasm');\n * ```\n *\n * NOTE: This can only be used with web-workers.\n * @class\n * @memberof PIXI\n * @implements {PIXI.ILoaderPlugin}\n */\nexport class BasisParser\n{\n    public static basisBinding: BasisBinding;\n    private static defaultRGBFormat: { basisFormat: BASIS_FORMATS, textureFormat: INTERNAL_FORMATS | TYPES };\n    private static defaultRGBAFormat: { basisFormat: BASIS_FORMATS, textureFormat: INTERNAL_FORMATS | TYPES };\n    private static fallbackMode = false;\n    private static workerPool: TranscoderWorker[] = [];\n\n    /**\n     * Runs transcoding and populates imageArray. It will run the transcoding in a web worker\n     * if they are available.\n     * @private\n     */\n    public static async transcode(arrayBuffer: ArrayBuffer): Promise<TranscodedResourcesArray>\n    {\n        let resources: TranscodedResourcesArray;\n\n        if (typeof Worker !== 'undefined' && BasisParser.TranscoderWorker.wasmSource)\n        {\n            resources = await BasisParser.transcodeAsync(arrayBuffer);\n        }\n        else\n        {\n            resources = BasisParser.transcodeSync(arrayBuffer);\n        }\n\n        return resources;\n    }\n\n    /**\n     * Finds a suitable worker for transcoding and sends a transcoding request\n     * @private\n     * @async\n     */\n    public static async transcodeAsync(arrayBuffer: ArrayBuffer): Promise<TranscodedResourcesArray>\n    {\n        if (!BasisParser.defaultRGBAFormat && !BasisParser.defaultRGBFormat)\n        {\n            BasisParser.autoDetectFormats();\n        }\n\n        const workerPool = BasisParser.workerPool;\n\n        let leastLoad = 0x10000000;\n        let worker = null;\n\n        for (let i = 0, j = workerPool.length; i < j; i++)\n        {\n            if (workerPool[i].load < leastLoad)\n            {\n                worker = workerPool[i];\n                leastLoad = worker.load;\n            }\n        }\n\n        if (!worker)\n        {\n            /* eslint-disable-next-line no-use-before-define */\n            worker = new TranscoderWorker();\n\n            workerPool.push(worker);\n        }\n\n        // Wait until worker is ready\n        await worker.initAsync();\n\n        const response = await worker.transcodeAsync(\n            new Uint8Array(arrayBuffer),\n            BasisParser.defaultRGBAFormat.basisFormat,\n            BasisParser.defaultRGBFormat.basisFormat,\n        );\n\n        const basisFormat = response.basisFormat;\n        const imageArray = response.imageArray;\n\n        // whether it is an uncompressed format\n        const fallbackMode = basisFormat > 12;\n        let imageResources: TranscodedResourcesArray;\n\n        if (!fallbackMode)\n        {\n            const format = BASIS_FORMAT_TO_INTERNAL_FORMAT[response.basisFormat];\n\n            // HINT: this.imageArray is CompressedTextureResource[]\n            imageResources = new Array<CompressedTextureResource>(imageArray.length) as TranscodedResourcesArray;\n\n            for (let i = 0, j = imageArray.length; i < j; i++)\n            {\n                imageResources[i] = new CompressedTextureResource(null, {\n                    format,\n                    width: imageArray[i].width,\n                    height: imageArray[i].height,\n                    levelBuffers: imageArray[i].levelArray,\n                    levels: imageArray[i].levelArray.length,\n                });\n            }\n        }\n        else\n        {\n            // TODO: BufferResource does not support manual mipmapping.\n            imageResources = imageArray.map((image) => new BufferResource(\n                new Uint16Array(image.levelArray[0].levelBuffer.buffer), {\n                    width: image.width,\n                    height: image.height,\n                }),\n            ) as TranscodedResourcesArray;\n        }\n\n        imageResources.basisFormat = basisFormat;\n\n        return imageResources;\n    }\n\n    /**\n     * Runs transcoding on the main thread.\n     * @private\n     */\n    public static transcodeSync(arrayBuffer: ArrayBuffer): TranscodedResourcesArray\n    {\n        if (!BasisParser.defaultRGBAFormat && !BasisParser.defaultRGBFormat)\n        {\n            BasisParser.autoDetectFormats();\n        }\n\n        const BASIS = BasisParser.basisBinding;\n\n        const data = new Uint8Array(arrayBuffer);\n        const basisFile = new BASIS.BasisFile(data);\n        const imageCount = basisFile.getNumImages();\n        const hasAlpha = basisFile.getHasAlpha();\n\n        const basisFormat = hasAlpha\n            ? BasisParser.defaultRGBAFormat.basisFormat\n            : BasisParser.defaultRGBFormat.basisFormat;\n        const basisFallbackFormat = BASIS_FORMATS.cTFRGB565;\n        const imageResources = new Array<CompressedTextureResource | BufferResource>(imageCount);\n\n        let fallbackMode = BasisParser.fallbackMode;\n\n        if (!basisFile.startTranscoding())\n        {\n            if (process.env.DEBUG)\n            {\n                console.error(`Basis failed to start transcoding!`);\n            }\n\n            basisFile.close();\n            basisFile.delete();\n\n            return null;\n        }\n\n        for (let i = 0; i < imageCount; i++)\n        {\n            // Don't transcode all mipmap levels in fallback mode!\n            const levels = !fallbackMode ? basisFile.getNumLevels(i) : 1;\n            const width = basisFile.getImageWidth(i, 0);\n            const height = basisFile.getImageHeight(i, 0);\n            const alignedWidth = (width + 3) & ~3;\n            const alignedHeight = (height + 3) & ~3;\n\n            const imageLevels = new Array<CompressedLevelBuffer>(levels);\n\n            // Transcode mipmap levels into \"imageLevels\"\n            for (let j = 0; j < levels; j++)\n            {\n                const levelWidth = basisFile.getImageWidth(i, j);\n                const levelHeight = basisFile.getImageHeight(i, j);\n                const byteSize = basisFile.getImageTranscodedSizeInBytes(\n                    i, 0, !fallbackMode ? basisFormat : basisFallbackFormat);\n\n                imageLevels[j] = {\n                    levelID: j,\n                    levelBuffer: new Uint8Array(byteSize),\n                    levelWidth,\n                    levelHeight,\n                };\n\n                if (!basisFile.transcodeImage(\n                    imageLevels[j].levelBuffer, i, 0, !fallbackMode ? basisFormat : basisFallbackFormat, false, false))\n                {\n                    if (fallbackMode)\n                    {\n                        if (process.env.DEBUG)\n                        {\n                            console.error(`Basis failed to transcode image ${i}, level ${0}!`);\n                        }\n                        break;\n                    }\n                    else\n                    {\n                        // Try transcoding to an uncompressed format before giving up!\n                        // NOTE: We must start all over again as all Resources must be in compressed OR uncompressed.\n                        i = -1;\n                        fallbackMode = true;\n\n                        if (process.env.DEBUG)\n                        {\n                        /* eslint-disable-next-line max-len */\n                            console.warn(`Basis failed to transcode image ${i}, level ${0} to a compressed texture format. Retrying to an uncompressed fallback format!`);\n                        }\n                        continue;\n                    }\n                }\n            }\n\n            let imageResource;\n\n            if (!fallbackMode)\n            {\n                imageResource = new CompressedTextureResource(null, {\n                    format: BASIS_FORMAT_TO_INTERNAL_FORMAT[basisFormat],\n                    width: alignedWidth,\n                    height: alignedHeight,\n                    levelBuffers: imageLevels,\n                    levels,\n                });\n            }\n            else\n            {\n                // TODO: BufferResource doesn't support manual mipmap levels\n                imageResource = new BufferResource(\n                    new Uint16Array(imageLevels[0].levelBuffer.buffer), { width, height });\n            }\n\n            imageResources[i] = imageResource;\n        }\n\n        basisFile.close();\n        basisFile.delete();\n\n        const transcodedResources = imageResources as TranscodedResourcesArray;\n\n        transcodedResources.basisFormat = !fallbackMode ? basisFormat : basisFallbackFormat;\n\n        return transcodedResources;\n    }\n\n    /**\n     * Detects the available compressed texture formats on the device.\n     * @param extensions - extensions provided by a WebGL context\n     * @ignore\n     */\n    static autoDetectFormats(extensions?: Partial<BasisTextureExtensions>): void\n    {\n        // Auto-detect WebGL compressed-texture extensions\n        if (!extensions)\n        {\n            const canvas = settings.ADAPTER.createCanvas();\n            const gl = canvas.getContext('webgl');\n\n            if (!gl)\n            {\n                console.error('WebGL not available for BASIS transcoding. Silently failing.');\n\n                return;\n            }\n\n            extensions = {\n                bptc: gl.getExtension('EXT_texture_compression_bptc'),\n                astc: gl.getExtension('WEBGL_compressed_texture_astc'),\n                etc: gl.getExtension('WEBGL_compressed_texture_etc'),\n                s3tc: gl.getExtension('WEBGL_compressed_texture_s3tc'),\n                s3tc_sRGB: gl.getExtension('WEBGL_compressed_texture_s3tc_srgb'), /* eslint-disable-line camelcase */\n                pvrtc: gl.getExtension('WEBGL_compressed_texture_pvrtc')\n                    || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc'),\n                etc1: gl.getExtension('WEBGL_compressed_texture_etc1'),\n                atc: gl.getExtension('WEBGL_compressed_texture_atc'),\n            };\n        }\n\n        // Discover the available texture formats\n        const supportedFormats: { [id: string]: INTERNAL_FORMATS } = {};\n\n        for (const key in extensions)\n        {\n            const extension = (extensions as any)[key];\n\n            if (!extension)\n            {\n                continue;\n            }\n\n            Object.assign(supportedFormats, Object.getPrototypeOf(extension));\n        }\n\n        // Set the default alpha/non-alpha output formats for basisu transcoding\n        for (let i = 0; i < 2; i++)\n        {\n            const detectWithAlpha = !!i;\n            let internalFormat: number;\n            let basisFormat: number;\n\n            for (const id in supportedFormats)\n            {\n                internalFormat = supportedFormats[id];\n                basisFormat = INTERNAL_FORMAT_TO_BASIS_FORMAT[internalFormat];\n\n                if (basisFormat !== undefined)\n                {\n                    if ((detectWithAlpha && BASIS_FORMATS_ALPHA[basisFormat])\n                        || (!detectWithAlpha && !BASIS_FORMATS_ALPHA[basisFormat]))\n                    {\n                        break;\n                    }\n                }\n            }\n\n            if (internalFormat)\n            {\n                BasisParser[detectWithAlpha ? 'defaultRGBAFormat' : 'defaultRGBFormat'] = {\n                    textureFormat: internalFormat,\n                    basisFormat,\n                };\n            }\n            else\n            {\n                BasisParser[detectWithAlpha ? 'defaultRGBAFormat' : 'defaultRGBFormat'] = {\n                    textureFormat: TYPES.UNSIGNED_SHORT_5_6_5,\n                    basisFormat: BASIS_FORMATS.cTFRGB565,\n                };\n\n                BasisParser.fallbackMode = true;\n            }\n        }\n    }\n\n    /**\n     * Binds the basis_universal transcoder to decompress *.basis files. You must initialize the transcoder library yourself.\n     * @example\n     * import { BasisParser } from '@pixi/basis';\n     *\n     * // BASIS() returns a Promise-like object\n     * globalThis.BASIS().then((basisLibrary) =>\n     * {\n     *     // Initialize basis-library; otherwise, transcoded results maybe corrupt!\n     *     basisLibrary.initializeBasis();\n     *\n     *     // Bind BasisParser to the transcoder\n     *     BasisParser.bindTranscoder(basisLibrary);\n     * });\n     * @param basisLibrary - the initialized transcoder library\n     * @private\n     */\n    static bindTranscoder(basisLibrary: BasisBinding): void\n    {\n        BasisParser.basisBinding = basisLibrary;\n    }\n\n    /**\n     * Loads the transcoder source code for use in {@link PIXI.BasisParser.TranscoderWorker}.\n     * @private\n     * @param jsURL - URL to the javascript basis transcoder\n     * @param wasmURL - URL to the wasm basis transcoder\n     */\n    static loadTranscoder(jsURL: string, wasmURL: string): Promise<[void, void]>\n    {\n        return BasisParser.TranscoderWorker.loadTranscoder(jsURL, wasmURL);\n    }\n\n    /**\n     * Set the transcoder source code directly\n     * @private\n     * @param jsSource - source for the javascript basis transcoder\n     * @param wasmSource - source for the wasm basis transcoder\n     */\n    static setTranscoder(jsSource: string, wasmSource: ArrayBuffer): void\n    {\n        BasisParser.TranscoderWorker.setTranscoder(jsSource, wasmSource);\n    }\n\n    static TranscoderWorker: typeof TranscoderWorker = TranscoderWorker;\n\n    static get TRANSCODER_WORKER_POOL_LIMIT(): number\n    {\n        return this.workerPool.length || 1;\n    }\n\n    static set TRANSCODER_WORKER_POOL_LIMIT(limit: number)\n    {\n        // TODO: Destroy workers?\n        for (let i = this.workerPool.length; i < limit; i++)\n        {\n            this.workerPool[i] = new TranscoderWorker();\n            this.workerPool[i].initAsync();\n        }\n    }\n}\n","import { extensions, ExtensionType } from '@pixi/core';\nimport { BasisParser } from './BasisParser';\n\nimport type { FormatDetectionParser } from '@pixi/assets';\n\nexport const detectBasis = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 3,\n    },\n    test: async (): Promise<boolean> => !!(BasisParser.basisBinding && BasisParser.TranscoderWorker.wasmSource),\n    add: async (formats) => [...formats, 'basis'],\n    remove: async (formats) => formats.filter((f) => f !== 'basis'),\n} as FormatDetectionParser;\n\nextensions.add(detectBasis);\n","import { checkExtension, createTexture, LoaderParserPriority } from '@pixi/assets';\nimport { CompressedTextureResource } from '@pixi/compressed-textures';\nimport { ALPHA_MODES, BaseTexture, extensions, ExtensionType, FORMATS, MIPMAP_MODES, settings } from '@pixi/core';\nimport { BASIS_FORMAT_TO_TYPE, BASIS_FORMATS } from '../Basis';\nimport { TranscoderWorker } from '../TranscoderWorker';\nimport { BasisParser } from './BasisParser';\n\nimport type { Loader, LoaderParser, ResolvedAsset } from '@pixi/assets';\nimport type { IBaseTextureOptions, Texture, TYPES } from '@pixi/core';\n\n/** Load BASIS textures! */\nexport const loadBasis = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.High,\n    },\n\n    name: 'loadBasis',\n\n    test(url: string): boolean\n    {\n        return checkExtension(url, '.basis');\n    },\n\n    async load(url: string, asset: ResolvedAsset, loader: Loader): Promise<Texture | Texture[]>\n    {\n        await TranscoderWorker.onTranscoderInitialized;\n\n        // get an array buffer...\n        const response = await settings.ADAPTER.fetch(url);\n\n        const arrayBuffer = await response.arrayBuffer();\n\n        const resources = await BasisParser.transcode(arrayBuffer);\n\n        const type: TYPES = BASIS_FORMAT_TO_TYPE[resources.basisFormat];\n        const format: FORMATS = resources.basisFormat !== BASIS_FORMATS.cTFRGBA32 ? FORMATS.RGB : FORMATS.RGBA;\n\n        const textures = resources.map((resource) =>\n        {\n            const base = new BaseTexture(resource, {\n                mipmap: resource instanceof CompressedTextureResource && resource.levels > 1\n                    ? MIPMAP_MODES.ON_MANUAL\n                    : MIPMAP_MODES.OFF,\n                alphaMode: ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,\n                type,\n                format,\n                ...asset.data,\n            });\n\n            return createTexture(base, loader, url);\n        });\n\n        return textures.length === 1 ? textures[0] : textures;\n    },\n\n    unload(texture): void\n    {\n        if (Array.isArray(texture))\n        {\n            texture.forEach((t) => t.destroy(true));\n        }\n        else\n        {\n            texture.destroy(true);\n        }\n    }\n\n} as LoaderParser<Texture | Texture[], IBaseTextureOptions>;\n\nextensions.add(loadBasis);\n"],"names":["BASIS_FORMATS","BASIS_FORMAT_TO_INTERNAL_FORMAT","INTERNAL_FORMATS","BASIS_FORMAT_TO_TYPE","TYPES","INTERNAL_FORMAT_TO_BASIS_FORMAT","key","reverseMap","basisFormat","BASIS_FORMATS_ALPHA","TranscoderWorkerWrapper","basisBinding","messageHandlers","message","basisLibrary","basisData","BASIS","data","basisFile","imageCount","basisFallbackFormat","imageArray","fallbackMode","i","levels","imageResource","j","format","width","height","byteSize","alignedWidth","alignedHeight","imageBuffer","e","msg","response","_TranscoderWorker","requestID","resolve","workerSource","beginIndex","endIndex","rgbaFormat","rgbFormat","requestPromise","reject","jsURL","wasmURL","jsPromise","res","text","wasmPromise","arrayBuffer","jsSource","wasmSource","TranscoderWorker","_BasisParser","resources","workerPool","leastLoad","worker","imageResources","image","BufferResource","CompressedTextureResource","imageLevels","levelWidth","levelHeight","transcodedResources","extensions","gl","settings","supportedFormats","extension","detectWithAlpha","internalFormat","id","limit","BasisParser","detectBasis","ExtensionType","formats","f","P","u","x","n","s","p","loadBasis","LoaderParserPriority","url","checkExtension","asset","loader","type","FORMATS","textures","resource","base","BaseTexture","__spreadValues","MIPMAP_MODES","ALPHA_MODES","createTexture","texture","t"],"mappings":"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"}